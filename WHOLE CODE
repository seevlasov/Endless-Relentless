/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/#include "zcommon.acs" #include "zdaemon.acs"	#import "GLOBALY"
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/#libdefine PBslots 5 #libdefine MBslots 10
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/#libdefine ZDaemon 1 #libdefine Zandronum 2 #libdefine GZDoom 3
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMM Z MMMNhhhhhhhhhhhhhhhhhhhhhmMNhhhhhhhhhhhhhhhhhhhhhhhhhmMmhhhhhhhhhhhhhhhhhhhNMdhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhmMMmhhhhhhhhhhhhhhhMMhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhNMdhhhhhhhhhhhhhhhhhhhhhNMmhhhhhhhhhhhhhhhhhhhhhhNMMMMMMMMM
MMMMMMMMMMMMMMMMMMMo                     yMy               .o/       +M+                   mN`                                   `+mm+.            `Nm                         -oo-            dM.                    `dM-                     .NMMMMMMMMM
MMMMMMMMMMMM E MMMM.                    `NM:               -My       +M+                   mN`                                     .omd+`          `Nm                       -ymh:             dM`                    -Md                      oMMMMMMMMMM
MMMMMMMMMMMMMMMMMNh                     /Mm                -My       +M+                   mN`                                       .omd/`        `Nm                     .smh:               dM`                    yM/                     `mMMMMMMMMMM
MMMMMMMMMMM B MMMMo............`        hMo     .........../My       +M+       `...........mN-...........................              .omd/       `Nm        ...........-smh:     `...........dM`       ............-NN`        L A          /MMMMMMMMMMM
MMMMMMMMMMMMMMMMNNddddddddddddd-       .MM.    `hddddddddddmMy       +M+       odddddddddddNMddddddddmNNddddddddddmNmddNNs.              .mN`      `Nm       .dddddddddddmMs       +dddddddddddNM`      `hdddddddddddNMo                      hMMMMMMMMMMM
MMMMMMMMMM E MMMMs                     oMd                 :My       +M+                   mN`       -yNh-`       :Ms  :hNNs.             dM`      `Nm                   +M+                   dM`                  `mN.                     .MMMMMMMMMMMM
MMMMMMMMMMMMMMMdM-                     mM/                 -My       +M+                   mN`         -yNo       :Ms    :hMNs.           dM`      `Nm                   /M+                   dM`                  :Mh                      sMMMMMMMMMMMM
MMMMMMMMM R MMMMm                     :MN`                 -My       +M+                   mN`           -+       :Ms      :hMNs.         dM`      `Nm                   /M+                   dM`                  hM:                     `NMMMMMMMMMMMM
MMMMMMMMMMMMMMyMo                   ..yMs       .........../My       +M+       `...........mN`                    :Ms        :dMNs`       dM`      `Nm        ...........oMo...........        dM-...........      .Md      O U T E R       +MMMMMMMMMMMMM
MMMMMMMM P MMMNM.                   /mMM:      `dddddddddddmMy       /Mh.      odddddddddddMN`                    :Ms          :hd:       dM`       mN:      .dddddddddddmMNddddddddddd-      :NMdddddddddddh      sM+                      mMMMMMMMMMMMMM
MMMMMMMMMMMMMMMh                      /mm+`                :My        :hNs.                mN`                    :Ms                     dM`       `sNd:                /M+                :hNy.                 `NN`    W O R L D S      :MMMMMMMMMMMMMM
MMMMMMM A MMMhM/        yo.            `+mm+`              -My          :dNs.              mN`      .d:           :Ms                     dM`         .sNd:              /M+              :hNy.                   +Ms                      hMMMMMMMMMMMMMM
MMMMMMMMMMMMMNm`        /dNo.            `+mm+`            -My           `:dNs.            mN`      `sNd:         :Ms                     dM`           .sNh:            /M+            :hNy-                     dM-                     .MMMMMMMMMMMMMMM
MMMMMM L 's        ......-oNNo.............-//-............/My.............-+NNs...........//.........:hMh:......./My.....................:/..............:hNh:..........+Mo............//:....................../Md......................sMMMMMMMMMMMMMMM
MMMMMMMMMMMMMNNNNNNNNNNNNNNMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNMMNNNNNNNNNNNNNNNMMMNNNNNNNNNNNNNNNNNNNNNNNNMMNNNNNNNNNMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNMMNNNNNNNNNNNNMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNMNNNNNNNNNNNNNNNNNNNNNNNMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMM/   \MMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMMMMMMMMMMMMMMMM/   \MMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMMMMMMMMMMM
MMMMMMMM  E  MMMMMMM  N  MMMMMMMM  D  MMMMMMMM  L  MMMMMMMM  E  MMMMMMMM  S  MMMMMMMM  S  MMMMMMMMMMMMMMMMMMMMMM  R  MMMMMMM  E  MMMMMMMM  L  MMMMMMMM  E  MMMMMMMM  N  MMMMMMMM  T  MMMMMMMM  L  MMMMMMMM  E  MMMMMMMM  S  MMMMMMMM  S  MMMMMMMMMMMMMMMMM
MMMMMMMM\   /MMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMMMMMMMMMMMMMMMM\   /MMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/ str BlockAt[PBslots][PBslots] = {{"Z"}};
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/Script "OfficialServer" (void) NET CLIENTSIDE{Switch(GetPort()){CASE
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/GZDoom: DemoMessage(1);break; CASE Zandronum:ConsoleCommand("connect
/*			This game was made to be compatible with 3 ports: ZDaemon, Zandronum and GZDoom. If you see some strange coding decisions, most likely ZDaemon compatibility is the reason for that.
			ZDaemon is an old-ass port and requires some gimmicky wayouts here and there. For example:
			1)When you compile it, make sure none of the scripts or functions carries more than 20 scope-defined variables inside of it!
			2)Don't use 'random`, use RNG function instead!
			3)Don't use StrParam function if it lasts longer than 1 cycle. A string will be lost the next tic! I use map sectors at the bottom to store important strparam info.
			4)Any new string should be at least defined as ''. Otherwise it can cause bugs in Zdaemon.
*/





    54.38.214.142:10666   "		/*		OFFICIAL SERVER ADDRESS (Blue Firestick)	Zandronum*/																																						);break;}}






/*

  ______   ______   .__   __.      _______.___________.    ___      .__   __. .___________.    _______.
 /      | /  __  \  |  \ |  |     /       |           |   /   \     |  \ |  | |           |   /       |
|  ,----'|  |  |  | |   \|  |    |   (----`---|  |----`  /  ^  \    |   \|  | `---|  |----`  |   (----`
|  |     |  |  |  | |  . `  |     \   \       |  |      /  /_\  \   |  . `  |     |  |        \   \
|  `----.|  `--'  | |  |\   | .----)   |      |  |     /  _____  \  |  |\   |     |  |    .----)   |
 \______| \______/  |__| \__| |_______/       |__|    /__/     \__\ |__| \__|     |__|    |_______/


*/



/////////////////////////////////////// ACTOR TIDS

#libdefine PLAYER_TID 					32000	// Player Header
#libdefine ImpossibleNum				32754

#libdefine PlayerRadius					16
#libdefine PlayerHeight					56


#libdefine ACTORTID_PortalsUpper 		20
#libdefine ACTORTID_PortalsLower 		21
#libdefine ACTORTID_InputArea 			3
#libdefine ACTORTID_SkyboxCamera 		32765
#libdefine ACTORTID_DynamicTid 			10000	// - 11000
#libdefine ACTORTID_PlayerSpawner 		11000	//
#libdefine ACTORTID_Projectile 			32730
#libdefine ACTORTID_Item 				32731
#libdefine ACTORTID_AmbientSound 		32732
#libdefine ACTORTID_AmbientSpot 		32733
#libdefine ACTORTID_AmbientWater 		32734

#libdefine ACTORTID_PortSpot 		32767
#libdefine ACTORTID_ZandronumTag 		32766
#libdefine ACTORTID_DebugCamera 		32764
#libdefine ACTORTID_GZDoomTag 			32763
#libdefine ACTORTID_InputPortal			32762
#libdefine ACTORTID_SkyfallInner		32761


#libdefine ACTORTID_MainTeleport 		1
#libdefine ACTORTID_Enemy 				32099
#libdefine ACTORTID_Boss				32098
#libdefine ACTORTID_Temp				32097

#libdefine ACTORTID_Hub 				32100
#libdefine ACTORTID_Skyfall 			32200
#libdefine SkyfallOffset 				4480

//////////////////////////////////////// SECTOR TAGS

#libdefine SECTORTAG_Hub 				2
#libdefine SECTORTAG_pit 				99
#libdefine SECTORTAG_Skybox 			30000	// 30001 - 30064
#libdefine SECTORTAG_Spawn				11
#libdefine SECTORTAG_ShaftCore			5
#libdefine SECTORTAG_ShaftCoreEdge		32767
#libdefine SECTORTAG_ShaftSlope			32766
#libdefine SECTORTAG_SkyfallGround		32765
#libdefine SECTORTAG_ShaftOuterEdge		32764
#libdefine SECTORTAG_ShaftOuterPaling	32763

#libdefine TIDRAM_WinnerNames 			10000
#libdefine TIDRAM_LegendNames 			10300
#libdefine TIDRAM_ExitMarkerA 			10400
#libdefine TIDRAM_ExitMarkerB			10401
#libdefine TIDRAM_SkyboxVolume 			10402
#libdefine TIDRAM_HubMusic 				10403
#libdefine TIDRAM_WinCamera 			10404
#libdefine TIDRAM_MapReset	 			10405
#libdefine TIDRAM_MoneyChar	 			10406
#libdefine TIDRAM_Port					10407
#libdefine TIDRAM_CantJoinZDA			10408
#libdefine TIDRAM_Money	 				10500 // - 10531

/////////////////////////////////////// LINE TAGS
#libdefine LINETAG_PlaygroundPerimeter	99
#libdefine LINETAG_ShaftEdge			98
#libdefine LINETAG_ShaftBase			97
#libdefine LINETAG_SkyfallPaling		96
#libdefine LINETAG_PlaygroundFence		95
#libdefine LINETAG_VolumetricA 			32756
#libdefine LINETAG_VolumetricB 			32757
#libdefine LINETAG_VolumetricC			32758
#libdefine LINETAG_VolumetricD_up		32759
#libdefine LINETAG_VolumetricD_dn		32760


#libdefine LINETAG_ZDaemonLegends 		30100
#libdefine LINETAG_ZandronumLegends		30208


#libdefine LINETAG_VolumetricPortal		32755
#libdefine LINETAG_Skybox				30000 //30001 - 30064


#libdefine CapeHeader 	   				5000
#libdefine CapeHeaderINNER 				CapeHeader + 50




#libdefine PlayerDiameter				32

//////////////////////////////////////


#libdefine MainMap						1
#libdefine TitleMap						99


#libdefine For_ActivatorOnly 			0
#libdefine For_Everyone					1

#libdefine GenDel_FloorFifth 			2
#libdefine GenDel_Border 				4
#libdefine GenDel_Height 				1

#libdefine MaxMiniBlocks 				80

#libdefine None 						0

#libdefine BottomLine 					-1
#libdefine Sec 							35
#libdefine DemoTime						60*5
#libdefine BYTE 						0
#libdefine FIXED 						1


#libdefine PlaygroundBlocks 			PBslots*PBslots
#libdefine MiniBlocks 					MBslots*MBslots

#libdefine MaxContainerTries 			16
#libdefine MaxRounds 					5
#libdefine DOESNT_MATTER 				-1

#libdefine MaxPlayers					32
#libdefine MaxStages					25
#libdefine MaxLegends 					3
#libdefine MaxMoney						250
#libdefine PanicTime 					30
#libdefine JoinTime 					15
#libdefine FlowInverseTime 				15

#libdefine TakeBreath 					Sec*4
#libdefine MoveInstantly 				65536
#libdefine MinAllowedInput 				3
#libdefine InstantDeath 				666

#libdefine NotSpectator 				0
#libdefine TrueSpectator 				1
#libdefine DeadSpectator 				2

#libdefine MaxNameCharsZDA 	6
#libdefine MaxNameCharsZAN 	12
#libdefine MaxPortNameCharsZDA 	15
#libdefine MaxPortNameCharsZAN 	32

#libdefine MaxInfoChars					55

#libdefine MaxByte						32767

#libdefine fromCvar_WINNERS 			0
#libdefine fromArray_WinnerNames 		1
#libdefine fromCvar_LEGENDS 			2
#libdefine fromArray_LegendNames 		3





#libdefine OneBlock 					1
#libdefine TwoBlocks 					2
#libdefine ThreeBlocks 					3
#libdefine FourBlocks 					4
#libdefine AllowedContainerTypes 		4
#libdefine StartBlock 					999
#libdefine FinishBlock 					998
#libdefine SpecialBlocks 				998


#libdefine ToRIGHT 						1
#libdefine ToDOWN 						2
#libdefine ToLEFT 						3
#libdefine ToUP 						4
#libdefine ToRIGHT_or_ToLEFT 			5
#libdefine ToUP_or_ToDOWN 				6
#libdefine ANG_to_RIGHT 				256
#libdefine ANG_to_DOWN 					192
#libdefine ANG_to_LEFT 					128
#libdefine ANG_to_UP 					64
#libdefine ANG_to_UpRight 				32
#libdefine ANG_to_RightDown 			224
#libdefine ANG_to_DownLeft				160
#libdefine ANG_to_LeftUp				96

#libdefine Stairs_NORMAL 				1
#libdefine Stairs_DIAGONAL_right 		2
#libdefine Stairs_DIAGONAL_left 		3

#libdefine MONSTER 						1
#libdefine ACTORB 						2

#libdefine AxisX 						0
#libdefine AxisY 						1




#libdefine gs_IDLE 						0
#libdefine gs_LOADING 					1
#libdefine gs_ACTIVE 					2
#libdefine gs_END 						3




#libdefine COLORTEXT_MAIN 				9		//WHITE
#libdefine COLORTEXT_SECO 				2		//gray

#libdefine HUDid_TOP_TITLE 				1101
#libdefine HUDid_MIDDLE_TITLE 			1102
#libdefine HUDid_BOTTOM_TITLE 			1103



#libdefine HUDid_TOP_BACK 				1106
#libdefine HUDid_TOP_ICON 				1105
#libdefine HUDid_TOP_LETTER 			1104

#libdefine HUDid_MIDDLE_BACK 			1109
#libdefine HUDid_MIDDLE_ICON 			1108
#libdefine HUDid_MIDDLE_LETTER 			1107

#libdefine HUDid_BOTTOM_BACK 			1112
#libdefine HUDid_BOTTOM_ICON 			1111
#libdefine HUDid_BOTTOM_LETTER 			1110

#libdefine HUDid_CLIENTCREDITS 			1115
#libdefine HUDid_CLIENTCREDTIT1 		1116
#libdefine HUDid_CLIENTCREDTIT2 		1117
#libdefine HUDid_CLIENTCREDTIT3 		1118
#libdefine HUDid_CLIENTCREDTIT4 		1119
#libdefine HUDid_INPUTNOTE 				1120
#libdefine HUDid_PRINTSCORES 			1121
#libdefine HUDid_InputName 				1130

#libdefine HUDid_NoteTOPmsg 			1131
#libdefine HUDid_NoteMIDmsg 			1132
#libdefine HUDid_NoteBOTmsg 			1133
#libdefine HUDid_NoteTOPicon 			1134
#libdefine HUDid_NoteMIDicon 			1135
#libdefine HUDid_NoteBOTicon 			1136

#libdefine HUDid_MoneyBack 				1139
#libdefine HUDid_MoneyValue 			1138
#libdefine HUDid_MoneyIcon 				1137

#libdefine HUDid_MGback1 				1201
#libdefine HUDid_MGback2 				1202
#libdefine HUDid_MGback3 				1203
#libdefine HUDid_MGback4 				1204
#libdefine HUDid_MGback5 				1205

#libdefine	noteFadeIn_Long 			2.0
#libdefine	noteFadeIn_Standart 		1.0
#libdefine	noteFadeIn_Short 			0.5
#libdefine	noteFadeIn_None 			0.0

#libdefine	noteHold_Started 			2.0
#libdefine	noteHold_Failed 			3.0
#libdefine	noteHold_Long 				8.0
#libdefine	noteHold_Standart 			5.0
#libdefine	noteHold_Short 				3.0
#libdefine	noteHold_None 				0.0

#libdefine	noteFadeOut_Started 		1.0
#libdefine	noteFadeOut_Failed 			2.0
#libdefine	noteFadeOut_Long 			4.0
#libdefine	noteFadeOut_Standart 		2.0
#libdefine	noteFadeOut_Short 			1.0
#libdefine	noteFadeOut_None 			0.0




#libdefine notepara_CENTER 0
#libdefine notepara_ALIGN 1

#libdefine notepose_TOP 0
#libdefine notepose_MID 1
#libdefine notepose_BOT 2

#libdefine HUDX_FULLSCREEN 8
#libdefine HUDY_FULLSCREEN 6

#libdefine HUDX_VERYBIG 160
#libdefine HUDY_VERYBIG 120

#libdefine HUDX_BIG 320
#libdefine HUDY_BIG 240

#libdefine HUDX_MEDIUM 640
#libdefine HUDY_MEDIUM 480

#libdefine HUDX_SMALL 1024
#libdefine HUDY_SMALL 768

#libdefine HUDX_VERYSMALL	1280
#libdefine HUDY_VERYSMALL	960


#libdefine X_MUTUAL HUDX_MEDIUM/2	+	HUDX_MEDIUM/3	+	HUDX_MEDIUM/10
#libdefine Y_MUTUAL HUDY_MEDIUM/2	-	HUDY_MEDIUM/3


#libdefine X_TOP_TITLE	HUDX_MEDIUM/2
#libdefine Y_TOP_TITLE	HUDY_MEDIUM/4 - 32
#libdefine X_MIDDLE_TITLE	HUDX_BIG/2
#libdefine Y_MIDDLE_TITLE	HUDY_BIG/4
#libdefine X_BOTTOM_TITLE	HUDX_MEDIUM/2
#libdefine Y_BOTTOM_TITLE	HUDY_MEDIUM/4 + 32




#libdefine Y_MONEY			Y_MUTUAL		-	Y_MUTUAL/3	-	Y_MUTUAL/3


#libdefine X_TOP_BACK		X_MUTUAL
#libdefine Y_TOP_BACK		Y_MUTUAL		-	Y_MUTUAL/3
#libdefine X_TOP_ICON		X_MUTUAL		-	X_MUTUAL/22
#libdefine Y_TOP_ICON		Y_MUTUAL		-	Y_MUTUAL/3
#libdefine X_TOP_LETTER		X_MUTUAL		+	X_MUTUAL/64
#libdefine Y_TOP_LETTER		Y_MUTUAL		-	Y_MUTUAL/3

#libdefine X_MIDDLE_BACK	X_MUTUAL
#libdefine Y_MIDDLE_BACK	Y_MUTUAL
#libdefine X_MIDDLE_ICON	X_MUTUAL		-	X_MUTUAL/22
#libdefine Y_MIDDLE_ICON	Y_MUTUAL
#libdefine X_MIDDLE_LETTER	X_MUTUAL		+	X_MUTUAL/64
#libdefine Y_MIDDLE_LETTER	Y_MUTUAL

#libdefine X_BOTTOM_BACK	X_MUTUAL
#libdefine Y_BOTTOM_BACK	Y_MUTUAL		+	Y_MUTUAL/3
#libdefine X_BOTTOM_ICON	X_MUTUAL		-	X_MUTUAL/22
#libdefine Y_BOTTOM_ICON	Y_MUTUAL		+	Y_MUTUAL/3
#libdefine X_BOTTOM_LETTER	X_MUTUAL		+	X_MUTUAL/64
#libdefine Y_BOTTOM_LETTER	Y_MUTUAL		+	Y_MUTUAL/3

#libdefine X_FULLSCREEN	HUDX_FULLSCREEN/2
#libdefine Y_FULLSCREEN	HUDY_FULLSCREEN/2


#libdefine DN_IconOffset	HUDX_MEDIUM/3 + HUDX_MEDIUM/32

#libdefine ICON_None 				32
#libdefine ICON_Exclamation 		33
#libdefine ICON_Location 			35
#libdefine ICON_Checkmark 			36
#libdefine ICON_Clock 				37
#libdefine ICON_Exit 				38
#libdefine ICON_Mission 			39
#libdefine ICON_Weapon 				40
#libdefine ICON_Sad 				41
#libdefine ICON_Money 				42
#libdefine ICON_Waypoint 			43
#libdefine ICON_HEADER_Load 		48
#libdefine ICON_HEADER_Clock 		52
#libdefine ICON_Round 				63
#libdefine ICON_Boss 				64
#libdefine ICON_EnemyCount 			65
#libdefine ICON_Substance 			66
#libdefine ICON_WhiteScreen 		112
#libdefine ICON_BlackScreen 		113

#libdefine BLACK 0
#libdefine WHITE 1


#libdefine FREELOOK_LIMIT_UP -40
#libdefine FREELOOK_LIMIT_DOWN 39



#libdefine Encrypt 0
#libdefine Decrypt 1

#libdefine mus_CALM 0
#libdefine mus_NORM 1
#libdefine mus_EPIC 2


#libdefine SCRIPT_InputEnter 30
#libdefine SCRIPT_InputBackspace 31
#libdefine SCRIPT_InputChar 32
#libdefine SCRIPT_Buy	33
#libdefine SCRIPT_DestroyProjectile 99

#libdefine PlaygroundRoot 0

#libdefine HubRoot 10240
#libdefine HubRadius 896
#libdefine InputroomRoot 4096
#libdefine InputroomRadius 576
#libdefine PlaygroundRadius PBslots*576/2 + 256



#libdefine ps_DEAD 0
#libdefine ps_HUB 1
#libdefine ps_PLAYGROUND 2
#libdefine ps_INPUT 3

//--------------------------------------------------------------
#libdefine ProjRole_EMIT 0
#libdefine ProjRole_DEVOUR 1
#libdefine SIDE_SIDEY 2

#libdefine area_FLOOR 			1
#libdefine area_CEILING 		2
#libdefine area_FLOORnCEIL		3
#libdefine area_Preparation		4

#libdefine ProjHoleHeight 16
#libdefine ProjHoleSize 32

#libdefine ProjParam_EMITSPOT 		1
#libdefine ProjParam_DEVOURSPOT 	2
#libdefine ProjParam_TYPE 			3
#libdefine ProjParam_SPEED			4
#libdefine ProjParam_ANGLE			5
#libdefine ProjParam_DELAY			6
#libdefine ProjParam_HEIGHT			7
#libdefine ProjParam_TIMER			8

#libdefine ProjectilaParams			9
#libdefine ProjectilaSlots			16*PlaygroundBlocks
//--------------------------------------------------------------

#libdefine 		SEASON 				0
#libdefine 		STAGE 				1
#libdefine 		TRY 				2
#libdefine 		MoneyNameCount 		3
#libdefine 		CREDITS 			4



#libdefine		LayoutType_Random 		0
#libdefine		LayoutType_ByTheList 	1
#libdefine		LayoutType_Boss 		2

#libdefine 		AccomplishByENEMYONLY 	0
#libdefine 		AccomplishByTELEPORT	1

#libdefine CREDITS_StartAt 1000

#libdefine InfoType_ORDER			0
#libdefine InfoType_BORDERTYPE		1
#libdefine InfoType_EntryX			2
#libdefine InfoType_EntryY			3
#libdefine InfoType_BLOCKSAMOUNT	4


#libdefine TransferToCvar 0
#libdefine TransferToArray 1




#libdefine refreshspot_ITEM			1
#libdefine refreshspot_PROJECTILE	2
#libdefine refreshspot_DEFAULT		3

#libdefine DefaultFloorHeight 0
#libdefine DefaultCeilingHeight 4096
#libdefine DefaultPitFloorHeight -1024
#libdefine DefaultPitCeilingHeight 4096


#libdefine SectorSpecial_CLEAR 	-1
#libdefine SectorSpecial_FLOW 	1
#libdefine SectorSpecial_DEATH	2


#libdefine mood_EARTH	1
#libdefine mood_COLONY	2
#libdefine mood_SPACE	3

 int GAMEINFO[12];
//GAMEINFO
#libdefine		PortIs					0
#libdefine		Mood 					1
#libdefine		Location 				2
#libdefine 		DemoVersion 			3
#libdefine 		GameSim 				4
#libdefine 		InputNameTime 			5
#libdefine 		WinnerPlayerNum 		6
#libdefine		GameTest				7
#libdefine		MaxNameChars			8
#libdefine		RoundsCount				9
#libdefine		MapTime					10
#libdefine		AbsoluteTime			11


int RoundInfo[64];

#libdefine 		CurrentRound 			0
#libdefine 		StartpointTAG 			1
#libdefine 		FinishpointTAG 			2
#libdefine 		GlobalCeilingHeight 	3
#libdefine 		GlobalFloorHeight 		4
#libdefine 		FlatBASEtx 				5
#libdefine 		FlatSECOtx 				6
#libdefine 		FlatEDGEtx 				7
#libdefine 		FlatFAILtx 				8
#libdefine 		FlatPORTtx 				9
#libdefine 		FlatWATEtx 				10
#libdefine 		FlatBOMBtx 				11
#libdefine 		FlatWORMtx 				12
#libdefine 		CeilBASEtx 				13
#libdefine 		CeilSECOtx 				14
#libdefine 		WallBASEtx 				15
#libdefine 		WallSECOtx 				16
#libdefine 		WallEDGEtx 				17
#libdefine 		WallFENCtx 				18
#libdefine 		WallRAIStx 				19
#libdefine 		LoadSegments 			20
#libdefine 		StairsChance 			21
#libdefine 		OptEntranceX 			22
#libdefine 		OptEntranceY 			23
#libdefine 		CurrFloorHeight			24
#libdefine 		OldCurrFloorHeight 		25
#libdefine 		HeightSeg 				26
#libdefine 		InvertedRoute 			27
#libdefine 		AddBorderEntryHeightX 	28
#libdefine 		AddBorderEntryHeightY 	29
#libdefine 		InvertedStairs 			30
#libdefine		BorderExceptionCounter 	31
#libdefine		PitFloorHeight 			32
#libdefine		PitCeilingHeight 		33
#libdefine		MaxSubstanceHeight 		34
#libdefine		CurrSubstanceHeight 	35
#libdefine		AbsSubstanceHeight 		36
#libdefine		SubstanceLineOffset 	37
#libdefine		SubstanceMoveDelay	 	38
#libdefine		SubstanceMoveTimer	 	39
#libdefine		adventureCounter		40			//in secs
#libdefine		CheckpointWinner	 	41
#libdefine		FlowSpeed	 			42
#libdefine		MiniStartpoint	 		43
#libdefine		MiniFinishpoint	 		44
#libdefine		MiniCheckPoint	 		45
#libdefine		SectorItemCounter	 	46
#libdefine		HealthSpawnerCounter	47
#libdefine		HealthSpawnerQueue		48
#libdefine		WeaponSpawnerCounter	49
#libdefine		WeaponSpawnerQueue		50
#libdefine		MoneySpawnerCounter		51
#libdefine		MoneySpawnerQueue		52
#libdefine		AmmoSpawnerCounter		53
#libdefine		AmmoSpawnerQueue		54
#libdefine		sct_RED					55
#libdefine		sct_GREEN				56
#libdefine		sct_BLUE				57
#libdefine		sct_DESATURATE			58
#libdefine		sct_BRIGHTNESS			59
#libdefine		sct_FADEDIV				60
#libdefine 		CheckpointReached 		61
#libdefine 		PlaygroundReached 		62
#libdefine 		TimeGiven				63








#libdefine 		StairsHeight 128


#libdefine		InvasionStartTime 	15
#libdefine 		DefaultFloorTexture 	1
#libdefine 		DefaultCeilingTexture 2
#libdefine 		DefaultBorderFloorTexture 3
#libdefine 		DefaultBorderCeilingTexture 4







int PlayerScore[MaxPlayers];
int PlayerCheckpoint[MaxPlayers];





int AdventureInfo[MaxRounds + 1][8];

#libdefine	adv_TYPE 				0
#libdefine 		adventure_BOSS 		1
#libdefine 		adventure_MAZE 		2
#libdefine 		adventure_LINEAR 	3
#libdefine 		adventure_RAISE 	4
#libdefine 		adventure_INVASION 	5
#libdefine 		adventure_FLOW 		6

#libdefine adv_DIFFICULTY   		1
#libdefine adv_MUSIC   				2
#libdefine adv_BOSS   				3
#libdefine adv_WEAPON 				4
#libdefine adv_RANDOMEVENT 			5
#libdefine 		event_BOMB			1
#libdefine 		event_WORM			2
#libdefine adv_BOSSMAXHP 			6
#libdefine adv_MINICHECKPOINTS 		7







	#libdefine id_None				0

#libdefine id_minWEAPON 		1
	#libdefine id_Pistol			1
	#libdefine id_Shotgun			2
	#libdefine id_Chaingun			3
	#libdefine id_SuperShotgun		4
	#libdefine id_RocketLauncher	5
	#libdefine id_PlasmaRifle		6
	#libdefine id_BFG9000			7
#libdefine id_maxWEAPON 		7

#libdefine id_minAMMO			8
	#libdefine id_Clip				8
	#libdefine id_ClipBox			9
	#libdefine id_Shell				10
	#libdefine id_ShellBox			11
	#libdefine id_RocketAmmo		12
	#libdefine id_RocketBox			13
	#libdefine id_Cell				14
	#libdefine id_CellPack			15
	#libdefine id_Backpack			16
#libdefine id_maxAMMO 			16

#libdefine id_minHEALTH			17
	#libdefine id_Stimpack 			17
	#libdefine id_Medkit 			18
	#libdefine id_Soulsphere 		19
#libdefine id_maxHEALTH			19

#libdefine id_minMoney			20
	#libdefine id_SmallCoin 		20
	#libdefine id_BigCoin 			21
#libdefine id_maxMoney			21

#libdefine id_minENEMY			22
	#libdefine id_Zombieman 		22
	#libdefine id_Imp				23
	#libdefine id_ShotgunGuy		24
	#libdefine id_Demon				25
	#libdefine id_LostSoul			26
	#libdefine id_HeavyWeaponDude	27
	#libdefine id_Spectre			28
	#libdefine id_Cacodemon			29
	#libdefine id_HellKnight		30
	#libdefine id_BaronOfHell		31
	#libdefine id_Mancubus			32
	#libdefine id_Arachnotron		33
	#libdefine id_Archvile			34
	#libdefine id_SpiderMastermind	35
	#libdefine id_Cyberdemon		36
	#libdefine id_Railgunner		37
#libdefine id_maxENEMY			37

#libdefine id_minPROJECTILE		38
	#libdefine id_ImpBall 			38
	#libdefine id_BaronBall 		39
	#libdefine id_ArachnotronShot 	40
	#libdefine id_PlasmaBall 		41
	#libdefine id_CacoBall 			42
	#libdefine id_RevenantBall		43
	#libdefine id_MancubusShot 		44
	#libdefine id_Rocket 			45
	#libdefine id_BFGBall 			46
#libdefine id_maxPROJECTILE		46

#libdefine id_minMARINE			47
	#libdefine id_MarineBFG 		47
	#libdefine id_MarinePlasma		48
	#libdefine id_MarineBerserk 	49
	#libdefine id_MarineChaingun 	50
	#libdefine id_MarineRocket 		51
	#libdefine id_MarineShotgun 	52
	#libdefine id_MarineRailgun 	53
	#libdefine id_MarineSSG			54
#libdefine id_maxMARINE			54




#libdefine tc_GREY 		1
#libdefine tc_WHITE 	2
#libdefine tc_BROWN 	3
#libdefine tc_PEACH 	4
#libdefine tc_RED 		5
#libdefine tc_PINK 		6
#libdefine tc_YELLOW 	7
#libdefine tc_BLUE 		8
#libdefine tc_GREEN 	9







int 	GAMESTATE,
		TimeLeft,
		LoadBit,
		TempSEASON,
		TempSTAGE,
		TempTRY;

bool 	Deploying,
		HoldTime;












/*

 _______  __    __  .__   __.   ______ .___________. __    ______   .__   __.                .______        ___           _______. __    ______
|   ____||  |  |  | |  \ |  |  /      ||           ||  |  /  __  \  |  \ |  |        _       |   _  \      /   \         /       ||  |  /      |
|  |__   |  |  |  | |   \|  | |  ,----'`---|  |----`|  | |  |  |  | |   \|  |       (_)      |  |_)  |    /  ^  \       |   (----`|  | |  ,----'
|   __|  |  |  |  | |  . `  | |  |         |  |     |  | |  |  |  | |  . `  |                |   _  <    /  /_\  \       \   \    |  | |  |
|  |     |  `--'  | |  |\   | |  `----.    |  |     |  | |  `--'  | |  |\   |        _       |  |_)  |  /  _____  \  .----)   |   |  | |  `----.
|__|      \______/  |__| \__|  \______|    |__|     |__|  \______/  |__| \__|       (_)      |______/  /__/     \__\ |_______/    |__|  \______|


*/







function int abs (int x)
{
	if (x < 0)
	return -x;

	return x;
}

function int invert (int x)
{
	x = -1*x;

return x;
}





function int int2fix(int value)
{
	return value * 1.0;
}



function int tic2sec(int Value)
{
	return FixedDiv(Value << 16, 35.0);
}




function int RNG (int min, int max)
{
int result;
	Switch(GetPort())
		{
		CASE ZDaemon:		result = ZD_rand(min, max);		break;
		CASE Zandronum:
		CASE GZDoom:		result = random(min, max);		break;
		}
return result;
}




function int StrToNum(str s)	//AToI
{
    int start = 0;
    bool negative = false;
    int n = 0;
    int len = StrLen(s);

    // Check if we start with a negative sign
    if (GetChar(s, 0) == '-')
    {
        negative = true;
        start++;
    }

    // Go through every character in the string
    for (int i=start; i<len; i++)
    {
        int char = GetChar(s, i);

        // Check that we are actually converting a number
        if (char < '0' || char > '9')
        {
            print(s:"ERROR, attempting to convert ", c:char, s:" to number!");
            continue;
        }

        // Add the number to our total
        n = n*10 + (char-'0');
    }

    if (negative)
        n = -n;

    return n;
}




function int ClientCount(void) // code by Korshun, edited by TDRR
{
    int count = 0;
    for (int i = 0; i < 32; i++)
        if (PlayerInGame(i) || PlayerIsSpectator(i))
            count++;
    return count;
}



function str PrintClock(int seconds) {
    int m = seconds / 60;
    int s = seconds % 60;

    str result = StrParam(d: m, s: ":");
    if (s < 10) result = StrParam(s: result, d: 0);
    result = StrParam(s: result, d: s);
    return result;
}




function bool BinarySwitch (bool Value)
{
if (Value == true) Value = false;
else value = true;
return Value;
}




function int RandomNoZero (int Min, int Max)
{
int Result;
int tendency = RNG(0,1);
Switch(tendency)
	{
	Case 0: Result = RNG(Min, -1); break;
	Case 1: Result = RNG(1, Max); break;
	}
return Result;
}




function int RandomRange (int Num)
{
int Result;
int tendency = RNG(0,1);
Switch(tendency)
	{
	Case 0: Result = RNG(-Num, 	-1); 	break;
	Case 1: Result = RNG(1, 	Num); 	break;
	}
return Result;
}



function int WithinHundred (int Num)
{
int Result;
		if (Num < 0)	Result = 0;
else 	if (Num > 100)	Result = 100;
else Result = Num;
return Result;
}





function int CharToUpper(int input)
{
    if (input >= 'a' && input <= 'z')
    {
        return input ^ 0x20;
    }

    return input;
}

function str StrToUpper(str input)
{
    str output = "";
    for (int i = 0; i < StrLen(input); i++)
    {
        int upper = CharToUpper(GetChar(input, i));
        output = StrParam(s: output, c: upper);
    }

    return output;
}




function str StripColors(str input) //DrinkyBird + Mr.Satan
{
  str output = ""; bool isCol = false; bool isBracket = false;
  for (int i = 0; i < StrLen(input); i++)
  {
    int c = GetChar(input, i);
    if (GetChar(input, i) == '\\' && GetChar(input, i + 1) == 'c') { isCol = true; i++; }
    else if (c == 0x1C) { isCol = true; }
    else if (isCol)
    {
      if (c == '[') { isBracket = true; }
      else if (c == ']') { isBracket = false; }
      if (!isBracket) { isCol = false; }
    }
    else { output = StrParam(s: output, c: c); }
  }
  return output;
}



function void Set_AllGodmode (bool set)
{
	for (int i = 0; i < MaxPlayers ; i++) {
		SetActorProperty(PLAYER_TID+i,APROP_Invulnerable,set);
	}
}






function str StringNoEdgeSpaces (str String)
{
int counter, Edge;
str Result = "";
int MaxStrChars = StrLen(String);
/*
                                                        _        _   _           __             _
  _ _ ___ _ __  _____ _____   ____ __  __ _ __ ___ ___ (_)_ _   | |_| |_  ___   / _|_ _ ___ _ _| |_
 | '_/ -_) '  \/ _ \ V / -_) (_-< '_ \/ _` / _/ -_|_-< | | ' \  |  _| ' \/ -_) |  _| '_/ _ \ ' \  _|
 |_| \___|_|_|_\___/\_/\___| /__/ .__/\__,_\__\___/__/ |_|_||_|  \__|_||_\___| |_| |_| \___/_||_\__|
                                |_|
*/

While(Edge < MaxStrChars)
{
if (GetChar(String, Edge) == 32) Edge++;
else break;
}



counter = Edge;
while(counter < MaxStrChars)
{
Result =   StrParam(s:Result, c:GetChar(String, counter));
counter++;
}

String = Result; counter = 0;	Result = "";
/*
                                                        _        _   _          _             _
  _ _ ___ _ __  _____ _____   ____ __  __ _ __ ___ ___ (_)_ _   | |_| |_  ___  | |__  __ _ __| |__
 | '_/ -_) '  \/ _ \ V / -_) (_-< '_ \/ _` / _/ -_|_-< | | ' \  |  _| ' \/ -_) | '_ \/ _` / _| / /
 |_| \___|_|_|_\___/\_/\___| /__/ .__/\__,_\__\___/__/ |_|_||_|  \__|_||_\___| |_.__/\__,_\__|_\_\
                                |_|
*/

Edge = StrLen(String) - 1;



While(Edge > 0)
{
if (GetChar(String, Edge) == 32) Edge--;
else break;
}



while(counter <= Edge)
{
Result =   StrParam(s:Result, c:GetChar(String, counter));        // StrParam(s:Result, c:WinnerNames[InputHeader + counter]);
counter++;
}
Return Result;

}




function int GetPort (void)
{
int Result = GetSectorLightLevel(TIDRAM_Port);
return Result;
}




function void SetPort (void)
{
int Result;
//																				CLIENTSIDE										SERVERSIDE
		if (IsTIDUsed(ACTORTID_GZDoomTag) 		== true)		{		Light_ChangeToValue(TIDRAM_Port, GZDoom);		GAMEINFO[PortIs] = GZDoom;		}
else 	if (IsTIDUsed(ACTORTID_ZandronumTag) 	== true)		{		Light_ChangeToValue(TIDRAM_Port, Zandronum);	GAMEINFO[PortIs] = Zandronum;	}
else															{		Light_ChangeToValue(TIDRAM_Port, ZDaemon);		GAMEINFO[PortIs] = ZDaemon;		}

}





function str GetPlayerName (int STRICTLY, int PlayerNum)
{
//if STRICTLY is on, then only account the account name
str Result = "";
Switch(GetPort())
	{
	CASE ZDaemon:
	CASE GZDoom:
	Result = StripColors(StrParam(n:PlayerNum + 1));
	break;

	CASE Zandronum:
	if (StrLen(GetPlayerAccountName(PlayerNum)) > 0) 	Result = GetPlayerAccountName(PlayerNum);
	else
		{
		if (STRICTLY == TRUE)		Result = "";
		else 						Result = StripColors(StrParam(n:PlayerNum + 1));
		}
	break;
	}
return Result;
}








#libdefine SFX_TimerPanic 		1
#libdefine SFX_BossEnter		2



Script "SFX" (int Port, int Which) CLIENTSIDE
{
str Sound = "";
Switch(Which)
		{
		CASE SFX_TimerPanic:	if(PlayerStatus(ConsolePlayerNumber()) == ps_PLAYGROUND)	Sound = "SFXPANIC";				break;
		CASE SFX_BossEnter:																	Sound = "SFXBOSSE";				break;
		}
LocalAmbientSound(Sound, 127);
}



function str TimeColor (int Time)
{
str Result;
int counter;
bool PanicSound;
if(Time <= PanicTime)
	{
	Result = "\cg";
		Switch(GAMESTATE)
		{
		CASE gs_IDLE:		PanicSound = FALSE;		break;
		CASE gs_LOADING:	PanicSound = FALSE;		break;
		CASE gs_ACTIVE:		PanicSound = TRUE;		break;
		CASE gs_END:		PanicSound = TRUE;		break;
		}
	}
else Result = "\cj";
//--------------------------------------------------------
if (PanicSound == TRUE)
	{
	while(counter < MaxPlayers)
		{
		if (!PlayerIsSpectator(counter))	ClientScript (counter, "SFX", GetPort(), SFX_TimerPanic, 0);
		counter++;
		}
	}

return Result;
}





function void StoreMoneyInfo (void)
{
int counter, i;
str StringA = "";
BeginDBTransaction();

	SetDBEntry("db_ERINFO", "MONEY_NameCount", ServerInfo[MoneyNameCount]);

	counter = 0;
	while(counter <= ServerInfo[MoneyNameCount])
				{
				SetDBEntry("db_ERINFO", StrParam(s:"MONEY_Value", i:counter), MoneyInfo_VALUE[counter]);
				while (i < 32)
						{
						StringA = StrParam(s:StringA, c:MoneyInfo_NAME[counter * 32 + i]);
						i++;
						}

				SetDBEntryString("db_ERINFO", StrParam(s:"MONEY_Name", i:counter), StringA);

				counter++;
				}

EndDBTransaction();

}













#libdefine SPS_AlsoPrint 1
#libdefine SPS_ScoresToPrint 5
#libdefine SPS_NameMaxChars 7

int BestScorePLAYANUM[SPS_ScoresToPrint];
int BestScorePTS[SPS_ScoresToPrint];


// Show maximum points and players.
function void SortPlayerScores (int Condition)
{
int i, j, k, counter, CharCounter, AddSpaces;
str NameTemp = "";
str NameStr = "";
str ScoreString = "";

	// Reset points
	for (i = 0; i < SPS_ScoresToPrint; i++)
		{
		BestScorePTS[i] = 0;
		BestScorePLAYANUM[i] = 0;
		}
		// Check all players
	for (i = 0; i <= MaxPlayers; i++)
		{
		if (PlayerStatus(i) > ps_DEAD)						//if (GetPlayerInfo(i, PLAYERINFO_HEALTH) > 0)	// Player is alive
			{
			for (j = 0; j < SPS_ScoresToPrint ; j++)	// check ranks from highest to lowest
				{
				if (PlayerScore[i] > BestScorePTS[j])				//if (GetPlayerInfo(i, PLAYERINFO_PTS_1) > BestScorePTS[j])	// Check if player has more points than rank 1..n
					{
					for (k = SPS_ScoresToPrint - 1; k >= j; k--)
						{
						if (k < SPS_ScoresToPrint - 1)	// Don't shift last rank
							{
							BestScorePTS[k + 1] = BestScorePTS[k];		// Shift down
							BestScorePLAYANUM[k + 1] = BestScorePLAYANUM[k];
							}
						}
					// Set current points and index
					BestScorePTS[j] = PlayerScore[i];			//GetPlayerInfo(i, PLAYERINFO_PTS_1);
					BestScorePLAYANUM[j] = i;
					break;
					}
				}
			}
		}


if (RoundInfo[CurrentRound] >= GAMEINFO[RoundsCount])	//STAGE WIN, Find a winner
{
counter = 0;
while (counter < SPS_ScoresToPrint)
	{
	if (PlayerCheckpoint[BestScorePLAYANUM[counter]] == RoundInfo[CurrentRound] + 1) 		{	GAMEINFO[WinnerPlayerNum] = BestScorePLAYANUM[counter];	break;	}
	else counter++;
	}
}

//PlayerCheckpoint[counter] = RoundInfo[CurrentRound] + 1;
//GAMEINFO[WinnerPlayerNum] = BestScorePLAYANUM[0];		//Set current winner

counter = 0;
if ((Condition == SPS_AlsoPrint)	 )//&& (PlayerCount() > 1))	// Print players and points each rank.
	{


		while(counter < SPS_ScoresToPrint)
				{
				if (BestScorePTS[counter] && (PlayerStatus(BestScorePLAYANUM[counter]) > ps_DEAD))
						{
						CharCounter = 0; NameStr = ""; /*ScoreString = "";*/ AddSpaces = 0;
						NameTemp = StrParam(n: BestScorePLAYANUM[counter] + 1);
						NameTemp = StripColors(NameTemp);
						NameTemp = StrToUpper(NameTemp);


						while(CharCounter < StrLen(NameTemp))
								{
								//REPLACE LAST TWO LETTERS WITH 2 DOTS IF ITS TOO LONG
								if ((CharCounter == SPS_NameMaxChars - 2) && (StrLen(NameTemp) > SPS_NameMaxChars))
										{
										NameStr = StrParam(s:NameStr, s:"..");
										break;
										}
								NameStr = StrParam(s:NameStr, c:GetChar(NameTemp, CharCounter));
								CharCounter++;
								}


						//ADD SPACES BCZ NAME IS TOO SHORT
						if (StrLen(NameTemp)  < SPS_NameMaxChars)
						{
						AddSpaces = SPS_NameMaxChars - StrLen(NameTemp);
						CharCounter = 0;

								while(CharCounter < AddSpaces)
										{
										NameStr = StrParam(s:NameStr, s:" ");
										CharCounter++;
										}
						}


						ScoreString = StrParam(s:ScoreString, s:NameStr, s:" ", i:BestScorePTS[counter], s:"\n\n");
						}

				else	ScoreString = StrParam(s:ScoreString, s:"\n\n");	//maybe cause a bug

				counter++;
				}




		SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, 0);
		SetFont("ERFONT");
		HudMessageBold(s:ScoreString; HUDMSG_FADEOUT, HUDid_PRINTSCORES, COLORTEXT_MAIN, int2fix(HUDX_MEDIUM/2	-	HUDX_MEDIUM/3	-	HUDX_MEDIUM/10), int2fix(HUDY_MEDIUM/2	+	HUDY_MEDIUM/3), 1.0, 1.0);
	}

}
















function int Crypt (int How, int Char)
{
int Result = Char;

if (How == Encrypt)
	{
		Switch(Char)
			{
			CASE 32: 	Result	=	97;		break;
			CASE 33: 	Result	=	57;		break;
			CASE 34:	Result	=	92;		break;
			CASE 35:	Result	=	75;		break;
			CASE 36:	Result	=	108;	break;
			CASE 37:	Result	=	76;		break;
			CASE 38:	Result	=	33;		break;
			CASE 39:	Result	=	95;		break;
			CASE 40:	Result	=	90;		break;
			CASE 41:	Result	=	85;		break;
			CASE 42:	Result	=	54;		break;
			CASE 43:	Result	=	126;	break;
			CASE 44:	Result	=	40;		break;
			CASE 45:	Result	=	77;		break;
			CASE 46:	Result	=	111;	break;
			CASE 47:	Result	=	91;		break;
			CASE 48:	Result	=	113;	break;
			CASE 49:	Result	=	66;		break;
			CASE 50:	Result	=	63;		break;
			CASE 51:	Result	=	78;		break;
			CASE 52:	Result	=	35;		break;
			CASE 53:	Result	=	61;		break;
			CASE 54:	Result	=	37;		break;
			CASE 55:	Result	=	32;		break;
			CASE 56:	Result	=	47;		break;
			CASE 57:	Result	=	69;		break;
			CASE 58:	Result	=	43;		break;
			CASE 59:	Result	=	98;		break;
			CASE 60:	Result	=	51;		break;
			CASE 61:	Result	=	101;	break;
			CASE 62:	Result	=	86;		break;
			CASE 63:	Result	=	50;		break;
			CASE 64:	Result	=	124;	break;
			CASE 65:	Result	=	94;		break;
			CASE 66:	Result	=	44;		break;
			CASE 67:	Result	=	68;		break;
			CASE 68:	Result	=	116;	break;
			CASE 69:	Result	=	45;		break;
			CASE 70:	Result	=	106;	break;
			CASE 71:	Result	=	104;	break;
			CASE 72:	Result	=	109;	break;
			CASE 73:	Result	=	100;	break;
			CASE 74:	Result	=	81;		break;
			CASE 75:	Result	=	119;	break;
			CASE 76:	Result	=	93;		break;
			CASE 77:	Result	=	67;		break;
			CASE 78:	Result	=	118;	break;
			CASE 79:	Result	=	55;		break;
			CASE 80:	Result	=	122;	break;
			CASE 81:	Result	=	53;		break;
			CASE 82:	Result	=	110;	break;
			CASE 83:	Result	=	117;	break;
			CASE 84:	Result	=	46;		break;
			CASE 85:	Result	=	38;		break;
			CASE 86:	Result	=	89;		break;
			CASE 87:	Result	=	84;		break;
			CASE 88:	Result	=	121;	break;
			CASE 89:	Result	=	102;	break;
			CASE 90:	Result	=	52;		break;
			CASE 91:	Result	=	60;		break;
			CASE 92:	Result	=	34;		break;
			CASE 93:	Result	=	82;		break;
			CASE 94:	Result	=	83;		break;
			CASE 95:	Result	=	112;	break;
			CASE 96:	Result	=	48;		break;
			CASE 97:	Result	=	87;		break;
			CASE 98:	Result	=	79;		break;
			CASE 99:	Result	=	71;		break;
			CASE 100:	Result	=	39;		break;
			CASE 101:	Result	=	56;		break;
			CASE 102:	Result	=	88;		break;
			CASE 103:	Result	=	65;		break;
			CASE 104:	Result	=	99;		break;
			CASE 105:	Result	=	120;	break;
			CASE 106:	Result	=	114;	break;
			CASE 107:	Result	=	115;	break;
			CASE 108:	Result	=	96;		break;
			CASE 109:	Result	=	58;		break;
			CASE 110:	Result	=	105;	break;
			CASE 111:	Result	=	49;		break;
			CASE 112:	Result	=	125;	break;
			CASE 113:	Result	=	72;		break;
			CASE 114:	Result	=	64;		break;
			CASE 115:	Result	=	103;	break;
			CASE 116:	Result	=	36;		break;
			CASE 117:	Result	=	42;		break;
			CASE 118:	Result	=	123;	break;
			CASE 119:	Result	=	70;		break;
			CASE 120:	Result	=	41;		break;
			CASE 121:	Result	=	62;		break;
			CASE 122:	Result	=	74;		break;
			CASE 123:	Result	=	59;		break;
			CASE 124:	Result	=	107;	break;
			CASE 125:	Result	=	80;		break;
			CASE 126:	Result	=	73;		break;
			}
	}


else if (How == Decrypt)
	{
		Switch(Char)
			{
			CASE 97: 	Result	=	32;		break;
			CASE 57: 	Result	=	33;		break;
			CASE 92:	Result	=	34;		break;
			CASE 75:	Result	=	35;		break;
			CASE 108:	Result	=	36;		break;
			CASE 76:	Result	=	37;		break;
			CASE 33:	Result	=	38;		break;
			CASE 95:	Result	=	39;		break;
			CASE 90:	Result	=	40;		break;
			CASE 85:	Result	=	41;		break;
			CASE 54:	Result	=	42;		break;
			CASE 126:	Result	=	43;		break;
			CASE 40:	Result	=	44;		break;
			CASE 77:	Result	=	45;		break;
			CASE 111:	Result	=	46;		break;
			CASE 91:	Result	=	47;		break;
			CASE 113:	Result	=	48;		break;
			CASE 66:	Result	=	49;		break;
			CASE 63:	Result	=	50;		break;
			CASE 78:	Result	=	51;		break;
			CASE 35:	Result	=	52;		break;
			CASE 61:	Result	=	53;		break;
			CASE 37:	Result	=	54;		break;
			CASE 32:	Result	=	55;		break;
			CASE 47:	Result	=	56;		break;
			CASE 69:	Result	=	57;		break;
			CASE 43:	Result	=	58;		break;
			CASE 98:	Result	=	59;		break;
			CASE 51:	Result	=	60;		break;
			CASE 101:	Result	=	61;		break;
			CASE 86:	Result	=	62;		break;
			CASE 50:	Result	=	63;		break;
			CASE 124:	Result	=	64;		break;
			CASE 94:	Result	=	65;		break;
			CASE 44:	Result	=	66;		break;
			CASE 68:	Result	=	67;		break;
			CASE 116:	Result	=	68;		break;
			CASE 45:	Result	=	69;		break;
			CASE 106:	Result	=	70;		break;
			CASE 104:	Result	=	71;		break;
			CASE 109:	Result	=	72;		break;
			CASE 100:	Result	=	73;		break;
			CASE 81:	Result	=	74;		break;
			CASE 119:	Result	=	75;		break;
			CASE 93:	Result	=	76;		break;
			CASE 67:	Result	=	77;		break;
			CASE 118:	Result	=	78;		break;
			CASE 55:	Result	=	79;		break;
			CASE 122:	Result	=	80;		break;
			CASE 53:	Result	=	81;		break;
			CASE 110:	Result	=	82;		break;
			CASE 117:	Result	=	83;		break;
			CASE 46:	Result	=	84;		break;
			CASE 38:	Result	=	85;		break;
			CASE 89:	Result	=	86;		break;
			CASE 84:	Result	=	87;		break;
			CASE 121:	Result	=	88;		break;
			CASE 102:	Result	=	89;		break;
			CASE 52:	Result	=	90;		break;
			CASE 60:	Result	=	91;		break;
			CASE 34:	Result	=	92;		break;
			CASE 82:	Result	=	93;		break;
			CASE 83:	Result	=	94;		break;
			CASE 112:	Result	=	95;		break;
			CASE 48:	Result	=	96;		break;
			CASE 87:	Result	=	97;		break;
			CASE 79:	Result	=	98;		break;
			CASE 71:	Result	=	99;		break;
			CASE 39:	Result	=	100;	break;
			CASE 56:	Result	=	101;	break;
			CASE 88:	Result	=	102;	break;
			CASE 65:	Result	=	103;	break;
			CASE 99:	Result	=	104;	break;
			CASE 120:	Result	=	105;	break;
			CASE 114:	Result	=	106;	break;
			CASE 115:	Result	=	107;	break;
			CASE 96:	Result	=	108;	break;
			CASE 58:	Result	=	109;	break;
			CASE 105:	Result	=	110;	break;
			CASE 49:	Result	=	111;	break;
			CASE 125:	Result	=	112;	break;
			CASE 72:	Result	=	113;	break;
			CASE 64:	Result	=	114;	break;
			CASE 103:	Result	=	115;	break;
			CASE 36:	Result	=	116;	break;
			CASE 42:	Result	=	117;	break;
			CASE 123:	Result	=	118;	break;
			CASE 70:	Result	=	119;	break;
			CASE 41:	Result	=	120;	break;
			CASE 62:	Result	=	121;	break;
			CASE 74:	Result	=	122;	break;
			CASE 59:	Result	=	123;	break;
			CASE 107:	Result	=	124;	break;
			CASE 80:	Result	=	125;	break;
			CASE 73:	Result	=	126;	break;
			}
	}

Return Result;
}




function int PlayerStatus (int PlayerNum)
{
int Result;
int counter;
int TEMP;
	if (PlayerNum > -1)	//Individual PlayerNum
		{
		if (ClassifyActor(PLAYER_TID+PlayerNum) & ACTOR_ALIVE)
			{
				 if (((GetActorY(PLAYER_TID + PlayerNum) >> 16) > PlaygroundRoot - PlaygroundRadius)	&&	((GetActorY(PLAYER_TID + PlayerNum) >> 16) < PlaygroundRoot + PlaygroundRadius))		Result = ps_PLAYGROUND;
			else if (((GetActorY(PLAYER_TID + PlayerNum) >> 16) > HubRoot - HubRadius)					&&	((GetActorY(PLAYER_TID + PlayerNum) >> 16) < HubRoot + HubRadius))						Result = ps_HUB;
			else if (((GetActorY(PLAYER_TID + PlayerNum) >> 16) > InputroomRoot - InputroomRadius)		&&	((GetActorY(PLAYER_TID + PlayerNum) >> 16) < InputroomRoot + InputroomRadius))			Result = ps_INPUT;
			}

		else Result = ps_DEAD;
		}


	else  //All players -1
	{
	while (counter < MaxPlayers)

	  {
		  if (ClassifyActor(PLAYER_TID+counter) & ACTOR_ALIVE)
			{
				 if (((GetActorY(PLAYER_TID + counter) >> 16) > PlaygroundRoot - PlaygroundRadius)		&&	((GetActorY(PLAYER_TID + counter) >> 16) < PlaygroundRoot + PlaygroundRadius))			TEMP = ps_PLAYGROUND;
			else if (((GetActorY(PLAYER_TID + counter) >> 16) > HubRoot - HubRadius)					&&	((GetActorY(PLAYER_TID + counter) >> 16) < HubRoot + HubRadius))						TEMP = ps_HUB;
			else if (((GetActorY(PLAYER_TID + counter) >> 16) > InputroomRoot - InputroomRadius)		&&	((GetActorY(PLAYER_TID + counter) >> 16) < InputroomRoot + InputroomRadius))			TEMP = ps_INPUT;
			if(Result < TEMP) Result = TEMP;
			}

		counter++;
	  }

	}

return Result;
}








#libdefine 		pos_ByActorPos 0
#libdefine 		pos_ByXYZ 1

function bool CheckActorPosition (int TID, int Method, int range, int PosTID, int x, int y, int z)
{
bool Result;


Switch(Method)
{
CASE pos_ByXYZ:
if 	(
	((GetActorX(TID) >> 16) > x - range) &&
	((GetActorY(TID) >> 16) > y - range) &&
	//((GetActorZ(TID) >> 16) > z - range) &&
	((GetActorX(TID) >> 16) < x + range) &&
	((GetActorY(TID) >> 16) < y + range) //&&
	//((GetActorZ(TID) >> 16) < z + range)
	)
	Result = true;
break;

CASE pos_ByActorPos:
if 	(
	((GetActorX(TID) >> 16) > (GetActorX(posTID) >> 16) - range) &&
	((GetActorY(TID) >> 16) > (GetActorY(posTID) >> 16) - range) &&
	//((GetActorZ(TID) >> 16) > (GetActorZ(posTID) >> 16) - range) &&
	((GetActorX(TID) >> 16) < (GetActorX(posTID) >> 16) + range) &&
	((GetActorY(TID) >> 16) < (GetActorY(posTID) >> 16) + range) //&&
	//((GetActorZ(TID) >> 16) < (GetActorZ(posTID) >> 16) + range)
	)
	Result = true;



break;

}



return Result;
}





function bool PlayerSectorCrossed (int TID)
{
bool result;
int rad = 1;
if 		(
 		(GetActorZ(TID)		<=	GetSectorFloorZ(0, 	(GetActorX(TID)>>16) + rad, (GetActorY(TID)>>16) + rad) )	&&
		(GetActorZ(TID)		<=	GetSectorFloorZ(0, 	(GetActorX(TID)>>16) + rad, (GetActorY(TID)>>16) - rad) )	&&
		(GetActorZ(TID)		<=	GetSectorFloorZ(0, 	(GetActorX(TID)>>16) - rad, (GetActorY(TID)>>16) - rad) )	&&
		(GetActorZ(TID)		<=	GetSectorFloorZ(0, 	(GetActorX(TID)>>16) - rad, (GetActorY(TID)>>16) + rad) )
		)
		Result = TRUE;
log(s:"PlayerSectorCrossed ", i:result);


return Result;
}











function void	DemoMessage (int Segment)
{
str font = "";
str BigTitleStr = "";
str MiddleStr = "";
str BottomStr = "";
str StrA = "";
str StrB = "";

Switch(Segment)
	{
	CASE 0:

Switch (GetPort())
		{
		CASE ZDaemon:
		CASE Zandronum:	font = "ERFONT";

		StrA = StrParam(
		s:"This mod was designed to be played online. Only Demo version\n",
		s:"is allowed offline. Download \cgDoom Explorer\cl to view servers.\n",
		s:"Type 'Endless Relentless' or 'Relendless'in search tab to find servers.\n",
		s:"You can also join the official one, right from the main menu\n",
		s:"(considering that server is still alive as you read this)."
		);
		StrB = StrParam(
		s:""
		);

		Switch(GetLevelInfo(LEVELINFO_LEVELNUM))
		{
		CASE MainMap:	MiddleStr = StrA;	BottomStr = "";		break;
		CASE TitleMap:	MiddleStr = StrB;	BottomStr = StrA;	break;
		}




		break;



		CASE GZDoom:	font = "NEWCONSOLEFONT";

		StrA = StrParam(
		s:"This port is outdated and lacks famous and cutting-edge\n",
		s:"features such as ZScri...oops, wrong berate direction...\n",
		s:"...ahem, such as C/S network architecture, a multiplayer\n",
		s:"launcher, igor memes and disrespectful community, and\n",
		s:"only Demo(w/possible bugs) is available for GZDoom.\n\n"
		);
		StrB = StrParam(
		s:"Seriously though. This mod was designed to be played in multiplayer sourceports\n",
		s:"only. Choose between either more advanced \cqZandronum\cl or an old-school \ciZDaemon\cl\n",
		s:"and you might also want to download the \cgDoom Explorer\cl to view all servers.\n",
		s:"Use search tab there to find RELENDLESS servers, or you can join the official one\n",
		s:"right from the main menu(considering that server is still alive as you read this)."
		);
		break;

		Switch(GetLevelInfo(LEVELINFO_LEVELNUM))
		{
		CASE MainMap:	MiddleStr = StrB;	BottomStr = "";		break;
		CASE TitleMap:	MiddleStr = StrA;	BottomStr = StrB;	break;
		}

		}

	SetFont(font);
	//-------------------------------------------------------------------------------------------------------------------//MIDDLE MESSAGE
	SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, 0);
	HudMessageBold(		s:MiddleStr			;HUDMSG_PLAIN, 0, CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2), int2fix(HUDY_MEDIUM/2), 0.0 );
	//-------------------------------------------------------------------------------------------------------------------//BOTTOM MESSAGE
	SetHUDSize(HUDX_SMALL, HUDY_SMALL, 0);
	HudMessageBold(		s:BottomStr			;HUDMSG_PLAIN, 0, CR_UNTRANSLATED, int2fix(HUDX_SMALL/2), FixedDiv(int2fix(HUDY_SMALL), 2.0) + FixedDiv(int2fix(HUDY_SMALL), 2.35), 0.0 );

	break;


	CASE 1:
	SetHUDSize(HUDX_BIG, HUDY_BIG, 0);
	SetFont("BIGFONT");
	HudMessageBold(		s:"ONLY ZANDRONUM OR ZDAEMON DOOM PORTS SUPPORT ONLINE GAME"		;HUDMSG_FADEOUT, 0, CR_UNTRANSLATED, int2fix(HUDX_BIG/2), int2fix(HUDY_BIG/2), 10.0, 2.0 );
	break;
	}




}






function void SetPlayerStuff (void)
{
str Font = "ERFONT"; str Color = "j";
//if  ((StrLen(GetCurrentGameMode()) == 8) && (GetChar(GetCurrentGameMode(), 1) == 85))
if  (GetPort() >= Zandronum)	if(GetCVar("Survival") == TRUE)		{	Font = "SMALLFONT";		Color = "g";}

	if (GAMEINFO[GameSim])
	{

			Thing_ChangeTID(0,PLAYER_TID + PlayerNumber());
			SetActorProperty(0, APROP_RenderStyle, STYLE_Translucent);
			SetActorProperty(0, APROP_Alpha, 1.0);
			PlayerCheckpoint[PlayerNumber()] = 1; //First Round

			TakeInventory(		"BlasterAmmo",  MaxByte);
			SetAmmoCapacity(	"BlasterAmmo",	MaxMoney);

			RegisterMoney(PlayerNumber(), FALSE);
			SpawnSpotForced("BlasterAmmo", 11025, 0, 0);

			if (GetPort() == GZDoom) 	ACS_NamedExecute("CLIENTLOGIC", 0);

				if (RoundInfo[CurrentRound] > 1)
						{
						DamageThing(InstantDeath, MOD_UNKNOWN);
						DrawNotification(For_ActivatorOnly, "TOO LATE TO JOIN!",	notepose_TOP, notepara_CENTER, ICON_None, StrParam(c:ICON_None), "g", "ERFONT", OFF, ON, noteFadeIn_None, noteHold_Standart, noteFadeOut_Standart);
						}


				else
				{

					if(ServerInfo[STAGE] > 0)
					{
					DrawNotification(For_ActivatorOnly, StrParam(s:"SEASON ", i:ServerInfo[SEASON]),	notepose_TOP, notepara_CENTER, ICON_None, StrParam(c:ICON_None), Color, Font,  ON, ON, noteFadeIn_None, noteHold_Started, noteFadeOut_Started);
					DrawNotification(For_ActivatorOnly, StrParam(s:"STAGE ", i:ServerInfo[STAGE]),		notepose_MID, notepara_CENTER, ICON_None, StrParam(c:ICON_None), Color, Font,  ON, ON, noteFadeIn_None, noteHold_Started, noteFadeOut_Started);
					}
					DrawNotification(For_ActivatorOnly, StrParam(s:"TRY #", i:ServerInfo[TRY]), 		notepose_BOT, notepara_CENTER, ICON_None, StrParam(c:ICON_None), Color, Font,  ON, ON, noteFadeIn_None, noteHold_Started, noteFadeOut_Started);
				}

				if  (GetPort() == Zandronum)
							if(LoggedIn(PlayerNumber()) == FALSE)
								if (IsNetworkGame())
											{
											ConsoleCommand("openmenu ZA_LoginMenu");
											DrawNotification(For_ActivatorOnly, StrParam(s:"LOG IN TO BANK MONEY!"), notepose_BOT, notepara_ALIGN, ICON_EXCLAMATION, StrParam(c:ICON_Exclamation), "q", "ERFONT",  OFF, ON, noteFadeIn_Short, noteHold_Long, noteFadeOut_Long);
											}



	}


}






function void MapReset (void)
{

	Switch(GetPort())
	{
	Case ZDaemon:		//in zdaemon ResetMap() works incorrectly. It defaults global vars and forgets console vars by an admin upon reseting. Previously got stuck in a loop above as well.
	Case GZDoom:
		Exit_Normal(0);	//ResetMap();
		break;
	Case Zandronum:

		if (!GetCvar("Survival"))	Exit_Normal(0);
		else						ResetMap();

		break;
	}
}



/*

 _______  __    __  .__   __.   ______ .___________. __    ______   .__   __.                  _______  _______ .__   __.      _______.
|   ____||  |  |  | |  \ |  |  /      ||           ||  |  /  __  \  |  \ |  |        _        /  _____||   ____||  \ |  |     /       |
|  |__   |  |  |  | |   \|  | |  ,----'`---|  |----`|  | |  |  |  | |   \|  |       (_)      |  |  __  |  |__   |   \|  |    |   (----`
|   __|  |  |  |  | |  . `  | |  |         |  |     |  | |  |  |  | |  . `  |                |  | |_ | |   __|  |  . `  |     \   \
|  |     |  `--'  | |  |\   | |  `----.    |  |     |  | |  `--'  | |  |\   |        _       |  |__| | |  |____ |  |\   | .----)   |
|__|      \______/  |__| \__|  \______|    |__|     |__|  \______/  |__| \__|       (_)       \______| |_______||__| \__| |_______/



*/

/*
function int ToRIGHT_or_ToLeft	(int void)
{
int Result = RNG(0,1);
Switch(Result)		{		CASE 0: Result = 1; break;	CASE 1: Result = 3; break;	}		return Result;
}

function int ToUP_or_ToDOWN	(int void)
{
int Result = RNG(0,1);
Switch(Result)		{		CASE 0: Result = 2; break;	CASE 1: Result = 4; break;	}		return Result;
}

*/

function int LayoutType (int AdventureType)
{
int Result;

Switch(AdventureType)
	{
	CASE	adventure_BOSS:			Result = LayoutType_Boss;			break;
	CASE	adventure_MAZE:			Result = LayoutType_Random;			break;
	CASE	adventure_LINEAR:		Result = LayoutType_ByTheList;		break;
	CASE	adventure_RAISE:		Result = LayoutType_ByTheList;		break;
	CASE	adventure_INVASION:		Result = LayoutType_Random;			break;
	CASE	adventure_FLOW:			Result = LayoutType_ByTheList;		break;
	}

return Result;
}


function int AccomplishType (int AdventureType)
{
int Result;

Switch(AdventureType)
	{
	CASE	adventure_BOSS:			Result = AccomplishByENEMYONLY;			break;
	CASE	adventure_MAZE:			Result = AccomplishByTELEPORT;			break;
	CASE	adventure_LINEAR:		Result = AccomplishByTELEPORT;			break;
	CASE	adventure_RAISE:		Result = AccomplishByTELEPORT;			break;
	CASE	adventure_INVASION:		Result = AccomplishByENEMYONLY;			break;
	CASE	adventure_FLOW:			Result = AccomplishByTELEPORT;			break;
	}

return Result;
}

function int MusicType (int AdventureType)
{
int Result;

Switch(AdventureType)
	{
	CASE	adventure_BOSS:			Result = mus_EPIC;						break;
	CASE	adventure_MAZE:			Result = mus_NORM;						break;
	CASE	adventure_LINEAR:		Result = mus_NORM;						break;
	CASE	adventure_RAISE:		Result = mus_EPIC;						break;
	CASE	adventure_INVASION:		Result = mus_NORM;						break;
	CASE	adventure_FLOW:			Result = mus_NORM;						break;
	}

return Result;
}



function int AssignMusic (int MusType)
{
int M;

if (MusType == mus_NORM)
Switch(RNG(1,25))
	{
	//CASE mus_NORM:
	CASE  1: M =  5;	break;
	CASE  2: M =  6;	break;
	CASE  3: M =  7;	break;
	CASE  4: M =  8;	break;
	CASE  5: M =  9;	break;
	CASE  6: M = 10;	break;
	CASE  7: M = 11;	break;
	CASE  8: M = 12;	break;
	CASE  9: M = 13;	break;
	CASE 10: M = 14;	break;
	CASE 11: M = 15;	break;
	CASE 12: M = 16;	break;
	CASE 13: M = 17;	break;
	CASE 14: M = 18;	break;
	CASE 15: M = 19;	break;
	CASE 16: M = 20;	break;
	CASE 17: M = 21;	break;
	CASE 18: M = 22;	break;
	CASE 19: M = 23;	break;
	CASE 20: M = 24;	break;
	CASE 21: M = 25;	break;
	CASE 22: M = 26;	break;
	CASE 23: M = 27;	break;
	CASE 24: M = 28;	break;
	CASE 25: M = 29;	break;
	}


else if (MusType == mus_EPIC)
Switch(RNG(1,3))
	{
	//CASE mus_NORM:
	CASE  1: M = 26;	break;
	CASE  2: M = 30;	break;
	CASE  3: M = 31;	break;
	}


else if (MusType == mus_CALM)
Switch(RNG(1,4))
	{
	//CASE mus_NORM:
	CASE  1: M =  1;	break;
	CASE  2: M =  2;	break;
	CASE  3: M =  3;	break;
	CASE  4: M =  4;	break;
	}

return M;
}



/*
   _____ ____  _   _ _______       _____ _   _ ______ _____         _____ ______ _______
  / ____/ __ \| \ | |__   __|/\   |_   _| \ | |  ____|  __ \       / ____|  ____|__   __|
 | |   | |  | |  \| |  | |  /  \    | | |  \| | |__  | |__) |     | (___ | |__     | |
 | |   | |  | | . ` |  | | / /\ \   | | | . ` |  __| |  _  /       \___ \|  __|    | |
 | |___| |__| | |\  |  | |/ ____ \ _| |_| |\  | |____| | \ \       ____) | |____   | |
  \_____\____/|_| \_|  |_/_/    \_\_____|_| \_|______|_|  \_\     |_____/|______|  |_|


*/



function int ContainerSet (int AdventureType, int ContainerType)
{
int Skript;
int Result;

Switch(AdventureType)
	{
	CASE	adventure_BOSS:


					Switch(ContainerType)
					{
					Case OneBlock:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 1; break;
								}
					break;



					Case TwoBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 2; break;
								}
					break;




					Case ThreeBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 3; break;
								}
					break;




					Case FourBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 4; break;
								}
					break;
					}

	break;




	CASE	adventure_MAZE:


					Switch(ContainerType)
					{
					Case OneBlock:


								Switch(RNG(1,2))
								{
								Case 1: Skript = 1; break;
								Case 2: Skript = 11; break;
								Case 3: Skript = 12; break;
								}
					break;



					Case TwoBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 2; break;
								}
					break;




					Case ThreeBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 3; break;
								}
					break;




					Case FourBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 4; break;
								}
					break;
					}

	break;




	CASE	adventure_LINEAR:

					Switch(ContainerType)
					{
					Case OneBlock:


								Switch(RNG(2,3))
								{
								Case 1: Skript = 1; break;
								Case 2: Skript = 11; break;
								Case 3: Skript = 12; break;
								}
					break;



					Case TwoBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 2; break;
								}
					break;




					Case ThreeBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 3; break;
								}
					break;




					Case FourBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 4; break;
								}
					break;
					}

	break;




	CASE	adventure_RAISE:


					Switch(ContainerType)
					{
					Case OneBlock:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 1; break;
								Case 2: Skript = 11; break;
								}
					break;



					Case TwoBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 2; break;
								}
					break;




					Case ThreeBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 3; break;
								}
					break;




					Case FourBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 4; break;
								}
					break;
					}

	break;




	CASE	adventure_INVASION:


					Switch(ContainerType)
					{
					Case OneBlock:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 1; break;
								}
					break;



					Case TwoBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 2; break;
								}
					break;




					Case ThreeBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 3; break;
								}
					break;




					Case FourBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 4; break;
								}
					break;
					}

	break;

	CASE	adventure_FLOW:


					Switch(ContainerType)
					{
					Case OneBlock:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 1; break;
								}
					break;



					Case TwoBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 2; break;
								}
					break;




					Case ThreeBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 3; break;
								}
					break;




					Case FourBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 4; break;
								}
					break;
					}

	break;
	}




return Skript;
}









/*
   _____ ______ _______                _____  ______
  / ____|  ____|__   __|         /\   |  __ \|  ____|   /\
 | (___ | |__     | |           /  \  | |__) | |__     /  \
  \___ \|  __|    | |          / /\ \ |  _  /|  __|   / /\ \
  ____) | |____   | |         / ____ \| | \ \| |____ / ____ \
 |_____/|______|  |_|        /_/    \_\_|  \_\______/_/    \_\


*/




//2, 4			Y   X
int MiniBlockAt[MBslots][MBslots] =
{
//    0   1   2   3   4   5   6   7   8   9
    {90, 91, 92, 93, 94, 95, 96, 97, 98, 99},	//0

    {89,  0,  1,  2,  3,  4,  5,  6,  7, 64},	//1

    {88,  8,  9, 10, 11, 12, 13, 14, 15, 65},	//2

	{87, 16, 17, 18, 19, 20, 21, 22, 23, 66},	//3

	{86, 24, 25, 26, 27, 28, 29, 30, 31, 67},	//4

	{85, 32, 33, 34, 35, 36, 37, 38, 39, 68},	//5

	{84, 40, 41, 42, 43, 44, 45, 46, 47, 69},	//6

	{83, 48, 49, 50, 51, 52, 53, 54, 55, 70},	//7

	{82, 56, 57, 58, 59, 60, 61, 62, 63, 71},	//8

	{81, 80, 79, 78, 77, 76, 75, 74, 73, 72},	//9
};




function int 	SetArea (int ChangeWhat, int BlockCounter, int Direction,  int MinY, int MaxY, int MinX, int MaxX, int Height, str TX, int Sspecial)
{
int Delaay, y, x, tempZ, FlowX, FlowY;

for (y = MinY; y <= MaxY; y++) {
for (x = MinX; x <= MaxX; x++) {

//FLOOR
if 	((ChangeWhat == area_FLOORnCEIL) || (ChangeWhat == area_FLOOR))
		{
		// MOVE
		//tempZ = GetSectorFloorZ(	TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), None, None) >> 16;		Delaay = GenDel_Height;
		if (Height != ImpossibleNum) 	Floor_MoveToValue(	TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), MoveInstantly, Height);

		// TEXTURES
		if (StrLen(TX) > 0)				ChangeFloor(TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), TX);


		Switch(Sspecial)
				{
				CASE SectorSpecial_CLEAR:
											Scroll_Floor(TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), 0, 0, SCROLL_AND_CARRY);
											Sector_SetDamage(TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), 0, 0);
											SetSectorVisual(TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]));
																																			break;
				CASE SectorSpecial_FLOW:
											Switch(Direction)
											{
											CASE ToRIGHT:	FlowX = 1; FlowY = 0;	break;
											CASE ToDOWN:	FlowX = 0; FlowY =-1;	break;
											CASE ToLEFT:	FlowX =-1; FlowY = 0;	break;
											CASE ToUP:		FlowX = 0; FlowY = 1;	break;
											}
											FlowX = FlowX*RoundInfo[FlowSpeed];		FlowY = FlowY*RoundInfo[FlowSpeed];
											Scroll_Floor(TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), FlowX, FlowY, SCROLL_AND_CARRY);
											//printbold(i:FlowX, s:"   ", i:FlowY);

											break;


				CASE SectorSpecial_DEATH:	Sector_SetDamage(TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), InstantDeath, MOD_EXIT);	break;
				}

		}

// CEILING
if 	((ChangeWhat == area_FLOORnCEIL) || (ChangeWhat == area_CEILING))
		{
		// MOVE
		//tempZ = GetSectorCeilingZ(	TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), None, None) >> 16;		Delaay = GenDel_Height;

		if (Height != ImpossibleNum)	Ceiling_MoveToValue(	TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), MoveInstantly, Height);

		// TEXTURES
		if (StrLen(TX) > 0)				ChangeCeiling(TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), TX);

		}



}}

Delaay = GenDel_Height;
return Delaay;
}






















/*
 __        _______    _    ____   ___  _   _ ____
 \ \      / / ____|  / \  |  _ \ / _ \| \ | / ___|
  \ \ /\ / /|  _|   / _ \ | |_) | | | |  \| \___ \
   \ V  V / | |___ / ___ \|  __/| |_| | |\  |___) |
    \_/\_/  |_____/_/   \_\_|    \___/|_| \_|____/

*/


#libdefine as_CODE 0
#libdefine as_TEXT 1

function str ActorString (int Num, int PrintAs)
{
str Result	= "";
str Code 	= "";
str Text	= "";

Switch(Num)
	{
	CASE id_None: 				Code = "";					Text = "";							break;
	CASE id_Pistol: 			Code = "Pistol";			Text = "Pistol";					break;
	CASE id_Shotgun: 			Code = "Shotgun";			Text = "Shotgun";					break;
	CASE id_Chaingun: 			Code = "Chaingun";			Text = "Chain Gun";					break;
	CASE id_SuperShotgun: 		Code = "SuperShotgun";		Text = "Super Shotgun";				break;
	CASE id_RocketLauncher: 	Code = "RocketLauncher";	Text = "Rocket Launcher";			break;
	CASE id_PlasmaRifle: 		Code = "PlasmaRifle";		Text = "Plasma Rifle";				break;
	CASE id_BFG9000: 			Code = "BFG9000";			Text = "BFG 9000";					break;
	CASE id_Clip: 				Code = "Clip";				Text = "Clip";						break;
	CASE id_ClipBox: 			Code = "ClipBox";			Text = "Box of Bullets";			break;
	CASE id_Shell: 				Code = "Shell";				Text = "Shotgun Shells";			break;
	CASE id_ShellBox: 			Code = "ShellBox";			Text = "Box of Shotgun Shells";		break;
	CASE id_RocketAmmo: 		Code = "RocketAmmo";		Text = "Rocket";					break;
	CASE id_RocketBox: 			Code = "RocketBox";			Text = "Box of Rockets";			break;
	CASE id_Cell: 				Code = "Cell";				Text = "Energy Cell";				break;
	CASE id_CellPack: 			Code = "CellPack";			Text = "Energy Cell Pack";			break;
	CASE id_Backpack: 			Code = "Backpack";			Text = "Backpack full of ammo";		break;
	CASE id_Stimpack: 			Code = "Stimpack";			Text = "Stimpack";					break;
	CASE id_Medkit: 			Code = "Medikit";			Text = "Medikit";					break;
	CASE id_SmallCoin: 			Code = "BlasterAmmo";		Text = "Small Coin";				break;
	CASE id_BigCoin: 			Code = "BlasterHefty";		Text = "Big Coin";					break;

	CASE id_Zombieman: 			Code = "ZombieMan";			break;
	CASE id_Imp: 				Code = "DoomImp";			break;
	CASE id_ShotgunGuy: 		Code = "ShotgunGuy";		break;
	CASE id_Demon: 				Code = "Demon";				break;
	CASE id_HeavyWeaponDude: 	Code = "ChaingunGuy";		break;
	CASE id_Spectre: 			Code = "Spectre";			break;
	CASE id_LostSoul: 			Code = "LostSoul";			break;
	CASE id_Cacodemon: 			Code = "Cacodemon";			break;
	CASE id_HellKnight: 		Code = "HellKnight";		break;
	CASE id_Archvile: 			Code = "Archvile";			break;
	CASE id_Mancubus: 			Code = "Fatso";				break;
	CASE id_BaronOfHell: 		Code = "BaronOfHell";		break;
	CASE id_Arachnotron: 		Code = "Arachnotron";		break;
	CASE id_SpiderMastermind: 	Code = "SpiderMastermind";	break;
	CASE id_Cyberdemon: 		Code = "Cyberdemon";		break;
	CASE id_Railgunner: 		Code = "WolfensteinSS";		break;

	CASE id_ImpBall: 			Code = "DoomImpBall";		break;
	CASE id_BaronBall: 			Code = "BaronBall";			break;
	CASE id_ArachnotronShot: 	Code = "ArachnotronPlasma";	break;
	CASE id_PlasmaBall: 		Code = "PlasmaBall";		break;
	CASE id_CacoBall: 			Code = "CacodemonBall";		break;
	CASE id_RevenantBall: 		Code = "RevenantTracer";	break;
	CASE id_MancubusShot: 		Code = "FatShot";			break;
	CASE id_Rocket: 			Code = "Rocket";			break;
	CASE id_BFGBall: 			Code = "BFGBall";			break;

	CASE id_MarinePlasma: 		Code = "MarinePlasma";		break;
	CASE id_MarineBerserk: 		Code = "MarineBerserk";		break;
	CASE id_MarineChaingun: 	Code = "MarineChaingun";	break;
	CASE id_MarineRocket: 		Code = "MarineRocket";		break;
	CASE id_MarineBFG: 			Code = "MarineBFG";			break;
	CASE id_MarineShotgun: 		Code = "MarineShotgun";		break;
	CASE id_MarineRailgun: 		Code = "MarineRailgun";		break;
	CASE id_MarineSSG: 			Code = "MarineSSG";			break;

	}

Switch(PrintAs)
	{
	CASE as_CODE:	Result = Code;			break;
	CASE as_TEXT:	Result = Text;			break;
	}
return Result;
}



function int SetRoundWeapon (int Difficulty)
{
int Weapon;
		if 		((Difficulty >=   0) && (Difficulty <  10))		Weapon = id_Pistol;
else 	if 		((Difficulty >=  10) && (Difficulty <  20))		Weapon = RNG(id_Pistol, id_Shotgun);
else 	if 		((Difficulty >=  20) && (Difficulty <  30))		Weapon = id_Shotgun;
else 	if 		((Difficulty >=  30) && (Difficulty <  40))		Weapon = RNG(id_Shotgun, id_Chaingun);
else 	if 		((Difficulty >=  40) && (Difficulty <  50))		Weapon = id_Chaingun;
else 	if 		((Difficulty >=  50) && (Difficulty <  60))		Weapon = RNG(id_Chaingun, id_SuperShotgun);
else 	if 		((Difficulty >=  60) && (Difficulty <  95))		Weapon = id_SuperShotgun;
else 	if 		((Difficulty >=  95) && (Difficulty <=100))		Weapon = RNG(id_RocketLauncher, id_PlasmaRifle);
//log (s:"DIFFICULTY IS ", i:Difficulty, s:", WEAPON id is ", i:Weapon);
return Weapon;
}

#libdefine 	si_SECTOR 	0
#libdefine	si_ACTOR 	1
#libdefine	si_DELAY 	2
#libdefine	si_TIMER 	3


#libdefine	item_RANDOM 	-1


#libdefine SectorItemSlots 512		#libdefine SectorItemParams 4
int SectorItem [SectorItemSlots][SectorItemParams];


int Projectila[ProjectilaSlots][ProjectilaParams];



function int SetItem (int BlockCounter, int Direction, int Tag, int idNum)
{
RoundInfo[SectorItemCounter]++;

int Deelay = 1;
	//SET A SECTOR OF RESPAWN-------------------------------------------------------------------------------------------------------------------------------------
	SectorItem [RoundInfo[SectorItemCounter]][si_SECTOR]	=	TagAt (BlockCounter, Direction, Tag);




	//SET AN ACTOR ITSELF-------------------------------------------------------------------------------------------------------------------------------------
if (idNum == item_RANDOM)
	{

			if (RoundInfo[HealthSpawnerCounter] 	== 0)			{	IdNum	=	GetHealthType();		RoundInfo[HealthSpawnerCounter]		= RoundInfo[HealthSpawnerQueue];	}
	else	if (RoundInfo[MoneySpawnerCounter]		== 0)			{	IdNum	=	GetMoneyType();			RoundInfo[MoneySpawnerCounter] 		= RoundInfo[MoneySpawnerQueue];		}
	else	if (RoundInfo[WeaponSpawnerCounter] 	== 0)			{	IdNum	=	GetWeaponType();		RoundInfo[WeaponSpawnerCounter] 	= RoundInfo[WeaponSpawnerQueue];	}
	else	if (RoundInfo[AmmoSpawnerCounter] 		== 0)			{	IdNum	=	GetAmmoType();			RoundInfo[AmmoSpawnerCounter] 		= RoundInfo[AmmoSpawnerQueue];		}
	else															{
																		IdNum	=	id_None;
																		RoundInfo[HealthSpawnerCounter]--;
																		RoundInfo[MoneySpawnerCounter]--;
																		RoundInfo[WeaponSpawnerCounter]--;
																		RoundInfo[AmmoSpawnerCounter]--;
																	}
	}


	SectorItem [RoundInfo[SectorItemCounter]][si_ACTOR]		=	idNum;


	//SET A RESPAWN DELAY-------------------------------------------------------------------------------------------------------------------------------------
						// Num is AMMO
						if ((idNum >= id_minAMMO)		&& 	(idNum <= id_maxAMMO))				SectorItem [RoundInfo[SectorItemCounter]][si_DELAY]	=	Sec*25 + (AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]*3);
						// Num is WEAPON
				else 	if ((idNum >= id_minWEAPON)		&& 	(idNum <= id_maxWEAPON))			SectorItem [RoundInfo[SectorItemCounter]][si_DELAY]	=	Sec*240;
						// Num is HEALTH
				else 	if ((idNum >= id_minHEALTH)		&& 	(idNum <= id_maxHEALTH))			SectorItem [RoundInfo[SectorItemCounter]][si_DELAY]	=	Sec*35 + (AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]*3);
						// Num is Money
				else 	if ((idNum >= id_minMoney)		&& 	(idNum <= id_maxMoney))				SectorItem [RoundInfo[SectorItemCounter]][si_DELAY]	=	Sec*ImpossibleNum;


	//SET TIMER-------------------------------------------------------------------------------------------------------------------------------------
//						SectorItem [RoundInfo[SectorItemCounter]][si_TIMER]	=	SectorItem [RoundInfo[SectorItemCounter]][si_DELAY];





return Deelay;
}

////////////////////////////////////////////////////////////////////////////////////////////////

function int GetWeaponType (void)
{
int Result;
int odds = RNG(1, 100);

Result = RNG(id_SuperShotgun, id_PlasmaRifle);
if (odds > 96)	Result = id_BFG9000;

return Result;
}


////////////////////////////////////////////////////////////////////////////////////////////////





Script "MSG_NewWeapon" (int WeaponType) CLIENTSIDE
{
str Got = "You've got a ";




//SetWeapon(int2str_WEAPON(WeaponType));	doesnt work
if (weaponType > id_Pistol)
		{
		AmbientSound("misc/w_pkup", 127);
		DrawNotification(For_ActivatorOnly, StrParam(s:Got, s:ActorString(WeaponType, as_TEXT), s:"!"), 		notepose_BOT, notepara_ALIGN, ICON_Weapon, StrParam(c:ICON_Weapon), "j", "ERFONT",  ON, OFF, noteFadeIn_Short, noteHold_Short, noteFadeOut_Short);
		}


}

////////////////////////////////////////////////////////////////////////////////////////////////



function int GetAmmoType (void)
{
int Ammo;
int odds = RNG(1, 100);
Switch(AdventureInfo[RNG(1, RoundInfo[CurrentRound])][adv_WEAPON])
		{
		CASE id_Pistol:				Ammo = id_Clip;										break;
		CASE id_Shotgun:			Ammo = RNG(id_Shell, 		id_ShellBox);			break;
		CASE id_Chaingun:			Ammo = RNG(id_Clip, 		id_ClipBox);			break;
		CASE id_SuperShotgun:		Ammo = RNG(id_Shell, 		id_ShellBox);			break;
		CASE id_RocketLauncher:		Ammo = RNG(id_RocketAmmo, 	id_RocketBox);			break;
		CASE id_PlasmaRifle:		Ammo = RNG(id_Cell, 		id_Cell);				break;
		CASE id_BFG9000:			Ammo = RNG(id_Cell, 		id_CellPack);			break;
		}
if (odds > 97)	Ammo = 	id_Backpack;

return Ammo;
}






function int GetHealthType (void)
{
int Result =	RNG(id_Stimpack, id_Medkit);
int odds =		RNG(1, 100);


if (odds > 96)	Result = id_Soulsphere;

return Result;
}


function int GetMoneyType (void)
{
int Result;
int odds = RNG(1, 100);


if (odds > 75)	Result = id_BigCoin;
else			Result = id_SmallCoin;

return Result;
}






Script "Items" (void)
{
int counter;

while(TRUE)
	{
	counter = 0;
	while( counter <= RoundInfo[SectorItemCounter])
		{
		if (IsTIDUsed(ACTORTID_DynamicTid + SectorItem [counter][si_SECTOR]) == FALSE)	//if item was picked or never spawned yet

			if ((SectorItem [counter][si_ACTOR] != id_None)	&&	(SectorItem [counter][si_SECTOR] != 0))
						{
						if (SectorItem [counter][si_TIMER] == 0)	//if it's time to spawn an item
								{


								RefreshSpotHeight(refreshspot_ITEM, counter);
								SpawnSpotForced(ActorString(SectorItem [counter][si_ACTOR], as_CODE), SectorItem [counter][si_SECTOR], ACTORTID_DynamicTid + SectorItem [counter][si_SECTOR], RNG(0,255));
								SpawnSpotForced("ItemFog", 									SectorItem [counter][si_SECTOR], 0, 0);	//visual
								SectorItem [counter][si_TIMER] = SectorItem [counter][si_DELAY];	//Refresh timer for this projectile
								}

						else	SectorItem [counter][si_TIMER]--;
						}
		counter++;
		}

	delay(1);
	}
}







function int SetSubstanceSpeed (void)
{
int Result;
		if  (AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]	<= 20 )																			Result = 		2;
else	if ((AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]	 > 20 )	&&	(AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]	<= 40 ))	Result = RNG(1,2);
else	if ((AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]	 > 40 )	&&	(AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]	<= 60 ))	Result = 		1;
else	if ((AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]	 > 60 )	&&	(AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]	<= 80 ))	Result = RNG(0,1);
else	if  (AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]	 > 80 )																			Result = 		0;

return Result;
}




/*
  _      ____   _____       _______ _____ ____  _   _                _   _ _____         _____ _  ____     ______   ______   __
 | |    / __ \ / ____|   /\|__   __|_   _/ __ \| \ | |         /\   | \ | |  __ \       / ____| |/ /\ \   / /  _ \ / __ \ \ / /
 | |   | |  | | |       /  \  | |    | || |  | |  \| |        /  \  |  \| | |  | |     | (___ | ' /  \ \_/ /| |_) | |  | \ V /
 | |   | |  | | |      / /\ \ | |    | || |  | | . ` |       / /\ \ | . ` | |  | |      \___ \|  <    \   / |  _ <| |  | |> <
 | |___| |__| | |____ / ____ \| |   _| || |__| | |\  |      / ____ \| |\  | |__| |      ____) | . \    | |  | |_) | |__| / . \
 |______\____/ \_____/_/    \_\_|  |_____\____/|_| \_|     /_/    \_\_| \_|_____/      |_____/|_|\_\   |_|  |____/ \____/_/ \_\


*/



function void SetPlaygroundColor (void)
{
int a, b;
Switch(GAMEINFO[Mood]*10 + GAMEINFO[Location])
		{

//EARTH
		CASE 11:											RoundInfo[sct_RED] 		= RNG(224, 255);				RoundInfo[sct_GREEN] 	= RNG(208, 224);			RoundInfo[sct_BLUE]	= RNG(192, 208);			RoundInfo[sct_DESATURATE] = RNG(  0,   0);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 12:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 10;					RoundInfo[sct_BLUE]	= RNG(208, 224);			RoundInfo[sct_DESATURATE] = RNG(104, 128);		RoundInfo[sct_BRIGHTNESS] = RNG(200, 224);	RoundInfo[sct_FADEDIV] = 2.0;	break;
		CASE 13:	b = RNG(216, 224);						RoundInfo[sct_RED] 		= b;							RoundInfo[sct_GREEN] 	= RNG(224, 255);			RoundInfo[sct_BLUE]	= b;						RoundInfo[sct_DESATURATE] = RNG(148, 172);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 2.0;	break;
		CASE 14:											RoundInfo[sct_RED] 		= RNG(245, 255);				RoundInfo[sct_GREEN] 	= RNG(245, 255);			RoundInfo[sct_BLUE]	= RNG(245, 255);			RoundInfo[sct_DESATURATE] = RNG(32, 72);		RoundInfo[sct_BRIGHTNESS] = RNG(200, 224);	RoundInfo[sct_FADEDIV] = 2.0;	break;
		CASE 15:	b = RNG(180, 208);						RoundInfo[sct_RED] 		= RNG(245, 255);				RoundInfo[sct_GREEN] 	= b;						RoundInfo[sct_BLUE]	= b;						RoundInfo[sct_DESATURATE] = RNG(16, 32);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 4.0;	break;
		CASE 16:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 10;					RoundInfo[sct_BLUE]	= a - 20;					RoundInfo[sct_DESATURATE] = RNG(1, 16);			RoundInfo[sct_BRIGHTNESS] = RNG(224, 255);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 17:											RoundInfo[sct_RED] 		= RNG(245, 255);				RoundInfo[sct_GREEN] 	= RNG(245, 255);			RoundInfo[sct_BLUE]	= RNG(245, 255);			RoundInfo[sct_DESATURATE] = RNG(1, 16);			RoundInfo[sct_BRIGHTNESS] = RNG(156, 172);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 18:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a;						RoundInfo[sct_BLUE]	= a;						RoundInfo[sct_DESATURATE] = RNG(1, 16);			RoundInfo[sct_BRIGHTNESS] = RNG(224, 255);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 19:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 20;					RoundInfo[sct_BLUE]	= a - 60;					RoundInfo[sct_DESATURATE] = RNG(16, 32);		RoundInfo[sct_BRIGHTNESS] = RNG(200, 224);	RoundInfo[sct_FADEDIV] = 4.0;	break;
//COLONY
		CASE 21:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 60;					RoundInfo[sct_BLUE]	= a - 120;					RoundInfo[sct_DESATURATE] = RNG(16, 32);		RoundInfo[sct_BRIGHTNESS] = RNG(156, 172);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 22:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 120;					RoundInfo[sct_BLUE]	= a - 120;					RoundInfo[sct_DESATURATE] = RNG(16, 48);		RoundInfo[sct_BRIGHTNESS] = RNG(200, 224);	RoundInfo[sct_FADEDIV] = 4.0;	break;
		CASE 23:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 40;					RoundInfo[sct_BLUE]	= a - 110;					RoundInfo[sct_DESATURATE] = RNG(32, 72);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 2.0;	break;
		CASE 24:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 50;					RoundInfo[sct_BLUE]	= a - 40;					RoundInfo[sct_DESATURATE] = RNG(1, 16);			RoundInfo[sct_BRIGHTNESS] = RNG(200, 224);	RoundInfo[sct_FADEDIV] = 2.0;	break;
		CASE 25:	b = RNG(200, 216);						RoundInfo[sct_RED] 		= b;							RoundInfo[sct_GREEN] 	= RNG(224, 255);			RoundInfo[sct_BLUE]	= b;						RoundInfo[sct_DESATURATE] = RNG(32, 64);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 2.0;	break;
		CASE 26:	b = RNG(216, 235);						RoundInfo[sct_RED] 		= b;							RoundInfo[sct_GREEN] 	= b;						RoundInfo[sct_BLUE]	= RNG(245, 255);			RoundInfo[sct_DESATURATE] = RNG(64, 128);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 2.0;	break;
		CASE 27:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 40;					RoundInfo[sct_BLUE]	= a - 80;					RoundInfo[sct_DESATURATE] = RNG(32, 72);		RoundInfo[sct_BRIGHTNESS] = RNG(200, 224);	RoundInfo[sct_FADEDIV] = 2.0;	break;
		CASE 28:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 20;					RoundInfo[sct_BLUE]	= a - 20;					RoundInfo[sct_DESATURATE] = RNG(32, 72);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 4.0;	break;
		CASE 29:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a;						RoundInfo[sct_BLUE]	= a - 30;					RoundInfo[sct_DESATURATE] = RNG(32, 72);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 2.0;	break;
//SPACE
		CASE 31:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 60;					RoundInfo[sct_BLUE]	= a - 110;					RoundInfo[sct_DESATURATE] = RNG(48, 80);		RoundInfo[sct_BRIGHTNESS] = RNG(224, 255);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 32:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 20;					RoundInfo[sct_BLUE]	= a - 40;					RoundInfo[sct_DESATURATE] = RNG(128, 192);		RoundInfo[sct_BRIGHTNESS] = RNG(224, 255);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 33:	a = RNG(224, 255);						RoundInfo[sct_BLUE] 	= a;							RoundInfo[sct_GREEN] 	= a - 10;					RoundInfo[sct_RED]	= a - 20;					RoundInfo[sct_DESATURATE] = RNG(128, 192);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 34:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a;						RoundInfo[sct_BLUE] = a;						RoundInfo[sct_DESATURATE] = RNG(128, 192);		RoundInfo[sct_BRIGHTNESS] = RNG(224, 255);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 35:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 20;					RoundInfo[sct_BLUE]	= a - 40;					RoundInfo[sct_DESATURATE] = RNG(128, 192);		RoundInfo[sct_BRIGHTNESS] = RNG(224, 255);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 36:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 20;					RoundInfo[sct_BLUE]	= a - 40;					RoundInfo[sct_DESATURATE] = RNG(128, 192);		RoundInfo[sct_BRIGHTNESS] = RNG(224, 255);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 37:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a;						RoundInfo[sct_BLUE] = a;						RoundInfo[sct_DESATURATE] = RNG(72,  128);		RoundInfo[sct_BRIGHTNESS] = RNG(224, 255);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 38:	a = RNG(216, 235);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a;						RoundInfo[sct_BLUE] = a - 30;					RoundInfo[sct_DESATURATE] = RNG(72,  128);		RoundInfo[sct_BRIGHTNESS] = RNG(224, 255);	RoundInfo[sct_FADEDIV] = 4.0;	break;
		CASE 39:	a = RNG(224, 255);						RoundInfo[sct_BLUE] 	= a;							RoundInfo[sct_GREEN] 	= a - 10;					RoundInfo[sct_RED]	= a - 20;					RoundInfo[sct_DESATURATE] = RNG(128, 192);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 0;		break;
		}
}


function void SetSectorVisual (int Tag)
{
//SetFade should be first in Zdaemon, otherwise desaturation wont work;

if (RoundInfo[sct_FADEDIV] > 0)	Sector_SetFade		(Tag, FixedDiv(int2fix(RoundInfo[sct_RED]), RoundInfo[sct_FADEDIV])>>16, FixedDiv(int2fix(RoundInfo[sct_GREEN]), RoundInfo[sct_FADEDIV])>>16, FixedDiv(int2fix(RoundInfo[sct_BLUE]), RoundInfo[sct_FADEDIV])>>16);
								Light_ChangeToValue	(Tag, RoundInfo[sct_BRIGHTNESS]);
								Sector_SetColor		(Tag, RoundInfo[sct_RED], RoundInfo[sct_GREEN], RoundInfo[sct_BLUE], RoundInfo[sct_DESATURATE]);
//log(i:tag);
}



Script "DrawSky" (int Turn, int SkyType) CLIENTSIDE
{
int i;
str sky = "";

Switch(Turn)
		{
		CASE ON:	sky = StrParam(i:SkyType);			break;
		CASE OFF:	sky = "00";							break;
		}




for (i = 1; i <= 64;  i++)			ChangeFloor		(SECTORTAG_Skybox + i,								StrParam(s:"SK", s:sky, s:"FL", i:i));
for (i = 1; i <= 64;  i++)			ChangeCeiling	(SECTORTAG_Skybox + i, 								StrParam(s:"SK", s:sky, s:"CE", i:i));
for (i = 1; i <=  4;  i++)			SetLineTexture	(SECTORTAG_Skybox + i, SIDE_FRONT, TEXTURE_MIDDLE,	StrParam(s:"SK", s:sky, s:"WA", i:i));



i = GetSectorLightLevel(TIDRAM_SkyboxVolume);
Switch(Turn)
		{
		CASE ON:	TranslucentLine(LINETAG_VolumetricD_up, 0, 1);					TranslucentLine(LINETAG_VolumetricD_dn, 0, 1);		break;
		CASE OFF:	TranslucentLine(LINETAG_VolumetricD_up, i, 1);					TranslucentLine(LINETAG_VolumetricD_dn, i, 1);		break;
		}


}


function str FailTextureName (void)
{
str Result = "";
Switch(GAMEINFO[Mood])
		{
		CASE mood_EARTH: 	Result = "LAVA";	break;
		CASE mood_COLONY:
		CASE mood_SPACE: 	Result = "SLIME";	break;
		}
return Result;
}



function str CreateLocationName (void)
{
int RootCount = RNG(25, 100);
int counter;
int Inter = RNG(0, 60);

str Name = "";	int MoodNameAt = RNG(ON,OFF);	//ON - at the start, OFF - at the end
//---------------------------------------------------------------------------------------------
if (MoodNameAt == ON)		Name = StrParam(s:Name, s:strMood(ON));
//---------------------------------------------------------------------------------------------


if (RootCount > 50)	RootCount = 1;
else RootCount = 0;

counter = 0;
while(counter <= RootCount)
	{
	Name = StrParam(s:Name, s:strLocationRoot());

	if (counter < RootCount)
		if (Inter > 50)
				{
				Name = StrParam(s:Name, s:strLocationInter());
				}
	counter++;
	}
//---------------------------------------------------------

Switch(RNG(false, true))
		{
		CASE true:	Name = StrParam(s:Name, s:strLocationEnding());		break;
		}
//---------------------------------------------------------
if (MoodNameAt == OFF)		Name = StrParam(s:Name, s:strMood(OFF));

return Name;
}







function str  strMood (int Part)
{
str Result = "";	str Start = ""; str End = "";
Switch(GAMEINFO[Mood]*10 + RNG(1, 3))
	{
	CASE 11:	Start = "State of "; 		End = "'s State";				break;
	CASE 12:	Start = "Country of "; 		End = "'s Country";				break;
	CASE 13:	Start = "The Land of "; 	End = "'s Land";				break;
	CASE 21:	Start = "Colony of "; 		End = " Colony";				break;
	CASE 22:	Start = "Satelite in "; 	End = "'s Satelite";			break;
	CASE 23:	Start = "A Star of "; 		End = " Star";					break;
	CASE 31:	Start = "Galaxy of "; 		End = " Galaxy";				break;
	CASE 32:	Start = "Universe of "; 	End = "'s Universe";			break;
	CASE 33:	Start = "Station of "; 		End = "'s Space Station";		break;
	}
Switch(Part)
		{
		CASE ON:	Result = Start;		break;
		CASE OFF:	Result = End;		break;
		}


return Result;
}






function str  strLocationRoot (void)
{
int Vari = RNG(1, 15);
int A;
Switch(RNG(65,68))
	{
	CASE 65:	//A
	Switch(Vari)
		{
		CASE 1: A = "amin"; 	break;				CASE 2: A = "ashi"; 	break;			CASE 3: A = "aegon"; 	break;				CASE 4: A = "ar"; 	break;					CASE 5: A = "ajith"; 	break;
		CASE 6: A = "axil"; 	break;				CASE 7: A = "aworth"; 	break;			CASE 8: A = "api"; 		break;				CASE 9: A = "abas"; 	break;				CASE 10: A = "Aphir"; 	break;
		CASE 11: A = "azi"; 	break;				CASE 12: A = "aldo"; 	break;			CASE 13: A = "avo"; 	break;				CASE 14: A = "aken"; 	break;				CASE 15: A = "asho"; 	break;
		}
	break;

	CASE 66:	//B
	Switch(Vari)
		{
		CASE 1: A = "bori"; 	break;				CASE 2: A = "becki"; 	break;			CASE 3: A = "bith"; 	break;				CASE 4: A = "bolp"; 	break;				CASE 5: A = "beert"; 	break;
		CASE 6: A = "benshi"; 	break;				CASE 7: A = "bagh"; 	break;			CASE 8: A = "beesh"; 	break;				CASE 9: A = "balin"; 	break;				CASE 10: A = "barc"; 	break;
		CASE 11: A = "bosch"; 	break;				CASE 12: A = "binli"; 	break;			CASE 13: A = "bio"; 	break;				CASE 14: A = "boja"; 	break;				CASE 15: A = "beel"; 	break;
		}
	break;

	CASE 67:	//C
	Switch(Vari)
		{
		CASE 1: A = "cosc"; 	break;				CASE 2: A = "coort"; 	break;			CASE 3: A = "chash"; 	break;				CASE 4: A = "circ"; 	break;				CASE 5: A = "clea"; 	break;
		CASE 6: A = "confo"; 	break;				CASE 7: A = "cath"; 	break;			CASE 8: A = "corth"; 	break;				CASE 9: A = "corgh"; 	break;				CASE 10: A = "coed"; 	break;
		CASE 11: A = "cenz"; 	break;				CASE 12: A = "coam"; 	break;			CASE 13: A = "chort"; 	break;				CASE 14: A = "ciph"; 	break;				CASE 15: A = "choep"; 	break;
		}
	break;

	CASE 68:	//D
	Switch(Vari)
		{
		CASE 1: A = "deesh"; 	break;				CASE 2: A = "dozh"; 	break;			CASE 3: A = "deit"; 	break;				CASE 4: A = "doom"; 	break;				CASE 5: A = "doon"; 	break;
		CASE 6: A = "daek"; 	break;				CASE 7: A = "dorth"; 	break;			CASE 8: A = "dyna"; 	break;				CASE 9: A = "dimo"; 	break;				CASE 10: A = "dzhan"; 	break;
		CASE 11: A = "dzhoy"; 	break;				CASE 12: A = "doris"; 	break;			CASE 13: A = "dari"; 	break;				CASE 14: A = "dokh"; 	break;				CASE 15: A = "dost"; 	break;
		}
	break;
	}

return A;
}

function str strLocationInter (void)
{
int A;
Switch(RNG(1,10))
	{
	CASE 1: A = "-or-"; 	break;				CASE 2: A = "-dit-"; 	break;			CASE 3: A = "-aq-"; 	break;				CASE 4: A = "-nes-"; 	break;				CASE 5: A = "-la-"; 	break;
	CASE 6: A = "-tez-"; 	break;				CASE 7: A = "ton-"; 	break;			CASE 8: A = "-qi-"; 	break;				CASE 9: A = "-mar-"; 	break;				CASE 10: A = "-ken-"; 	break;
	}
return A;
}



function str strLocationEnding (void)
{
int A;
Switch(RNG(1,25))
	{
	CASE 1: A = "adia"; 	break;				CASE 2: A = "ia"; 	break;			CASE 3: A = "ria"; 	break;				CASE 4: A = "cain"; 	break;				CASE 5: A = "la"; 		break;
	CASE 6: A = "via"; 	break;					CASE 7: A = "que"; 	break;			CASE 8: A = "rra"; 	break;				CASE 9: A = "ius"; 	break;					CASE 10: A = "dos"; 	break;
	CASE 11: A = "ros"; 	break;				CASE 12: A = "tos"; break;		CASE 13: A = "roon"; 	break;				CASE 14: A = "an"; 	break;					CASE 15: A = "and"; 	break;
	CASE 16: A = "rica"; 	break;				CASE 17: A = "nes"; break;		CASE 18: A = "dor"; 	break;				CASE 19: A = "nia"; 	break;				CASE 20: A = "gia"; 	break;
	CASE 21: A = "any"; 	break;				CASE 22: A = "ity"; break;		CASE 23: A = "ver"; 	break;				CASE 24: A = "key"; 	break;				CASE 25: A = "see"; 	break;
	}
return A;
}






/*
  _____  _____   ____       _ ______ _____ _______ _____ _      ______  _____
 |  __ \|  __ \ / __ \     | |  ____/ ____|__   __|_   _| |    |  ____|/ ____|
 | |__) | |__) | |  | |    | | |__ | |       | |    | | | |    | |__  | (___
 |  ___/|  _  /| |  | |_   | |  __|| |       | |    | | | |    |  __|  \___ \
 | |    | | \ \| |__| | |__| | |___| |____   | |   _| |_| |____| |____ ____) |
 |_|    |_|  \_\\____/ \____/|______\_____|  |_|  |_____|______|______|_____/


*/










function int SetProjectile (int ProjPart, int ProjRole, int BlockCounter, int Direction, int EmitTag, int DevourTag, int Angle, int AddHeight, int Difficulty)
{
int exc, Delaay, IsAtException, TagHeight, ExceptionHeight, Tag, ArrayRole, LineTag;
bool DontMoveGeometry;
Difficulty 		= WithinHundred(AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY] + Difficulty);

Switch(ProjRole)
		{
		CASE ProjRole_EMIT: 	ArrayRole = ProjParam_EMITSPOT; 	Tag = EmitTag; 		break;
		CASE ProjRole_DEVOUR: 	ArrayRole = ProjParam_DEVOURSPOT; 	Tag = DevourTag;	break;
		}


if ((ProjPart == area_FLOOR) || (ProjPart == area_CEILING))
		{

		// CHANGE HEIGHTS
		for (exc = 0; exc <= RoundInfo[BorderExceptionCounter]; exc++)				// if 			SPOT IS AT ALREADY USED (Emitter Spot)												SPOT IS AT ALREADY USED (Devour Spot)
																					if ((TagAt (BlockCounter, Direction, Tag) == Projectila[exc][ProjParam_EMITSPOT])	||	(TagAt (BlockCounter, Direction, Tag) == Projectila[exc][ProjParam_DEVOURSPOT]))
																						{

																							IsAtException = true;
																							//log(s:"\ctException is at ", i:TagAt (BlockCounter, Direction, Tag));
																							Switch(ProjPart)
																									{
																									CASE area_FLOOR:
																														TagHeight		= int2fix(RoundInfo[CurrFloorHeight]	+	ProjHoleHeight	+	AddHeight);
																														ExceptionHeight = int2fix(Projectila[exc][ArrayRole]	+	ProjHoleHeight	+	AddHeight);

																															if (TagHeight  >=   ExceptionHeight)
																																	{
																																	DontMoveGeometry = true;
																																	Delaay = 0;
																																	}
																									break;

																									//--------------------------------------------------------------------------------------------------------

																									CASE area_CEILING:
																														TagHeight		= int2fix(RoundInfo[CurrFloorHeight]	+	ProjHoleHeight	+	AddHeight	+	ProjHoleSize);
																														ExceptionHeight = int2fix(Projectila[exc][ArrayRole]	+	ProjHoleHeight	+	AddHeight	+	ProjHoleSize);

																															if (TagHeight  <=   ExceptionHeight)
																																	{
																																	DontMoveGeometry = true;
																																	Delaay = 0;
																																	}
																									break;
																									}

																						if (DontMoveGeometry == true) break;


																						}

				if (DontMoveGeometry == FALSE)
							{

							Delaay = GenDel_Height;		// do delay only after floors, because delaying switching emit ceiling to devour floor is pointless

							Switch(ProjPart)
										{
										CASE area_FLOOR:
															TagHeight = RoundInfo[CurrFloorHeight]	+	ProjHoleHeight	+	AddHeight;
															Floor_MoveToValue	(TagAt (BlockCounter, Direction, Tag), 			MoveInstantly, TagHeight);
															ChangeFloor			(TagAt (BlockCounter, Direction, Tag),  		TextureIs(FlatEDGEtx));
										break;


										CASE area_CEILING:
															TagHeight = RoundInfo[CurrFloorHeight]	+	ProjHoleHeight	+	AddHeight	+	ProjHoleSize;
															Ceiling_MoveToValue	(TagAt (BlockCounter, Direction, Tag), 			MoveInstantly, TagHeight);
															ChangeCeiling		(TagAt (BlockCounter, Direction, Tag),  		TextureIs(FlatEDGEtx));
										break;

										}

							}

				// SET LINES
				if (ProjPart == area_CEILING)	//Set Textures once we move the ceiling
					{

											// F R O N T L I N E
															LineTag = LineAt (BlockCounter, Direction, AssignLine (SIDE_FRONT, 	Tag));
															Switch(ProjRole)
															{
															CASE ProjRole_EMIT:																	break;
															CASE ProjRole_DEVOUR:
															SetLineSpecial(		LineTag, 	ACS_ExecuteAlways, SCRIPT_DestroyProjectile);		break;
															}
															Line_SetBlocking(	LineTag,	false, 			BLOCKF_EVERYTHING);
															Line_SetBlocking(	LineTag,	false, 			BLOCKF_PROJECTILES);
															Line_SetBlocking(	LineTag,	BLOCKF_SIGHT, 		false);
															Line_SetBlocking(	LineTag,	BLOCKF_CREATURES, 	false);
															SetLineTexture(		LineTag,	SIDE_FRONT,	TEXTURE_MIDDLE, "BLACKWAL");
															SetLineTexture(		LineTag,	SIDE_BACK,	TEXTURE_MIDDLE, "BLACKWAL");

											// B A C K L I N E		(if that's a new block in the exceptions, then also fill the backline)
											if (IsAtException == false)
															{
															LineTag = LineAt (BlockCounter, Direction, AssignLine (SIDE_BACK, 	Tag));
															Line_SetBlocking(	LineTag,	BLOCKF_EVERYTHING, 	false);
															Line_SetBlocking(	LineTag,	BLOCKF_SIGHT, 		false);
															SetLineTexture(		LineTag,	SIDE_FRONT,	TEXTURE_MIDDLE, TextureIs(WallEDGEtx));
															SetLineTexture(		LineTag,	SIDE_BACK,	TEXTURE_MIDDLE, TextureIs(WallEDGEtx));
																	// S I D E L I N E 		(if this block is located at the entrance)
																	if (AssignLine (SIDE_SIDEY, 	Tag) != 0)
																	{
																	LineTag = LineAt (BlockCounter, Direction, AssignLine (SIDE_SIDEY, 	Tag));
																	Line_SetBlocking(	LineTag,	BLOCKF_EVERYTHING, 	false);
																	Line_SetBlocking(	LineTag,	BLOCKF_SIGHT, 		false);
																	SetLineTexture(		LineTag,	SIDE_FRONT,	TEXTURE_MIDDLE, TextureIs(WallEDGEtx));
																	SetLineTexture(		LineTag,	SIDE_BACK,	TEXTURE_MIDDLE, TextureIs(WallEDGEtx));
																	}
															}

					}

		}







if (ProjPart == area_PREPARATION)
		{

		//ASSIGNING A BORDER EXCEPTION
		RoundInfo[BorderExceptionCounter]++;


				if 		((Difficulty <=   0) && (Difficulty <  10))		{	ProjRole = RNG(id_None, 					id_ImpBall			);		ArrayRole = 95;						Tag = 95;					}
		else 	if 		((Difficulty >=  10) && (Difficulty <  20))		{	ProjRole = RNG(id_ImpBall, 				id_BaronBall		);		ArrayRole = 100;					Tag = 90;					}
		else 	if 		((Difficulty >=  20) && (Difficulty <  30))		{	ProjRole = RNG(id_BaronBall, 			id_ArachnotronShot	);		ArrayRole = 105;					Tag = 85;					}
		else 	if 		((Difficulty >=  30) && (Difficulty <  40))		{	ProjRole = RNG(id_ArachnotronShot, 		id_PlasmaBall		);		ArrayRole = 110 + 5*RNG(1,3);	Tag = 80;					}
		else 	if 		((Difficulty >=  40) && (Difficulty <  50))		{	ProjRole = RNG(id_PlasmaBall,			id_CacoBall			);		ArrayRole = 115 + 5*RNG(1,3);	Tag = 75;					}
		else 	if 		((Difficulty >=  50) && (Difficulty <  60))		{	ProjRole = RNG(id_CacoBall,				id_RevenantBall		);		ArrayRole = 120 + 5*RNG(1,4);	Tag = 70;					}
		else 	if 		((Difficulty >=  60) && (Difficulty <  70))		{	ProjRole = RNG(id_RevenantBall,			id_MancubusShot		);		ArrayRole = 125 + 5*RNG(1,4);	Tag = 65;					}
		else 	if 		((Difficulty >=  70) && (Difficulty <  80))		{	ProjRole = RNG(id_MancubusShot,			id_Rocket	 		);		ArrayRole = 130 + 5*RNG(1,5);	Tag = 60;					}
		else 	if 		((Difficulty >=  80) && (Difficulty <  90))		{	ProjRole = RNG(id_Rocket,				id_Rocket 			);		ArrayRole = 135 + 5*RNG(1,5);	Tag = 55 + 5*RNG(1,2);	}
		else 	if 		((Difficulty >=  90) && (Difficulty < 100))		{	ProjRole = RNG(id_Rocket,				id_BFGBall			);		ArrayRole = 140 + 5*RNG(1,6);	Tag = 40 + RNG(0,10);	}
		else 	if 		(Difficulty	 >= 100)							{	ProjRole = RNG(id_BFGBall,				id_BFGBall			);		ArrayRole = 145 + 5*RNG(1,10);	Tag = 35 + RNG(0,10);	}




		//Assigning a projectile actor
		Projectila[RoundInfo[BorderExceptionCounter]][ProjParam_EMITSPOT]	= TagAt (BlockCounter, Direction, EmitTag);
		Projectila[RoundInfo[BorderExceptionCounter]][ProjParam_DEVOURSPOT]	= TagAt (BlockCounter, Direction, DevourTag);
		Projectila[RoundInfo[BorderExceptionCounter]][ProjParam_TYPE] 		= ProjRole;
		Projectila[RoundInfo[BorderExceptionCounter]][ProjParam_SPEED]		= ArrayRole;
		Projectila[RoundInfo[BorderExceptionCounter]][ProjParam_ANGLE]		= ActorAngle(Angle, Direction, BYTE);
		Projectila[RoundInfo[BorderExceptionCounter]][ProjParam_DELAY]		= Tag;
		Projectila[RoundInfo[BorderExceptionCounter]][ProjParam_HEIGHT]		= RoundInfo[CurrFloorHeight]	+	ProjHoleHeight	+	AddHeight;
		Projectila[RoundInfo[BorderExceptionCounter]][ProjParam_TIMER]		= Projectila[RoundInfo[BorderExceptionCounter]][ProjParam_DELAY];

		}




return Delaay;

}





Script "Projectiles" (void)
{
int counter;

while(TRUE)
	{
	counter = 0;
	while( counter <= RoundInfo[BorderExceptionCounter])
		{
		if (Projectila[counter][ProjParam_EMITSPOT] != 0)
					{
					if (Projectila[counter][ProjParam_TIMER] == 0)	//if it's time to fire a projectile
							{
							RefreshSpotHeight(refreshspot_PROJECTILE, counter);
							SpawnProjectile(Projectila[counter][ProjParam_EMITSPOT], ActorString(Projectila[counter][ProjParam_TYPE], as_CODE), Projectila[counter][ProjParam_ANGLE], Projectila[counter][ProjParam_SPEED], 0, 0, ACTORTID_Projectile);
							Projectila[counter][ProjParam_TIMER] = Projectila[counter][ProjParam_DELAY];	//Refresh timer for this projectile
							}

					else	Projectila[counter][ProjParam_TIMER]--;
					}
		counter++;
		}

	delay(1);
	}
}




Script SCRIPT_DestroyProjectile (void)
{
if (LineSide() == LINE_FRONT)	Thing_Remove(0);
}










///////////////////////////////////////////////////////////////////////////////////////////////////////////////



function int BlockAtAXIS (int Which, int Num)
{
int Result, Y, X;
Switch (Num)
	{
	CASE  1:Y = 0; X = 0;break;CASE  2:Y = 0; X = 1;break;CASE  3:Y = 0; X = 2;break;CASE  4:Y = 0; X = 3;break;CASE  5:Y = 0; X = 4;break;
	CASE  6:Y = 1; X = 0;break;CASE  7:Y = 1; X = 1;break;CASE  8:Y = 1; X = 2;break;CASE  9:Y = 1; X = 3;break;CASE 10:Y = 1; X = 4;break;
	CASE 11:Y = 2; X = 0;break;CASE 12:Y = 2; X = 1;break;CASE 13:Y = 2; X = 2;break;CASE 14:Y = 2; X = 3;break;CASE 15:Y = 2; X = 4;break;
	CASE 16:Y = 3; X = 0;break;CASE 17:Y = 3; X = 1;break;CASE 18:Y = 3; X = 2;break;CASE 19:Y = 3; X = 3;break;CASE 20:Y = 3; X = 4;break;
	CASE 21:Y = 4; X = 0;break;CASE 22:Y = 4; X = 1;break;CASE 23:Y = 4; X = 2;break;CASE 24:Y = 4; X = 3;break;CASE 25:Y = 4; X = 4;break;
	}


Switch(Which)
	{
	CASE AxisY: Result = Y; break;
	CASE AxisX: Result = X; break;
	}

return Result;
}



function str BlockAtBC (int Num)
{
str Result = "";
Switch (Num)
	{
	CASE  1:Result=BlockAt[0][0];break;CASE  2:Result=BlockAt[0][1];break;CASE  3:Result=BlockAt[0][2];break;CASE  4:Result=BlockAt[0][3];break;CASE  5:Result=BlockAt[0][4];break;CASE  6:Result=BlockAt[0][5];break;CASE  7:Result=BlockAt[0][6];break;
	CASE  8:Result=BlockAt[1][0];break;CASE  9:Result=BlockAt[1][1];break;CASE 10:Result=BlockAt[1][2];break;CASE 11:Result=BlockAt[1][3];break;CASE 12:Result=BlockAt[1][4];break;CASE 13:Result=BlockAt[1][5];break;CASE 14:Result=BlockAt[1][6];break;
	CASE 15:Result=BlockAt[2][0];break;CASE 16:Result=BlockAt[2][1];break;CASE 17:Result=BlockAt[2][2];break;CASE 18:Result=BlockAt[2][3];break;CASE 19:Result=BlockAt[2][4];break;CASE 20:Result=BlockAt[2][5];break;CASE 21:Result=BlockAt[2][6];break;
	CASE 22:Result=BlockAt[3][0];break;CASE 23:Result=BlockAt[3][1];break;CASE 24:Result=BlockAt[3][2];break;CASE 25:Result=BlockAt[3][3];break;CASE 26:Result=BlockAt[3][4];break;CASE 27:Result=BlockAt[3][5];break;CASE 28:Result=BlockAt[3][6];break;
	CASE 29:Result=BlockAt[4][0];break;CASE 30:Result=BlockAt[4][1];break;CASE 31:Result=BlockAt[4][2];break;CASE 32:Result=BlockAt[4][3];break;CASE 33:Result=BlockAt[4][4];break;CASE 34:Result=BlockAt[4][5];break;CASE 35:Result=BlockAt[4][6];break;
	CASE 36:Result=BlockAt[5][0];break;CASE 37:Result=BlockAt[5][1];break;CASE 38:Result=BlockAt[5][2];break;CASE 39:Result=BlockAt[5][3];break;CASE 40:Result=BlockAt[5][4];break;CASE 41:Result=BlockAt[5][5];break;CASE 42:Result=BlockAt[5][6];break;
	CASE 43:Result=BlockAt[6][0];break;CASE 44:Result=BlockAt[6][1];break;CASE 45:Result=BlockAt[6][2];break;CASE 46:Result=BlockAt[6][3];break;CASE 47:Result=BlockAt[6][4];break;CASE 48:Result=BlockAt[6][5];break;CASE 49:Result=BlockAt[6][6];break;
	}
return Result;
}




function bool CheckArea(int ContainerType, int Direction, int RowNum, int ColumnNum)
{
bool Result; int FreeBlocks;
for (int y = RowNum; 	y < RowNum		+ ContainerMass(AxisY, ContainerType, Direction); y++) {
for (int x = ColumnNum; x < ColumnNum 	+ ContainerMass(AxisX, ContainerType, Direction); x++) {


	if 	(
		(StrLen(BlockAt	[Y]	[X]) <= 1)  &&
			(
			( ColumnNum 	+ ContainerMass(AxisX, ContainerType, Direction)	<=	sqrt(PlaygroundBlocks))	&&
			( RowNum		+ ContainerMass(AxisY, ContainerType, Direction)	<=	sqrt(PlaygroundBlocks))
			)
		)
	FreeBlocks++;




}}

	if (FreeBlocks == ContainerType) 	Result = true;
	else Result = false;



Return Result;
}


function void FillArea(int WhatToDo, int ContainerType, int Direction, int RowNum, int ColumnNum, int VecIn, int VecOut, int Zpecial)
{
int x, y;
str StrDir = "";	str StrVecIn = "";	str StrVecOut = "";	str StrZpe = "";


Switch(WhatToDo)
{
CASE 0:

for (y = 0; y < sqrt(PlaygroundBlocks); y++) {
for (x = 0; x < sqrt(PlaygroundBlocks); x++) {

BlockAt[Y][X] = "Z";


}}


break;

CASE 1:

//debug
int color  = RNG(97, 122);
if (color == 108) color = 99;
str Dir = "";



Switch(Direction)
	{
	CASE NONE:			StrDir = "*";	break;
	CASE ToRight:		StrDir = ">";	break;
	CASE ToDown:		StrDir = "v";	break;
	CASE ToLeft:		StrDir = "<";	break;
	CASE ToUp:			StrDir = "^";	break;
	}


Switch(VecIn)
	{
	CASE NONE:			StrVecIn = "*";	break;
	CASE ToRight:		StrVecIn = ">";	break;
	CASE ToDown:		StrVecIn = "v";	break;
	CASE ToLeft:		StrVecIn = "<";	break;
	CASE ToUp:			StrVecIn = "^";	break;
	}

Switch(VecOut)
	{
	CASE NONE:			StrVecOut = "*";break;
	CASE ToRight:		StrVecOut = ">";break;
	CASE ToDown:		StrVecOut = "v";break;
	CASE ToLeft:		StrVecOut = "<";break;
	CASE ToUp:			StrVecOut = "^";break;
	}

Switch(Zpecial)
	{
	CASE NONE:						StrZpe = "--";	break;
	CASE Stairs_NORMAL:				StrZpe = "SN";	break;
	CASE Stairs_DIAGONAL_right:		StrZpe = "dR";	break;
	CASE Stairs_DIAGONAL_left:		StrZpe = "dL";	break;
	CASE StartBlock:				StrZpe = "$$";	break;
	CASE FinishBlock:				StrZpe = "XX";	break;
	}

for (y = RowNum; 	y < RowNum		+ ContainerMass(AxisY, ContainerType, Direction); y++) {
for (x = ColumnNum; x < ColumnNum 	+ ContainerMass(AxisX, ContainerType, Direction); x++) {


	Switch(GetPort())
	{
	Case ZDaemon:
		BlockAt[Y][X] = ContainerStr(ContainerType, Direction);
		//BlockAt[Y][X] = StrParam(i:ContainerType, i:Direction);
		break;
	Case Zandronum: Case GZDoom:
		BlockAt[Y][X] = StrParam(s:"\c", c:color, s:StrDir, i:ContainerType, s:StrZpe, s:StrVecIn, s:StrVecOut, s:"\cl");
		break;
	}


}}

break;
}


}









function bool BlockCounterAtTheEdge (int Side, int BlockCounter)
{
int i;
bool Result;

Switch(SIDE)
	{
	CASE ToRIGHT:
	for (i = 1; i <= sqrt(PlaygroundBlocks); i++)
	if 		(BlockCounter == (sqrt(PlaygroundBlocks)*i))							Result = TRUE;
	break;


	CASE ToDOWN:
	if 		(BlockCounter > (PlaygroundBlocks - sqrt(PlaygroundBlocks))) 			Result = TRUE;
	break;


	CASE ToLEFT:
	for (i = 0; i < sqrt(PlaygroundBlocks); i++)
	if 		(BlockCounter == (sqrt(PlaygroundBlocks)*i + 1))						Result = TRUE;
	break;


	CASE ToUP:
	if 		((BlockCounter > 0) && (BlockCounter <= sqrt(PlaygroundBlocks)))		Result = TRUE;
	break;
	}



return Result;
}





function int LineAt (int BlockCounter, int Direction, int Line)		//BlockCounter is only needed to check if its the edge of the map
{
int Result, A;

Switch(Direction)
	{
	Case ToRIGHT:

	Switch(Line)
			{
			Case  0: A = BlockCounter;				break;			//BASIC INSIDE
			Case 99: A = B2S(BlockCounter) +  0;	break;			//BASIC BORDER

	//Right Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 21: A = B2S(BlockCounter) + 21;	break;										Case 22: A = B2S(BlockCounter) + 22;	break;										Case 23: A = B2S(BlockCounter) + 23;	break;
			Case 24: A = B2S(BlockCounter) + 24;	break;										Case 25: A = B2S(BlockCounter) + 25;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 26: A = B2S(BlockCounter) + 26;	break;										Case 27: A = B2S(BlockCounter) + 27;	break;										Case 28: A = B2S(BlockCounter) + 28;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 31: A = B2S(BlockCounter) + 31;	break;										Case 32: A = B2S(BlockCounter) + 32;	break;										Case 33: A = B2S(BlockCounter) + 33;	break;
			Case 34: A = B2S(BlockCounter) + 34;	break;										Case 35: A = B2S(BlockCounter) + 35;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 36: A = B2S(BlockCounter) + 36;	break;										Case 37: A = B2S(BlockCounter) + 37;	break;										Case 38: A = B2S(BlockCounter) + 38;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 20: A = B2S(BlockCounter) + 20;	break;										Case 30: A = B2S(BlockCounter) + 30;	break;										Case 29: A = B2S(BlockCounter) + 29;	break;

	//Down Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 41: A = B2S(BlockCounter) + 41;	break;										Case 42: A = B2S(BlockCounter) + 42;	break;										Case 43: A = B2S(BlockCounter) + 43;	break;
			Case 44: A = B2S(BlockCounter) + 44;	break;										Case 45: A = B2S(BlockCounter) + 45;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 46: A = B2S(BlockCounter) + 46;	break;										Case 47: A = B2S(BlockCounter) + 47;	break;										Case 48: A = B2S(BlockCounter) + 48;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 51: A = B2S(BlockCounter) + 51;	break;										Case 52: A = B2S(BlockCounter) + 52;	break;										Case 53: A = B2S(BlockCounter) + 53;	break;
			Case 54: A = B2S(BlockCounter) + 54;	break;										Case 55: A = B2S(BlockCounter) + 55;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 56: A = B2S(BlockCounter) + 56;	break;										Case 57: A = B2S(BlockCounter) + 57;	break;										Case 58: A = B2S(BlockCounter) + 58;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 40: A = B2S(BlockCounter) + 40;	break;										Case 50: A = B2S(BlockCounter) + 50;	break;										Case 49: A = B2S(BlockCounter) + 49;	break;

	//Left Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 61: A = B2S(BlockCounter) - 62;	break;										Case 62: A = B2S(BlockCounter) - 63;	break;										Case 63: A = B2S(BlockCounter) - 64;	break;
			Case 64: A = B2S(BlockCounter) - 65;	break;										Case 65: A = B2S(BlockCounter) - 66;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 66: A = B2S(BlockCounter) - 67;	break;										Case 67: A = B2S(BlockCounter) - 68;	break;										Case 68: A = B2S(BlockCounter) - 69;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 71: A = B2S(BlockCounter) - 72;	break;										Case 72: A = B2S(BlockCounter) - 73;	break;										Case 73: A = B2S(BlockCounter) - 74;	break;
			Case 74: A = B2S(BlockCounter) - 75;	break;										Case 75: A = B2S(BlockCounter) - 76;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 76: A = B2S(BlockCounter) - 77;	break;										Case 77: A = B2S(BlockCounter) - 78;	break;										Case 78: A = B2S(BlockCounter) - 79;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 60: A = B2S(BlockCounter) - 70;	break;										Case 70: A = B2S(BlockCounter) - 80;	break;										Case 69: A = B2S(BlockCounter) - 71;	break;

	//Up Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 81: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 58;	break;			Case 82: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 57;	break;			Case 83: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 56;	break;
			Case 84: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 55;	break;			Case 85: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 54;	break;			//   < - - -  E N T R A N C E   T A G S   ---
			Case 86: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 53;	break;			Case 87: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 52;	break;			Case 88: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 51;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 91: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 48;	break;			Case 92: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 47;	break;			Case 93: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 46;	break;
			Case 94: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 45;	break;			Case 95: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 44;	break;			//   < - - -  E N T R A N C E   T A G S   ---
			Case 96: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 43;	break;			Case 97: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 42;	break;			Case 98: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 41;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 80: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 50;	break;			Case 90: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 40;	break;			Case 89: A = B2S(BlockCounter) + 49;	break;
			}
//----------------  LINE IS IN BLIND AREA
						if 	(
							((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	&&	(Line >= 21) && (Line <= 38))	||	// R
							((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	&&	(Line >= 41) && (Line <= 58))	||	// D
							((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	&&	(Line >= 61) && (Line <= 78))	||	// L
							((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	&&	(Line >= 81) && (Line <= 98))		// U
							)

							A = ImpossibleNum;
			break;

	Case ToDOWN:

	Switch(Line)
			{
			Case  0: A = BlockCounter;				break;			//BASIC INSIDE
			Case 99: A = B2S(BlockCounter) +  0;	break;			//BASIC BORDER

	//Right Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 21: A = B2S(BlockCounter) + 41;	break;										Case 22: A = B2S(BlockCounter) + 42;	break;										Case 23: A = B2S(BlockCounter) + 43;	break;
			Case 24: A = B2S(BlockCounter) + 44;	break;										Case 25: A = B2S(BlockCounter) + 45;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 26: A = B2S(BlockCounter) + 46;	break;										Case 27: A = B2S(BlockCounter) + 47;	break;										Case 28: A = B2S(BlockCounter) + 48;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 31: A = B2S(BlockCounter) + 51;	break;										Case 32: A = B2S(BlockCounter) + 52;	break;										Case 33: A = B2S(BlockCounter) + 53;	break;
			Case 34: A = B2S(BlockCounter) + 54;	break;										Case 35: A = B2S(BlockCounter) + 55;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 36: A = B2S(BlockCounter) + 56;	break;										Case 37: A = B2S(BlockCounter) + 57;	break;										Case 38: A = B2S(BlockCounter) + 58;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 20: A = B2S(BlockCounter) + 40;	break;										Case 30: A = B2S(BlockCounter) + 50;	break;										Case 29: A = B2S(BlockCounter) + 49;	break;

	//Down Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 41: A = B2S(BlockCounter) - 62;	break;										Case 42: A = B2S(BlockCounter) - 63;	break;										Case 43: A = B2S(BlockCounter) - 64;	break;
			Case 44: A = B2S(BlockCounter) - 65;	break;										Case 45: A = B2S(BlockCounter) - 66;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 46: A = B2S(BlockCounter) - 67;	break;										Case 47: A = B2S(BlockCounter) - 68;	break;										Case 48: A = B2S(BlockCounter) - 69;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 51: A = B2S(BlockCounter) - 72;	break;										Case 52: A = B2S(BlockCounter) - 73;	break;										Case 53: A = B2S(BlockCounter) - 74;	break;
			Case 54: A = B2S(BlockCounter) - 75;	break;										Case 55: A = B2S(BlockCounter) - 76;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 56: A = B2S(BlockCounter) - 77;	break;										Case 57: A = B2S(BlockCounter) - 78;	break;										Case 58: A = B2S(BlockCounter) - 79;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 40: A = B2S(BlockCounter) - 70;	break;										Case 50: A = B2S(BlockCounter) - 80;	break;										Case 49: A = B2S(BlockCounter) - 71;	break;

	//Left Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 61: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 58;	break;			Case 62: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 57;	break;			Case 63: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 56;	break;
			Case 64: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 55;	break;			Case 65: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 54;	break;			//   < - - -  E N T R A N C E   T A G S   ---
			Case 66: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 53;	break;			Case 67: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 52;	break;			Case 68: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 51;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 71: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 48;	break;			Case 72: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 47;	break;			Case 73: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 46;	break;
			Case 74: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 45;	break;			Case 75: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 44;	break;			//   < - - -  E N T R A N C E   T A G S   ---
			Case 76: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 43;	break;			Case 77: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 42;	break;			Case 78: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 41;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 60: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 50;	break;			Case 70: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 40;	break;			Case 69: A = B2S(BlockCounter) + 49;	break;

	//Up Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 81: A = B2S(BlockCounter) + 21;	break;										Case 82: A = B2S(BlockCounter) + 22;	break;										Case 83: A = B2S(BlockCounter) + 23;	break;
			Case 84: A = B2S(BlockCounter) + 24;	break;										Case 85: A = B2S(BlockCounter) + 25;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 86: A = B2S(BlockCounter) + 26;	break;										Case 87: A = B2S(BlockCounter) + 27;	break;										Case 88: A = B2S(BlockCounter) + 28;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 91: A = B2S(BlockCounter) + 31;	break;										Case 92: A = B2S(BlockCounter) + 32;	break;										Case 93: A = B2S(BlockCounter) + 33;	break;
			Case 94: A = B2S(BlockCounter) + 34;	break;										Case 95: A = B2S(BlockCounter) + 35;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 96: A = B2S(BlockCounter) + 36;	break;										Case 97: A = B2S(BlockCounter) + 37;	break;										Case 98: A = B2S(BlockCounter) + 38;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 80: A = B2S(BlockCounter) + 20;	break;										Case 90: A = B2S(BlockCounter) + 30;	break;										Case 89: A = B2S(BlockCounter) + 29;	break;

			}
//----------------  LINE IS IN BLIND AREA
						if 	(
							((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	&&	(Line >= 21) && (Line <= 38))	||	// R
							((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	&&	(Line >= 41) && (Line <= 58))	||	// D
							((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	&&	(Line >= 61) && (Line <= 78))	||	// L
							((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	&&	(Line >= 81) && (Line <= 98))		// U
							)

							A = ImpossibleNum;
			break;

	Case ToLEFT:

	Switch(Line)
			{
			Case  0: A = BlockCounter;				break;			//BASIC INSIDE
			Case 99: A = B2S(BlockCounter) +  0;	break;			//BASIC BORDER


	//Right Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 21: A = B2S(BlockCounter) - 62;	break;										Case 22: A = B2S(BlockCounter) - 63;	break;										Case 23: A = B2S(BlockCounter) - 64;	break;
			Case 24: A = B2S(BlockCounter) - 65;	break;										Case 25: A = B2S(BlockCounter) - 66;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 26: A = B2S(BlockCounter) - 67;	break;										Case 27: A = B2S(BlockCounter) - 68;	break;										Case 28: A = B2S(BlockCounter) - 69;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 31: A = B2S(BlockCounter) - 72;	break;										Case 32: A = B2S(BlockCounter) - 73;	break;										Case 33: A = B2S(BlockCounter) - 74;	break;
			Case 34: A = B2S(BlockCounter) - 75;	break;										Case 35: A = B2S(BlockCounter) - 76;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 36: A = B2S(BlockCounter) - 77;	break;										Case 37: A = B2S(BlockCounter) - 78;	break;										Case 38: A = B2S(BlockCounter) - 79;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 20: A = B2S(BlockCounter) - 70;	break;										Case 30: A = B2S(BlockCounter) - 80;	break;										Case 29: A = B2S(BlockCounter) - 71;	break;

	//Down Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 41: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 58;	break;			Case 42: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 57;	break;			Case 43: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 56;	break;
			Case 44: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 55;	break;			Case 45: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 54;	break;			//   < - - -  E N T R A N C E   T A G S   ---
			Case 46: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 53;	break;			Case 47: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 52;	break;			Case 48: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 51;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 51: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 48;	break;			Case 52: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 47;	break;			Case 53: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 46;	break;
			Case 54: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 45;	break;			Case 55: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 44;	break;			//   < - - -  E N T R A N C E   T A G S   ---
			Case 56: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 43;	break;			Case 57: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 42;	break;			Case 58: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 41;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 40: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 50;	break;			Case 50: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 40;	break;			Case 49: A = B2S(BlockCounter) + 49;	break;

	//Left Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 61: A = B2S(BlockCounter) + 21;	break;										Case 62: A = B2S(BlockCounter) + 22;	break;										Case 63: A = B2S(BlockCounter) + 23;	break;
			Case 64: A = B2S(BlockCounter) + 24;	break;										Case 65: A = B2S(BlockCounter) + 25;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 66: A = B2S(BlockCounter) + 26;	break;										Case 67: A = B2S(BlockCounter) + 27;	break;										Case 68: A = B2S(BlockCounter) + 28;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 71: A = B2S(BlockCounter) + 31;	break;										Case 72: A = B2S(BlockCounter) + 32;	break;										Case 73: A = B2S(BlockCounter) + 33;	break;
			Case 74: A = B2S(BlockCounter) + 34;	break;										Case 75: A = B2S(BlockCounter) + 35;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 76: A = B2S(BlockCounter) + 36;	break;										Case 77: A = B2S(BlockCounter) + 37;	break;										Case 78: A = B2S(BlockCounter) + 38;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 60: A = B2S(BlockCounter) + 20;	break;										Case 70: A = B2S(BlockCounter) + 30;	break;										Case 69: A = B2S(BlockCounter) + 29;	break;

	//Up Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 81: A = B2S(BlockCounter) + 41;	break;										Case 82: A = B2S(BlockCounter) + 42;	break;										Case 83: A = B2S(BlockCounter) + 43;	break;
			Case 84: A = B2S(BlockCounter) + 44;	break;										Case 85: A = B2S(BlockCounter) + 45;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 86: A = B2S(BlockCounter) + 46;	break;										Case 87: A = B2S(BlockCounter) + 47;	break;										Case 88: A = B2S(BlockCounter) + 48;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 91: A = B2S(BlockCounter) + 51;	break;										Case 92: A = B2S(BlockCounter) + 52;	break;										Case 93: A = B2S(BlockCounter) + 53;	break;
			Case 94: A = B2S(BlockCounter) + 54;	break;										Case 95: A = B2S(BlockCounter) + 55;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 96: A = B2S(BlockCounter) + 56;	break;										Case 97: A = B2S(BlockCounter) + 57;	break;										Case 98: A = B2S(BlockCounter) + 58;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 80: A = B2S(BlockCounter) + 40;	break;										Case 90: A = B2S(BlockCounter) + 50;	break;										Case 89: A = B2S(BlockCounter) + 49;	break;
			}
//----------------  LINE IS IN BLIND AREA
						if 	(
							((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	&&	(Line >= 21) && (Line <= 38))	||	// R
							((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	&&	(Line >= 41) && (Line <= 58))	||	// D
							((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	&&	(Line >= 61) && (Line <= 78))	||	// L
							((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	&&	(Line >= 81) && (Line <= 98))		// U
							)

							A = ImpossibleNum;
			break;

	Case ToUP:

	Switch(Line)
			{
			Case  0: A = BlockCounter;				break;			//BASIC INSIDE
			Case 99: A = B2S(BlockCounter) +  0;	break;			//BASIC BORDER



	//Right Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 21: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 58;	break;			Case 22: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 57;	break;			Case 23: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 56;	break;
			Case 24: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 55;	break;			Case 25: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 54;	break;			//   < - - -  E N T R A N C E   T A G S   ---
			Case 26: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 53;	break;			Case 27: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 52;	break;			Case 28: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 51;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 31: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 48;	break;			Case 32: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 47;	break;			Case 33: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 46;	break;
			Case 34: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 45;	break;			Case 35: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 44;	break;			//   < - - -  E N T R A N C E   T A G S   ---
			Case 36: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 43;	break;			Case 37: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 42;	break;			Case 38: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 41;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 20: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 50;	break;			Case 30: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 40;	break;			Case 29: A = B2S(BlockCounter) + 49;	break;

	//Down Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 41: A = B2S(BlockCounter) + 21;	break;										Case 42: A = B2S(BlockCounter) + 22;	break;										Case 43: A = B2S(BlockCounter) + 23;	break;
			Case 44: A = B2S(BlockCounter) + 24;	break;										Case 45: A = B2S(BlockCounter) + 25;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 46: A = B2S(BlockCounter) + 26;	break;										Case 47: A = B2S(BlockCounter) + 27;	break;										Case 48: A = B2S(BlockCounter) + 28;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 51: A = B2S(BlockCounter) + 31;	break;										Case 52: A = B2S(BlockCounter) + 32;	break;										Case 53: A = B2S(BlockCounter) + 33;	break;
			Case 54: A = B2S(BlockCounter) + 34;	break;										Case 55: A = B2S(BlockCounter) + 35;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 56: A = B2S(BlockCounter) + 36;	break;										Case 57: A = B2S(BlockCounter) + 37;	break;										Case 58: A = B2S(BlockCounter) + 38;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 40: A = B2S(BlockCounter) + 20;	break;										Case 50: A = B2S(BlockCounter) + 30;	break;										Case 49: A = B2S(BlockCounter) + 29;	break;

	//Left Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 61: A = B2S(BlockCounter) + 41;	break;										Case 62: A = B2S(BlockCounter) + 42;	break;										Case 63: A = B2S(BlockCounter) + 43;	break;
			Case 64: A = B2S(BlockCounter) + 44;	break;										Case 65: A = B2S(BlockCounter) + 45;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 66: A = B2S(BlockCounter) + 46;	break;										Case 67: A = B2S(BlockCounter) + 47;	break;										Case 68: A = B2S(BlockCounter) + 48;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 71: A = B2S(BlockCounter) + 51;	break;										Case 72: A = B2S(BlockCounter) + 52;	break;										Case 73: A = B2S(BlockCounter) + 53;	break;
			Case 74: A = B2S(BlockCounter) + 54;	break;										Case 75: A = B2S(BlockCounter) + 55;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 76: A = B2S(BlockCounter) + 56;	break;										Case 77: A = B2S(BlockCounter) + 57;	break;										Case 78: A = B2S(BlockCounter) + 58;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 60: A = B2S(BlockCounter) + 40;	break;										Case 70: A = B2S(BlockCounter) + 50;	break;										Case 69: A = B2S(BlockCounter) + 49;	break;

	//Up Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 81: A = B2S(BlockCounter) - 62;	break;										Case 82: A = B2S(BlockCounter) - 63;	break;										Case 83: A = B2S(BlockCounter) - 64;	break;
			Case 84: A = B2S(BlockCounter) - 65;	break;										Case 85: A = B2S(BlockCounter) - 66;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 86: A = B2S(BlockCounter) - 67;	break;										Case 87: A = B2S(BlockCounter) - 68;	break;										Case 88: A = B2S(BlockCounter) - 69;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 91: A = B2S(BlockCounter) - 72;	break;										Case 92: A = B2S(BlockCounter) - 73;	break;										Case 93: A = B2S(BlockCounter) - 74;	break;
			Case 94: A = B2S(BlockCounter) - 75;	break;										Case 95: A = B2S(BlockCounter) - 76;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 96: A = B2S(BlockCounter) - 77;	break;										Case 97: A = B2S(BlockCounter) - 78;	break;										Case 98: A = B2S(BlockCounter) - 79;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 80: A = B2S(BlockCounter) - 70;	break;										Case 90: A = B2S(BlockCounter) - 80;	break;										Case 89: A = B2S(BlockCounter) - 71;	break;
			}
//----------------  LINE IS IN BLIND AREA
						if 	(
							((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	&&	(Line >= 21) && (Line <= 38))	||	// R
							((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	&&	(Line >= 41) && (Line <= 58))	||	// D
							((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	&&	(Line >= 61) && (Line <= 78))	||	// L
							((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	&&	(Line >= 81) && (Line <= 98))		// U
							)

							A = ImpossibleNum;
			break;
	}
Result = A;
return Result;
}














function int TagAt (int BlockCounter, int Direction, int Tag)		//BlockCounter is only needed to check if its the edge of the map
{
int Result;
int A;



Switch(Direction)
	{
	Case ToRIGHT:

	Switch(Tag)
			{
			Case  0: A = B2S(BlockCounter) +  0;	break;														Case  1: A = B2S(BlockCounter) +  1;	break;														Case  2: A = B2S(BlockCounter) +  2;	break;														Case  3: A = B2S(BlockCounter) +  3;	break;
			Case  4: A = B2S(BlockCounter) +  4;	break;														Case  5: A = B2S(BlockCounter) +  5;	break;														Case  6: A = B2S(BlockCounter) +  6;	break;														Case  7: A = B2S(BlockCounter) +  7;	break;
			Case  8: A = B2S(BlockCounter) +  8;	break;														Case  9: A = B2S(BlockCounter) +  9;	break;														Case 10: A = B2S(BlockCounter) + 10;	break;														Case 11: A = B2S(BlockCounter) + 11;	break;
			Case 12: A = B2S(BlockCounter) + 12;	break;														Case 13: A = B2S(BlockCounter) + 13;	break;														Case 14: A = B2S(BlockCounter) + 14;	break;														Case 15: A = B2S(BlockCounter) + 15;	break;
			Case 16: A = B2S(BlockCounter) + 16;	break;														Case 17: A = B2S(BlockCounter) + 17;	break;														Case 18: A = B2S(BlockCounter) + 18;	break;														Case 19: A = B2S(BlockCounter) + 19;	break;
			Case 20: A = B2S(BlockCounter) + 20;	break;														Case 21: A = B2S(BlockCounter) + 21;	break;														Case 22: A = B2S(BlockCounter) + 22;	break;														Case 23: A = B2S(BlockCounter) + 23;	break;
			Case 24: A = B2S(BlockCounter) + 24;	break;														Case 25: A = B2S(BlockCounter) + 25;	break;														Case 26: A = B2S(BlockCounter) + 26;	break;														Case 27: A = B2S(BlockCounter) + 27;	break;
			Case 28: A = B2S(BlockCounter) + 28;	break;														Case 29: A = B2S(BlockCounter) + 29;	break;														Case 30: A = B2S(BlockCounter) + 30;	break;														Case 31: A = B2S(BlockCounter) + 31;	break;
			Case 32: A = B2S(BlockCounter) + 32;	break;														Case 33: A = B2S(BlockCounter) + 33;	break;														Case 34: A = B2S(BlockCounter) + 34;	break;														Case 35: A = B2S(BlockCounter) + 35;	break;
			Case 36: A = B2S(BlockCounter) + 36;	break;														Case 37: A = B2S(BlockCounter) + 37;	break;														Case 38: A = B2S(BlockCounter) + 38;	break;														Case 39: A = B2S(BlockCounter) + 39;	break;
			Case 40: A = B2S(BlockCounter) + 40;	break;														Case 41: A = B2S(BlockCounter) + 41;	break;														Case 42: A = B2S(BlockCounter) + 42;	break;														Case 43: A = B2S(BlockCounter) + 43;	break;
			Case 44: A = B2S(BlockCounter) + 44;	break;														Case 45: A = B2S(BlockCounter) + 45;	break;														Case 46: A = B2S(BlockCounter) + 46;	break;														Case 47: A = B2S(BlockCounter) + 47;	break;
			Case 48: A = B2S(BlockCounter) + 48;	break;														Case 49: A = B2S(BlockCounter) + 49;	break;														Case 50: A = B2S(BlockCounter) + 50;	break;														Case 51: A = B2S(BlockCounter) + 51;	break;
			Case 52: A = B2S(BlockCounter) + 52;	break;														Case 53: A = B2S(BlockCounter) + 53;	break;														Case 54: A = B2S(BlockCounter) + 54;	break;														Case 55: A = B2S(BlockCounter) + 55;	break;
			Case 56: A = B2S(BlockCounter) + 56;	break;														Case 57: A = B2S(BlockCounter) + 57;	break;														Case 58: A = B2S(BlockCounter) + 58;	break;														Case 59: A = B2S(BlockCounter) + 59;	break;
			Case 60: A = B2S(BlockCounter) + 60;	break;														Case 61: A = B2S(BlockCounter) + 61;	break;														Case 62: A = B2S(BlockCounter) + 62;	break;														Case 63: A = B2S(BlockCounter) + 63;	break;
//----R-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 64: A = B2S(BlockCounter) + 64;	break;														Case 65: A = B2S(BlockCounter) + 65;	break;														Case 66: A = B2S(BlockCounter) + 66;	break;
			Case 67: A = B2S(BlockCounter) + 67;	break;														Case 68: A = B2S(BlockCounter) + 68;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 69: A = B2S(BlockCounter) + 69;	break;														Case 70: A = B2S(BlockCounter) + 70;	break;														Case 71: A = B2S(BlockCounter) + 71;	break;
//----D-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 73: A = B2S(BlockCounter) + 73;	break;														Case 74: A = B2S(BlockCounter) + 74;	break;														Case 75: A = B2S(BlockCounter) + 75;	break;
			Case 76: A = B2S(BlockCounter) + 76;	break;														Case 77: A = B2S(BlockCounter) + 77;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 78: A = B2S(BlockCounter) + 78;	break;														Case 79: A = B2S(BlockCounter) + 79;	break;														Case 80: A = B2S(BlockCounter) + 80;	break;
//----L-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 82: A = B2S(BlockCounter) - 29;	break;														Case 83: A = B2S(BlockCounter) - 30;	break;														Case 84: A = B2S(BlockCounter) - 31;	break;
			Case 85: A = B2S(BlockCounter) - 32;	break;														Case 86: A = B2S(BlockCounter) - 33;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 87: A = B2S(BlockCounter) - 34;	break;														Case 88: A = B2S(BlockCounter) - 35;	break;														Case 89: A = B2S(BlockCounter) - 36;	break;
//----U-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 91: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 80;	break;							Case 92: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 79;	break;							Case 93: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 78;	break;
			Case 94: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 77;	break;							Case 95: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 76;	break;							//   < - - -  E N T R A N C E   T A G S   -----------
			Case 96: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 75;	break;							Case 97: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 74;	break;							Case 98: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 73;	break;
//--Cross1----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 72: if ((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToDOWN, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) + 72;
			break;
//--Cross2----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 81: if ((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToLEFT, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - 28;
			break;
//--Cross3----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 90: if ((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) - 28;	break;
			break;
//--Cross4----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 99: if ((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 72;	break;
			break;
			}
//----------------  TAG IS IN BLIND AREA
					if 	((Tag != 72) && (Tag !=	81) && (Tag != 90) && (Tag != 99))
						if 	(
						//((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	&&	(Tag >= 64) && (Tag < 72))	||	// R
						//((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	&&	(Tag >= 73) && (Tag < 81)) 	||	// D
						((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	&&	(Tag >= 82) && (Tag < 90))	||	// L
						((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	&&	(Tag >= 91) && (Tag < 99))		// U
							)

					A = ImpossibleNum;

			break;


	Case ToDOWN:
	Switch(Tag)
			{
			Case  0: A = B2S(BlockCounter) +  7;	break;														Case  1: A = B2S(BlockCounter) + 15;	break;														Case  2: A = B2S(BlockCounter) + 23;	break;														Case  3: A = B2S(BlockCounter) + 31;	break;
			Case  4: A = B2S(BlockCounter) + 39;	break;														Case  5: A = B2S(BlockCounter) + 47;	break;														Case  6: A = B2S(BlockCounter) + 55;	break;														Case  7: A = B2S(BlockCounter) + 63;	break;
			Case  8: A = B2S(BlockCounter) +  6;	break;														Case  9: A = B2S(BlockCounter) + 14;	break;														Case 10: A = B2S(BlockCounter) + 22;	break;														Case 11: A = B2S(BlockCounter) + 30;	break;
			Case 12: A = B2S(BlockCounter) + 38;	break;														Case 13: A = B2S(BlockCounter) + 46;	break;														Case 14: A = B2S(BlockCounter) + 54;	break;														Case 15: A = B2S(BlockCounter) + 62;	break;
			Case 16: A = B2S(BlockCounter) +  5;	break;														Case 17: A = B2S(BlockCounter) + 13;	break;														Case 18: A = B2S(BlockCounter) + 21;	break;														Case 19: A = B2S(BlockCounter) + 29;	break;
			Case 20: A = B2S(BlockCounter) + 37;	break;														Case 21: A = B2S(BlockCounter) + 45;	break;														Case 22: A = B2S(BlockCounter) + 53;	break;														Case 23: A = B2S(BlockCounter) + 61;	break;
			Case 24: A = B2S(BlockCounter) +  4;	break;														Case 25: A = B2S(BlockCounter) + 12;	break;														Case 26: A = B2S(BlockCounter) + 20;	break;														Case 27: A = B2S(BlockCounter) + 28;	break;
			Case 28: A = B2S(BlockCounter) + 36;	break;														Case 29: A = B2S(BlockCounter) + 44;	break;														Case 30: A = B2S(BlockCounter) + 52;	break;														Case 31: A = B2S(BlockCounter) + 60;	break;
			Case 32: A = B2S(BlockCounter) +  3;	break;														Case 33: A = B2S(BlockCounter) + 11;	break;														Case 34: A = B2S(BlockCounter) + 19;	break;														Case 35: A = B2S(BlockCounter) + 27;	break;
			Case 36: A = B2S(BlockCounter) + 35;	break;														Case 37: A = B2S(BlockCounter) + 43;	break;														Case 38: A = B2S(BlockCounter) + 51;	break;														Case 39: A = B2S(BlockCounter) + 59;	break;
			Case 40: A = B2S(BlockCounter) +  2;	break;														Case 41: A = B2S(BlockCounter) + 10;	break;														Case 42: A = B2S(BlockCounter) + 18;	break;														Case 43: A = B2S(BlockCounter) + 26;	break;
			Case 44: A = B2S(BlockCounter) + 34;	break;														Case 45: A = B2S(BlockCounter) + 42;	break;														Case 46: A = B2S(BlockCounter) + 50;	break;														Case 47: A = B2S(BlockCounter) + 58;	break;
			Case 48: A = B2S(BlockCounter) +  1;	break;														Case 49: A = B2S(BlockCounter) +  9;	break;														Case 50: A = B2S(BlockCounter) + 17;	break;														Case 51: A = B2S(BlockCounter) + 25;	break;
			Case 52: A = B2S(BlockCounter) + 33;	break;														Case 53: A = B2S(BlockCounter) + 41;	break;														Case 54: A = B2S(BlockCounter) + 49;	break;														Case 55: A = B2S(BlockCounter) + 57;	break;
			Case 56: A = B2S(BlockCounter) +  0;	break;														Case 57: A = B2S(BlockCounter) +  8;	break;														Case 58: A = B2S(BlockCounter) + 16;	break;														Case 59: A = B2S(BlockCounter) + 24;	break;
			Case 60: A = B2S(BlockCounter) + 32;	break;														Case 61: A = B2S(BlockCounter) + 40;	break;														Case 62: A = B2S(BlockCounter) + 48;	break;														Case 63: A = B2S(BlockCounter) + 56;	break;
//----R-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 64: A = B2S(BlockCounter) + 73;	break;														Case 65: A = B2S(BlockCounter) + 74;	break;														Case 66: A = B2S(BlockCounter) + 75;	break;
			Case 67: A = B2S(BlockCounter) + 76;	break;														Case 68: A = B2S(BlockCounter) + 77;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 69: A = B2S(BlockCounter) + 78;	break;														Case 70: A = B2S(BlockCounter) + 79;	break;														Case 71: A = B2S(BlockCounter) + 80;	break;
//----D-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 73: A = B2S(BlockCounter) - 29;	break;														Case 74: A = B2S(BlockCounter) - 30;	break;														Case 75: A = B2S(BlockCounter) - 31;	break;
			Case 76: A = B2S(BlockCounter) - 32;	break;														Case 77: A = B2S(BlockCounter) - 33;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 78: A = B2S(BlockCounter) - 34;	break;														Case 79: A = B2S(BlockCounter) - 35;	break;														Case 80: A = B2S(BlockCounter) - 36;	break;
//----L-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 82: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 80;	break;							Case 83: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 79;	break;							Case 84: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 78;	break;
			Case 85: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 77;	break;							Case 86: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 76;	break;							//   < - - -  E N T R A N C E   T A G S   -----------
			Case 87: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 75;	break;							Case 88: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 74;	break;							Case 89: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 73;	break;
//----U-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 91: A = B2S(BlockCounter) + 64;	break;														Case 92: A = B2S(BlockCounter) + 65;	break;														Case 93: A = B2S(BlockCounter) + 66;	break;
			Case 94: A = B2S(BlockCounter) + 67;	break;														Case 95: A = B2S(BlockCounter) + 68;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 96: A = B2S(BlockCounter) + 69;	break;														Case 97: A = B2S(BlockCounter) + 70;	break;														Case 98: A = B2S(BlockCounter) + 71;	break;
//--Cross1----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 72: if ((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToLEFT, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - 28;
			break;
//--Cross2----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 81: if ((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) - 28;	break;
			break;
//--Cross3----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 90: if ((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 72;	break;
			break;
//--Cross4----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 99: if ((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToDOWN, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) + 72;
			break;
			}
//----------------  TAG IS IN BLIND AREA
					if 	((Tag != 72) && (Tag !=	81) && (Tag != 90) && (Tag != 99))
						if 	(
						//((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	&&	(Tag >= 64) && (Tag < 72))	||	// R
						((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	&&	(Tag >= 73) && (Tag < 81)) 	||	// D
						((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	&&	(Tag >= 82) && (Tag < 90))	//||	// L
						//((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	&&	(Tag >= 91) && (Tag < 99))		// U
							)

					A = ImpossibleNum;

			break;


	Case ToLEFT:
	Switch(Tag)
			{
			Case  0: A = B2S(BlockCounter) + 63;	break;														Case  1: A = B2S(BlockCounter) + 62;	break;														Case  2: A = B2S(BlockCounter) + 61;	break;														Case  3: A = B2S(BlockCounter) + 60;	break;
			Case  4: A = B2S(BlockCounter) + 59;	break;														Case  5: A = B2S(BlockCounter) + 58;	break;														Case  6: A = B2S(BlockCounter) + 57;	break;														Case  7: A = B2S(BlockCounter) + 56;	break;
			Case  8: A = B2S(BlockCounter) + 55;	break;														Case  9: A = B2S(BlockCounter) + 54;	break;														Case 10: A = B2S(BlockCounter) + 53;	break;														Case 11: A = B2S(BlockCounter) + 52;	break;
			Case 12: A = B2S(BlockCounter) + 51;	break;														Case 13: A = B2S(BlockCounter) + 50;	break;														Case 14: A = B2S(BlockCounter) + 49;	break;														Case 15: A = B2S(BlockCounter) + 48;	break;
			Case 16: A = B2S(BlockCounter) + 47;	break;														Case 17: A = B2S(BlockCounter) + 46;	break;														Case 18: A = B2S(BlockCounter) + 45;	break;														Case 19: A = B2S(BlockCounter) + 44;	break;
			Case 20: A = B2S(BlockCounter) + 43;	break;														Case 21: A = B2S(BlockCounter) + 42;	break;														Case 22: A = B2S(BlockCounter) + 41;	break;														Case 23: A = B2S(BlockCounter) + 40;	break;
			Case 24: A = B2S(BlockCounter) + 39;	break;														Case 25: A = B2S(BlockCounter) + 38;	break;														Case 26: A = B2S(BlockCounter) + 37;	break;														Case 27: A = B2S(BlockCounter) + 36;	break;
			Case 28: A = B2S(BlockCounter) + 35;	break;														Case 29: A = B2S(BlockCounter) + 34;	break;														Case 30: A = B2S(BlockCounter) + 33;	break;														Case 31: A = B2S(BlockCounter) + 32;	break;
			Case 32: A = B2S(BlockCounter) + 31;	break;														Case 33: A = B2S(BlockCounter) + 30;	break;														Case 34: A = B2S(BlockCounter) + 29;	break;														Case 35: A = B2S(BlockCounter) + 28;	break;
			Case 36: A = B2S(BlockCounter) + 27;	break;														Case 37: A = B2S(BlockCounter) + 26;	break;														Case 38: A = B2S(BlockCounter) + 25;	break;														Case 39: A = B2S(BlockCounter) + 24;	break;
			Case 40: A = B2S(BlockCounter) + 23;	break;														Case 41: A = B2S(BlockCounter) + 22;	break;														Case 42: A = B2S(BlockCounter) + 21;	break;														Case 43: A = B2S(BlockCounter) + 20;	break;
			Case 44: A = B2S(BlockCounter) + 19;	break;														Case 45: A = B2S(BlockCounter) + 18;	break;														Case 46: A = B2S(BlockCounter) + 17;	break;														Case 47: A = B2S(BlockCounter) + 16;	break;
			Case 48: A = B2S(BlockCounter) + 15;	break;														Case 49: A = B2S(BlockCounter) + 14;	break;														Case 50: A = B2S(BlockCounter) + 13;	break;														Case 51: A = B2S(BlockCounter) + 12;	break;
			Case 52: A = B2S(BlockCounter) + 11;	break;														Case 53: A = B2S(BlockCounter) + 10;	break;														Case 54: A = B2S(BlockCounter) +  9;	break;														Case 55: A = B2S(BlockCounter) +  8;	break;
			Case 56: A = B2S(BlockCounter) +  7;	break;														Case 57: A = B2S(BlockCounter) +  6;	break;														Case 58: A = B2S(BlockCounter) +  5;	break;														Case 59: A = B2S(BlockCounter) +  4;	break;
			Case 60: A = B2S(BlockCounter) +  3;	break;														Case 61: A = B2S(BlockCounter) +  2;	break;														Case 62: A = B2S(BlockCounter) +  1;	break;														Case 63: A = B2S(BlockCounter) +  0;	break;
//----R-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 64: A = B2S(BlockCounter) - 29;	break;														Case 65: A = B2S(BlockCounter) - 30;	break;														Case 66: A = B2S(BlockCounter) - 31;	break;
			Case 67: A = B2S(BlockCounter) - 32;	break;														Case 68: A = B2S(BlockCounter) - 33;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 69: A = B2S(BlockCounter) - 34;	break;														Case 70: A = B2S(BlockCounter) - 35;	break;														Case 71: A = B2S(BlockCounter) - 36;	break;
//----D-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 73: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 80;	break;							Case 74: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 79;	break;							Case 75: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 78;	break;
			Case 76: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 77;	break;							Case 77: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 76;	break;							//   < - - -  E N T R A N C E   T A G S   -----------
			Case 78: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 75;	break;							Case 79: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 74;	break;							Case 80: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 73;	break;
//----L-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 82: A = B2S(BlockCounter) + 64;	break;														Case 83: A = B2S(BlockCounter) + 65;	break;														Case 84: A = B2S(BlockCounter) + 66;	break;
			Case 85: A = B2S(BlockCounter) + 67;	break;														Case 86: A = B2S(BlockCounter) + 68;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 87: A = B2S(BlockCounter) + 69;	break;														Case 88: A = B2S(BlockCounter) + 70;	break;														Case 89: A = B2S(BlockCounter) + 71;	break;
//----U-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 91: A = B2S(BlockCounter) + 73;	break;														Case 92: A = B2S(BlockCounter) + 74;	break;														Case 93: A = B2S(BlockCounter) + 75;	break;
			Case 94: A = B2S(BlockCounter) + 76;	break;														Case 95: A = B2S(BlockCounter) + 77;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 96: A = B2S(BlockCounter) + 78;	break;														Case 97: A = B2S(BlockCounter) + 79;	break;														Case 98: A = B2S(BlockCounter) + 80;	break;
//--Cross1----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 72: if ((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) - 28;	break;
			break;
//--Cross2----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 81: if ((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 72;	break;
			break;
//--Cross3----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 90: if ((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToDOWN, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) + 72;
			break;
//--Cross4----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 99: if ((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToLEFT, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - 28;
			break;
			}
//----------------  TAG IS IN BLIND AREA
					if 	((Tag != 72) && (Tag !=	81) && (Tag != 90) && (Tag != 99))
						if 	(
						((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	&&	(Tag >= 64) && (Tag < 72))	||	// R
						((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	&&	(Tag >= 73) && (Tag < 81)) //	||	// D
						//((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	&&	(Tag >= 82) && (Tag < 90))	||	// L
						//((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	&&	(Tag >= 91) && (Tag < 99))		// U
							)

					A = ImpossibleNum;

			break;



	Case ToUP:
	Switch(Tag)
			{
			Case  0: A = B2S(BlockCounter) + 56;	break;														Case  1: A = B2S(BlockCounter) + 48;	break;														Case  2: A = B2S(BlockCounter) + 40;	break;														Case  3: A = B2S(BlockCounter) + 32;	break;
			Case  4: A = B2S(BlockCounter) + 24;	break;														Case  5: A = B2S(BlockCounter) + 16;	break;														Case  6: A = B2S(BlockCounter) +  8;	break;														Case  7: A = B2S(BlockCounter) +  0;	break;
			Case  8: A = B2S(BlockCounter) + 57;	break;														Case  9: A = B2S(BlockCounter) + 49;	break;														Case 10: A = B2S(BlockCounter) + 41;	break;														Case 11: A = B2S(BlockCounter) + 33;	break;
			Case 12: A = B2S(BlockCounter) + 25;	break;														Case 13: A = B2S(BlockCounter) + 17;	break;														Case 14: A = B2S(BlockCounter) +  9;	break;														Case 15: A = B2S(BlockCounter) +  1;	break;
			Case 16: A = B2S(BlockCounter) + 58;	break;														Case 17: A = B2S(BlockCounter) + 50;	break;														Case 18: A = B2S(BlockCounter) + 42;	break;														Case 19: A = B2S(BlockCounter) + 34;	break;
			Case 20: A = B2S(BlockCounter) + 26;	break;														Case 21: A = B2S(BlockCounter) + 18;	break;														Case 22: A = B2S(BlockCounter) + 10;	break;														Case 23: A = B2S(BlockCounter) +  2;	break;
			Case 24: A = B2S(BlockCounter) + 59;	break;														Case 25: A = B2S(BlockCounter) + 51;	break;														Case 26: A = B2S(BlockCounter) + 43;	break;														Case 27: A = B2S(BlockCounter) + 35;	break;
			Case 28: A = B2S(BlockCounter) + 27;	break;														Case 29: A = B2S(BlockCounter) + 19;	break;														Case 30: A = B2S(BlockCounter) + 11;	break;														Case 31: A = B2S(BlockCounter) +  3;	break;
			Case 32: A = B2S(BlockCounter) + 60;	break;														Case 33: A = B2S(BlockCounter) + 52;	break;														Case 34: A = B2S(BlockCounter) + 44;	break;														Case 35: A = B2S(BlockCounter) + 36;	break;
			Case 36: A = B2S(BlockCounter) + 28;	break;														Case 37: A = B2S(BlockCounter) + 20;	break;														Case 38: A = B2S(BlockCounter) + 12;	break;														Case 39: A = B2S(BlockCounter) +  4;	break;
			Case 40: A = B2S(BlockCounter) + 61;	break;														Case 41: A = B2S(BlockCounter) + 53;	break;														Case 42: A = B2S(BlockCounter) + 45;	break;														Case 43: A = B2S(BlockCounter) + 37;	break;
			Case 44: A = B2S(BlockCounter) + 29;	break;														Case 45: A = B2S(BlockCounter) + 21;	break;														Case 46: A = B2S(BlockCounter) + 13;	break;														Case 47: A = B2S(BlockCounter) +  5;	break;
			Case 48: A = B2S(BlockCounter) + 62;	break;														Case 49: A = B2S(BlockCounter) + 54;	break;														Case 50: A = B2S(BlockCounter) + 46;	break;														Case 51: A = B2S(BlockCounter) + 38;	break;
			Case 52: A = B2S(BlockCounter) + 30;	break;														Case 53: A = B2S(BlockCounter) + 22;	break;														Case 54: A = B2S(BlockCounter) + 14;	break;														Case 55: A = B2S(BlockCounter) +  6;	break;
			Case 56: A = B2S(BlockCounter) + 63;	break;														Case 57: A = B2S(BlockCounter) + 55;	break;														Case 58: A = B2S(BlockCounter) + 47;	break;														Case 59: A = B2S(BlockCounter) + 39;	break;
			Case 60: A = B2S(BlockCounter) + 31;	break;														Case 61: A = B2S(BlockCounter) + 23;	break;														Case 62: A = B2S(BlockCounter) + 15;	break;														Case 63: A = B2S(BlockCounter) +  7;	break;

//----R-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 64: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 80;	break;							Case 65: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 79;	break;							Case 66: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 78;	break;
			Case 67: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 77;	break;							Case 68: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 76;	break;							//   < - - -  E N T R A N C E   T A G S   -----------
			Case 69: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 75;	break;							Case 70: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 74;	break;							Case 71: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 73;	break;
//----D-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 73: A = B2S(BlockCounter) + 64;	break;														Case 74: A = B2S(BlockCounter) + 65;	break;														Case 75: A = B2S(BlockCounter) + 66;	break;
			Case 76: A = B2S(BlockCounter) + 67;	break;														Case 77: A = B2S(BlockCounter) + 68;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 78: A = B2S(BlockCounter) + 69;	break;														Case 79: A = B2S(BlockCounter) + 70;	break;														Case 80: A = B2S(BlockCounter) + 71;	break;
//----L-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 82: A = B2S(BlockCounter) + 73;	break;														Case 83: A = B2S(BlockCounter) + 74;	break;														Case 84: A = B2S(BlockCounter) + 75;	break;
			Case 85: A = B2S(BlockCounter) + 76;	break;														Case 86: A = B2S(BlockCounter) + 77;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 87: A = B2S(BlockCounter) + 78;	break;														Case 88: A = B2S(BlockCounter) + 79;	break;														Case 89: A = B2S(BlockCounter) + 80;	break;
//----U-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 91: A = B2S(BlockCounter) - 29;	break;														Case 92: A = B2S(BlockCounter) - 30;	break;														Case 93: A = B2S(BlockCounter) - 31;	break;
			Case 94: A = B2S(BlockCounter) - 32;	break;														Case 95: A = B2S(BlockCounter) - 33;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 96: A = B2S(BlockCounter) - 34;	break;														Case 97: A = B2S(BlockCounter) - 35;	break;														Case 98: A = B2S(BlockCounter) - 36;	break;
//--Cross1----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 72: if ((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 72;	break;
			break;
//--Cross2----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 81: if ((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToDOWN, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) + 72;
			break;
//--Cross3----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 90: if ((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToLEFT, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - 28;
			break;
//--Cross4----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 99: if ((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) - 28;	break;
			break;
			}
//----------------  TAG IS IN BLIND AREA
					if 	((Tag != 72) && (Tag !=	81) && (Tag != 90) && (Tag != 99))
						if 	(
						((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	&&	(Tag >= 64) && (Tag < 72))	||	// R
						//((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	&&	(Tag >= 73) && (Tag < 81)) 	||	// D
						//((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	&&	(Tag >= 82) && (Tag < 90))	||	// L
						((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	&&	(Tag >= 91) && (Tag < 99))		// U
							)

					A = ImpossibleNum;

			break;
	}



Result = A;
return Result;
}




function int AssignLine (int WhichSide,  int SectorTag)		//BlockCounter is only needed to check if its the edge of the map
{

int Result, SectorTagRoot, LineTagRoot, counter, SideTag;

		if ((SectorTag >= 64) && (SectorTag < 72))
				{
				SectorTagRoot = 64;
				  LineTagRoot = 21;
													if (SectorTag == 66)	SideTag = 20;
													if (SectorTag == 67)	SideTag = 29;
													if (SectorTag == 68)	SideTag = 30;
													if (SectorTag == 69)	SideTag = 30;

				}
else 	if ((SectorTag >= 73) && (SectorTag < 81))
				{
				SectorTagRoot = 73;
				  LineTagRoot = 41;
													if (SectorTag == 75)	SideTag = 40;
													if (SectorTag == 76)	SideTag = 49;
													if (SectorTag == 77)	SideTag = 50;
													if (SectorTag == 78)	SideTag = 50;
				}
else 	if ((SectorTag >= 82) && (SectorTag < 90))
				{
				SectorTagRoot = 82;
				  LineTagRoot = 61;
													if (SectorTag == 84)	SideTag = 60;
													if (SectorTag == 85)	SideTag = 69;
													if (SectorTag == 86)	SideTag = 70;
													if (SectorTag == 87)	SideTag = 70;
				}
else 	if ((SectorTag >= 91) && (SectorTag < 99))
				{
				SectorTagRoot = 91;
				  LineTagRoot = 81;
													if (SectorTag == 93)	SideTag = 80;
													if (SectorTag == 94)	SideTag = 89;
													if (SectorTag == 95)	SideTag = 90;
													if (SectorTag == 96)	SideTag = 90;
				}






counter = SectorTag - SectorTagRoot;

Switch (WhichSide)
		{
						CASE SIDE_FRONT: 	Result = LineTagRoot + counter;			break;
						CASE SIDE_BACK: 	Result = LineTagRoot + counter + 10;	break;
						CASE SIDE_SIDEY: 	Result = SideTag;						break;
		}


return Result;

}











function int ActorAngle		(int InitialAngle, int Direction, int Type)
{
int Result;

Switch(TYPE)
	{
	CASE BYTE:
				Switch(Direction)
					{
					CASE ToRIGHT:		Result = InitialAngle;			break;
					CASE ToDOWN:		Result = InitialAngle + 192;	break;
					CASE ToLEFT:		Result = InitialAngle + 128;	break;
					CASE ToUP:			Result = InitialAngle + 64;		break;
					}
	break;

	CASE FIXED:
				Switch(Direction)
					{
					CASE ToRIGHT:		Result = InitialAngle;			break;
					CASE ToDOWN:		Result = InitialAngle + 0.75;	break;
					CASE ToLEFT:		Result = InitialAngle + 0.5;	break;
					CASE ToUP:			Result = InitialAngle + 0.25;	break;
					}
	break;
	}


return Result;
}










 //Stupid fucking zdaemon can't fucking remember the motherfucking StrParam for more than one tic (this fucking shit is so fucking annoying, they used to masterban on this port for nothing rofl)
 //so im doing it this clunky way

function str ContainerStr (int ContainerType, int Direction)
{
str Result;
Switch(ContainerType)
	{
	CASE OneBlock:
	Switch(Direction)
		{
		CASE ToRIGHT: 	Result = ">1";	break;
		CASE ToDown: 	Result = "V1";	break;
		CASE ToLEFT: 	Result = "<1";	break;
		CASE ToUP: 		Result = "^1";	break;
		}
	break;
	CASE TwoBlocks:
	Switch(Direction)
		{
		CASE ToRIGHT: 	Result = ">2";	break;
		CASE ToDown: 	Result = "V2";	break;
		CASE ToLEFT: 	Result = "<2";	break;
		CASE ToUP: 		Result = "^2";	break;
		}
	break;
	CASE ThreeBlocks:
	Switch(Direction)
		{
		CASE ToRIGHT: 	Result = ">3";	break;
		CASE ToDown: 	Result = "V3";	break;
		CASE ToLEFT: 	Result = "<3";	break;
		CASE ToUP: 		Result = "^3";	break;
		}
	break;
	CASE FourBlocks:
	Switch(Direction)
		{
		CASE ToRIGHT: 	Result = ">4";	break;
		CASE ToDown: 	Result = "V4";	break;
		CASE ToLEFT: 	Result = "<4";	break;
		CASE ToUP: 		Result = "^4";	break;
		}
	break;
	}
return Result;
}




function int GetRoundsCount (void)
{
int Result;
Switch(ServerInfo[STAGE])
	{
	CASE 0:		Result = GAMEINFO[RoundsCount];		break;

	CASE 1:		Result = 2;		break;
	CASE 2:		Result = 2;		break;
	CASE 3:		Result = 2;		break;
	CASE 4:		Result = 3;		break;
	CASE 5:		Result = 2;		break;
	CASE 6:		Result = 3;		break;
	CASE 7:		Result = 3;		break;
	CASE 8:		Result = 3;		break;
	CASE 9:		Result = 3;		break;
	CASE 10:	Result = 3;		break;
	CASE 11:	Result = 3;		break;
	CASE 12:	Result = 3;		break;
	CASE 13:	Result = 3;		break;
	CASE 14:	Result = 3;		break;
	CASE 15:	Result = 3;		break;
	CASE 16:	Result = 3;		break;
	CASE 17:	Result = 4;		break;
	CASE 18:	Result = 3;		break;
	CASE 19:	Result = 4;		break;
	CASE 20:	Result = 4;		break;
	CASE 21:	Result = 4;		break;
	CASE 22:	Result = 4;		break;
	CASE 23:	Result = 5;		break;
	CASE 24:	Result = 4;		break;
	CASE 25:	Result = 5;		break;
	}
return Result;
}





function int StrNumToInt (str Char)
{
int Result;
Switch(Char)
	{
	CASE "0": Result = 0; break;
	CASE "1": Result = 1; break;
	CASE "2": Result = 2; break;
	CASE "3": Result = 3; break;
	CASE "4": Result = 4; break;
	CASE "5": Result = 5; break;
	CASE "6": Result = 6; break;
	CASE "7": Result = 7; break;
	CASE "8": Result = 8; break;
	CASE "9": Result = 9; break;
	}



return Result;
}








function str VolumetricTextureSize (int Type, int Num)
{
str Result = "";	str Size = "";	str Vector = "";
Switch(Num)
	{
	CASE LINETAG_VolumetricA: 		Size = "SMA";		Vector = "U";	break;
	CASE LINETAG_VolumetricB: 		Size = "MED";		Vector = "U";	break;
	CASE LINETAG_VolumetricC: 		Size = "BIG";		Vector = "U";	break;
	CASE LINETAG_VolumetricD_up: 	Size = "MED";		Vector = "U";	break;
	CASE LINETAG_VolumetricD_dn: 	Size = "BIG";		Vector = "D";	break;
	}

Switch(Type)
	{
	CASE 1: Result = Size; break;
	CASE 2: Result = Vector; break;
	}

return Result;
}






function void PortalVisuals (int Turn)
{
Switch (Turn)
	{
	CASE ON:
	if(GetPort() >= Zandronum)		{ReplaceTextures("SPAW1Z0", "SPAW1N1");	ReplaceTextures("SPAW2Z0", "SPAW2N1");	ReplaceTextures("SPAW3Z0", "SPAW3N1");	ReplaceTextures("SPAW4Z0", "SPAW4N1");}
									TranslucentLine(LINETAG_VolumetricPortal, 192, TRUE);
	break;

	CASE OFF:
	if(GetPort() >= Zandronum)		{ReplaceTextures("SPAW1N1", "SPAW1Z0");	ReplaceTextures("SPAW2N1", "SPAW2Z0");	ReplaceTextures("SPAW3N1", "SPAW3Z0");	ReplaceTextures("SPAW4N1", "SPAW4Z0");}
									TranslucentLine(LINETAG_VolumetricPortal, 0, TRUE);
	break;
	}
}



function void MapPreset (int Num)
{
int i;



Switch(Num)
	{
	CASE 1:
			int counter; int counterB = RNG(0,6); int counterC = RandomNoZero(-2, 2); int counterD = RNG(128, 160);	Light_ChangeToValue(TIDRAM_SkyboxVolume, counterD);

												Sector_SetColor	(SECTORTAG_Hub, 		255, 255, 255, 255);
			for (i = 1; i <= 64;  i++)			Sector_SetColor	(SECTORTAG_Skybox + i,	255, 255, 255, 255);
			for (i = 1; i <= 64;  i++)			ChangeFloor		(SECTORTAG_Skybox + i,								StrParam(s:"SK", s:"00", s:"FL", i:i));
			for (i = 1; i <= 64;  i++)			ChangeCeiling	(SECTORTAG_Skybox + i, 								StrParam(s:"SK", s:"00", s:"CE", i:i));
			for (i = 1; i <=  4;  i++)			SetLineTexture	(SECTORTAG_Skybox + i, SIDE_FRONT, TEXTURE_MIDDLE,	StrParam(s:"SK", s:"00", s:"WA", i:i));


			PortalVisuals(OFF);



			counter = LINETAG_VolumetricA;
			while(counter <= LINETAG_VolumetricC)
				{
				SetLineTexture(counter, SIDE_FRONT, TEXTURE_MIDDLE, StrParam(s:"LIT", s:VolumetricTextureSize(1, counter), s:VolumetricTextureSize(2, counter), i:RNG(0, 6)));
				TranslucentLine(counter, RNG(32, 128), 1);
				Scroll_Wall(counter, int2fix(RNG(-4, 4)), 0, SIDE_FRONT, 2);
				//Scroll_Wall(counter, FixedDiv( int2fix(RNG(-4, 4)), 	int2fix(GetChar(StrNumToInt(VolumetricTextureSize(3, counter)), 0))), 0, SIDE_FRONT, 2);
				counter++;
				}




			counter = LINETAG_VolumetricD_up;
			while(counter <= LINETAG_VolumetricD_dn)
				{
				SetLineTexture(counter, SIDE_FRONT, TEXTURE_MIDDLE, StrParam(s:"LIT", s:VolumetricTextureSize(1, counter), s:VolumetricTextureSize(2, counter), i:counterB));
				TranslucentLine(counter, counterD, 1);
				Scroll_Wall(counter, int2fix(counterC), 0, SIDE_FRONT, 2);
				//Scroll_Wall(counter, FixedDiv( int2fix(RNG(-4, 4)), 	int2fix(GetChar(StrNumToInt(VolumetricTextureSize(3, counter)), 0))), 0, SIDE_FRONT, 2);
				counter++;
				}

		BREAK;


		CASE 2:
													Sector_SetColor	(SECTORTAG_Hub, 		255, 255, 255, 0);
				for (i = 1; i <= 64;  i++)			Sector_SetColor	(SECTORTAG_Skybox + i,	255, 255, 255, 0);




				GAMEINFO[RoundsCount] = RNG(2,5);




				CreateTranslation (tc_GREY, 	112:127		=	96:111);
				CreateTranslation (tc_WHITE, 	112:127		=	80:95);
				CreateTranslation (tc_BROWN, 	112:127		=	64:79);
				CreateTranslation (tc_PEACH, 	112:127		=	48:63);
				CreateTranslation (tc_RED, 		112:127		=	32:47);
				CreateTranslation (tc_PINK, 	112:127		=	16:31);
				CreateTranslation (tc_YELLOW, 	112:127		=	227:231);
				CreateTranslation (tc_BLUE, 	112:127		=	198:207);
				CreateTranslation (tc_GREEN, 	112:127		=	112:127);


		BREAK;
	}




}



















function void DrawNotification (int Who, str srcString, int Position, int Paragraph, int IconInt, str IconStr, int Color, str MainFont, int LogIt, int Capped, int FadeIn, int Hold, int FadeOut)
{
int counter, Yoffset, HUDidmsg, HUDidicon;
str tempStr = "";
Str IconName = "";
Str LogColor = "";
SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, 0);
Switch(Position)
	{
	CASE notepose_TOP:	Yoffset = int2fix(Y_TOP_ICON);			HUDidmsg = HUDid_NoteTOPmsg;	HUDidicon = HUDid_NoteTOPicon;		break;
	CASE notepose_MID:	Yoffset = int2fix(Y_MIDDLE_ICON);		HUDidmsg = HUDid_NoteMIDmsg;	HUDidicon = HUDid_NoteMIDicon;		break;
	CASE notepose_BOT:	Yoffset = int2fix(Y_BOTTOM_ICON);		HUDidmsg = HUDid_NoteBOTmsg;	HUDidicon = HUDid_NoteBOTicon;		break;
	}





if (Paragraph == notepara_ALIGN)
	{
				if (strLen(srcString) > MaxInfoChars)
						{
						counter = 0;	tempStr = "";
						while (counter < MaxInfoChars - 2)
							{
							tempStr = StrParam(s:tempStr, c:GetChar(srcString, counter));
							counter++;
							}
						tempStr = StrParam(s:tempStr, s:"..");

						}

		else	if (strLen(srcString) < MaxInfoChars)
						{
						tempStr = srcString;
						counter = StrLen(tempStr);
						while (counter < MaxInfoChars)
							{
							tempStr = StrParam(s:tempStr, s:" ");
							counter++;
							}
						}

	}

else 	tempStr = srcString;

if (Capped == ON) tempStr = StrToUpper(tempStr);
//---------------------------------------------
if (LogIt == ON)
	{
	Switch(IconInt)
			{
			CASE ICON_None: 			IconName = ""; 																																						break;
			CASE ICON_Exclamation:		if (GetPort() >= Zandronum)		LogColor = "\cg";	IconName = StrParam(s:LogColor, s:"WARNING"); 																	break;
			CASE ICON_Location:			if (GetPort() >= Zandronum)		LogColor = "\cf";	IconName = StrParam(s:LogColor, s:"LOCATION"); 																	break;
			CASE ICON_Checkmark:		if (GetPort() >= Zandronum)		LogColor = "\cg";	IconName = StrParam(s:LogColor, i:RoundInfo[CurrentRound], s:"/", i:GAMEINFO[RoundsCount], s:" CLEARED");			break;
			CASE ICON_Clock:			if (GetPort() >= Zandronum)		LogColor = "\cx";	IconName = StrParam(s:LogColor, s:"TIME"); 																		break;
			CASE ICON_Exit:				if (GetPort() >= Zandronum)		LogColor = "\cx";	IconName = StrParam(s:LogColor, s:"EXIT"); 																		break;
			CASE ICON_Mission:			if (GetPort() >= Zandronum)		LogColor = "\ci";	IconName = StrParam(s:LogColor, s:"GOAL"); 																		break;
			CASE ICON_Weapon:			if (GetPort() >= Zandronum)		LogColor = "\cr";	IconName = StrParam(s:LogColor, s:"NEW WEAPON"); 																break;
			CASE ICON_Sad:				if (GetPort() >= Zandronum)		LogColor = "\ch";	IconName = StrParam(s:LogColor, s:"OOPS"); 																		break;
			CASE ICON_Sad:				if (GetPort() >= Zandronum)		LogColor = "\cq";	IconName = StrParam(s:LogColor, s:"PURCHASE"); 																	break;
			CASE ICON_HEADER_Clock:		if (GetPort() >= Zandronum)		LogColor = "\cg";	IconName = StrParam(s:LogColor, s:"COUNTDOWN"); 																break;
			CASE ICON_Round:			if (GetPort() >= Zandronum)		LogColor = "\cc";	IconName = StrParam(s:LogColor, s:"ROUND"); 																	break;
			CASE ICON_Boss:				if (GetPort() >= Zandronum)		LogColor = "\cg";	IconName = StrParam(s:LogColor, s:"BOSS"); 																		break;
			}
	if (StrLen(IconName) > 0)			if (GetPort() >= Zandronum)		LogColor = "\cj";	IconName = StrParam(s:IconName, s:LogColor, s:":  ");
	if (Capped == ON) 																		IconName = StrToUpper(IconName);
	}



Switch(Who)
	{
	CASE For_ActivatorOnly:
	SetFont("ERICON");		HudMessage		(s:"\c",	s:color, s:IconStr; 	HUDMSG_FADEINOUT, 					HUDidicon,	CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2 - DN_IconOffset),		Yoffset, 	Hold, FadeIn, FadeOut);
	SetFont(MainFont);		HudMessage		(s:"\c",	s:color, s:tempStr; 	HUDMSG_FADEINOUT,					HUDidmsg,	CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2),						Yoffset, 	Hold, FadeIn, FadeOut);

	if (LogIt == ON)		HudMessage		(		s:IconName,	s:tempStr; 		HUDMSG_FADEINOUT|HUDMSG_LOG|HUDMSG_ALPHA,		0,			CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2),					Yoffset, 	0.001, 0.0, 0.0, 0.0);
	break;

	CASE For_Everyone:
	SetFont("ERICON");		HudMessageBold	(s:"\c",	s:color, s:IconStr; 	HUDMSG_FADEINOUT, 					HUDidicon,	CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2 - DN_IconOffset),		Yoffset, 	Hold, FadeIn, FadeOut);
	SetFont(MainFont);		HudMessageBold	(s:"\c",	s:color, s:tempStr; 	HUDMSG_FADEINOUT,					HUDidmsg,	CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2),						Yoffset, 	Hold, FadeIn, FadeOut);

	if (LogIt == ON)		HudMessageBold	(		s:IconName,	s:tempStr; 		HUDMSG_FADEINOUT|HUDMSG_LOG|HUDMSG_ALPHA,		0,			CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2),					Yoffset, 	0.001, 0.0, 0.0, 0.0);
	break;
	}






}





Script "MSG_Hurry" (int AdventureType) CLIENTSIDE
{
str Hurr = ""; str to = "";

	Switch(RNG(0,1))
			{
			CASE 0:	Hurr = "HURRY UP! ";	break;			CASE 1:	Hurr = "HURRY, ";	break;
			}

	Switch (AdventureType)
			{
			CASE adventure_RAISE: 	to = "CLIMB TO THE ";		break;
			CASE adventure_LINEAR: 	to = "GET TO THE ";			break;
			CASE adventure_MAZE: 	to = "GET BACK TO THE ";	break;
			CASE adventure_FLOW: 	to = "FLOW BACK TO THE ";	break;
			}

DrawNotification(For_ActivatorOnly, StrParam(s:Hurr, s:To, s:"TELEPORT"), 		notepose_MID, notepara_ALIGN, ICON_Exclamation, StrParam(c:ICON_Exclamation), "c", "ERFONT",  ON, ON, noteFadeIn_Short, noteHold_Standart, noteFadeOut_Standart);
}





function int AdventureCeilingHeight (void)
{
int Height;
	Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])
			{
			CASE	adventure_BOSS:		Height = RNG(2,4); 	break;
			CASE	adventure_MAZE:		Height = RNG(2,4); 	break;
			CASE	adventure_LINEAR:	Height = 16; 			break;
			CASE	adventure_RAISE:	Height = 32; 			break;
			CASE	adventure_INVASION:	Height = RNG(1,2); 	break;
			CASE	adventure_FLOW	:	Height = RNG(2,3); 	break;
			}

Height = Height*128;

return Height;
}







function void RefreshSpotHeight (int Which, int ID)
{

Switch(Which)
		{
		CASE	refreshspot_ITEM:
		if (GetActorZ(SectorItem [ID][si_SECTOR]) != GetSectorFloorZ(SectorItem [ID][si_SECTOR], None, None))
		SetActorPosition(SectorItem [ID][si_SECTOR], GetActorX(SectorItem [ID][si_SECTOR]), GetActorY(SectorItem [ID][si_SECTOR]), GetSectorFloorZ(SectorItem [ID][si_SECTOR], None, None), false);
		break;

		CASE	refreshspot_PROJECTILE:
		if (GetActorZ(Projectila[ID][ProjParam_EMITSPOT]) != int2fix(Projectila[ID][ProjParam_HEIGHT]))
		SetActorPosition(Projectila[ID][ProjParam_EMITSPOT], GetActorX(Projectila[ID][ProjParam_EMITSPOT]), GetActorY(Projectila[ID][ProjParam_EMITSPOT]), int2fix(Projectila[ID][ProjParam_HEIGHT]), false);
		break;


		CASE	refreshspot_DEFAULT:
		if (GetActorZ(ID) != GetSectorFloorZ(ID, None, None))
		SetActorPosition(ID, GetActorX(ID), GetActorY(ID), GetSectorFloorZ(ID, None, None), false);
		break;
		}


}




/*

 _______  __    __  .__   __.   ______ .___________. __    ______   .__   __.      _______.                       _______.___________..______      .______          ___      .___  ___.
|   ____||  |  |  | |  \ |  |  /      ||           ||  |  /  __  \  |  \ |  |     /       |       _              /       |           ||   _  \     |   _  \        /   \     |   \/   |
|  |__   |  |  |  | |   \|  | |  ,----'`---|  |----`|  | |  |  |  | |   \|  |    |   (----`      (_)            |   (----`---|  |----`|  |_)  |    |  |_)  |      /  ^  \    |  \  /  |
|   __|  |  |  |  | |  . `  | |  |         |  |     |  | |  |  |  | |  . `  |     \   \                          \   \       |  |     |      /     |      /      /  /_\  \   |  |\/|  |
|  |     |  `--'  | |  |\   | |  `----.    |  |     |  | |  `--'  | |  |\   | .----)   |          _          .----)   |      |  |     |  |\  \----.|  |\  \----./  _____  \  |  |  |  |
|__|      \______/  |__| \__|  \______|    |__|     |__|  \______/  |__| \__| |_______/          (_)         |_______/       |__|     | _| `._____|| _| `._____/__/     \__\ |__|  |__|


ZDaemon is incapable to store any kind of Variable that has inhereted it's value from the GetCvarString or StrParam functions. It gets dumped the next tic.
For the cases when I need to store it for more than 1 cycle I store it in a 'RAM'. RAM are sectors light values at the bottom of the map. That's right, because of that issue
I have to store important stuff in map geometry rofl. I think in all cases I just store it in a RAM and immediatelly send it where I need to.



*/







function void SetRAM (int Which)
{
int counter, TIDRAM;		str DataStr = "";


Switch(Which)
	{

	CASE fromCvar_WINNERS:

	DataStr = 	GetCVarString("Winners");
	TIDRAM	=	TIDRAM_WinnerNames;

	break;



	CASE fromArray_WinnerNames:

	While(counter < (MaxStages*GAMEINFO[MaxNameChars]))
		{
		//DataStr = StrParam(s:DataStr, c:Crypt(Decrypt, WinnerNames[counter]));
		DataStr = StrParam(s:DataStr, c:WinnerNames[counter]);
		counter++;
		}

	TIDRAM	=	TIDRAM_WinnerNames;

	break;



	CASE fromCvar_LEGENDS:

	DataStr = 	GetCVarString("Legends");
	TIDRAM	=	TIDRAM_LegendNames;

	break;


	CASE fromArray_LegendNames:

	While(counter < (MaxLegends*GAMEINFO[MaxNameChars]))
		{
		//DataStr = StrParam(s:DataStr, c:Crypt(Decrypt, LegendNames[counter]));
		DataStr = StrParam(s:DataStr, c:LegendNames[counter]);
		counter++;
		}

	TIDRAM	=	TIDRAM_LegendNames;

	break;





	}







counter = 0;
//Convert
while(counter < StrLen(DataStr))
    {
    Light_ChangeToValue(TIDRAM + counter, GetChar(DataStr, counter));


	Switch(which)
		{
		CASE fromCvar_WINNERS: 				WinnerNames[counter] = GetSectorLightLevel(TIDRAM + counter);	break;
		CASE fromArray_WinnerNames: 		WinnerNames[counter] = GetSectorLightLevel(TIDRAM + counter);	break;
		CASE fromCvar_LEGENDS: 				LegendNames[counter] = GetSectorLightLevel(TIDRAM + counter);	break;
		CASE fromArray_LegendNames: 		LegendNames[counter] = GetSectorLightLevel(TIDRAM + counter);	break;
		}




    counter++;
    }
}








function void NewLegend (void)
{


int counter, NewLegendNum, NewLegendScore, CmpA, CmpB, IncrementedScore, Iteration;
str CmpNameA, CmpNameB = "";

/*
             _              ___              _
  __ _ _____(_)__ _ _ _    / __|_ __  _ __  /_\
 / _` (_-<_-< / _` | ' \  | (__| '  \| '_ \/ _ \
 \__,_/__/__/_\__, |_||_|  \___|_|_|_| .__/_/ \_\
              |___/                  |_|
*/


while(CmpA < MaxStages)
	{
	CmpA++;


	//Setting up a name of the Comparing
	counter = 0;	CmpNameA = "";	IncrementedScore = CmpA;	CmpB = 0;
	while(counter < GAMEINFO[MaxNameChars])
			{
			CmpNameA = StrParam(s:CmpNameA, c:WinnerNames[(CmpA - 1)*GAMEINFO[MaxNameChars] + counter]);
			counter++;
			}






/*
             _              ___            ___
  __ _ _____(_)__ _ _ _    / __|_ __  _ __| _ )
 / _` (_-<_-< / _` | ' \  | (__| '  \| '_ \ _ \
 \__,_/__/__/_\__, |_||_|  \___|_|_|_| .__/___/
              |___/                  |_|
*/



	while (CmpB < MaxStages)
		{
		CmpB++;

			counter = 0;	CmpNameB = "";
			while(counter < GAMEINFO[MaxNameChars])		//Setting up a name of the Comparable
					{
					CmpNameB = StrParam(s:CmpNameB, c:WinnerNames[(CmpB - 1)*GAMEINFO[MaxNameChars] + counter]);
					counter++;
					}



					if ((StrCmp(CmpNameA, CmpNameB) == 0) && (CmpA != CmpB))	IncrementedScore += CmpB;		//If there was the same name and it was not the same stage, increment by his other stage win


		}



		//Checking if the Comparing outbested all the comparables
		if (IncrementedScore > NewLegendScore)
				{
				NewLegendScore = IncrementedScore;
				NewLegendNum = CmpA;
				}



	//log(s:CmpNameA, s:" has ", i:IncrementedScore, s:" points");




	}




		//Moving the old legends back a bit

		//ONE
		Iteration = GAMEINFO[MaxNameChars];
		for (int a = Iteration; a < Iteration + GAMEINFO[MaxNameChars];  a++)
		LegendNames[a + GAMEINFO[MaxNameChars]] = LegendNames[a];

		//TWO
		Iteration = 0;
		for (a = Iteration; a < Iteration + GAMEINFO[MaxNameChars];  a++)
		LegendNames[a + GAMEINFO[MaxNameChars]] = LegendNames[a];


counter = 0;	CmpNameA = "";
While(counter < GAMEINFO[MaxNameChars])
	{
	LegendNames[counter] = WinnerNames[GAMEINFO[MaxNameChars]*(NewLegendNum - 1) + counter];
	CmpNameA = StrParam(s:CmpNameA, c:LegendNames[counter]);
	counter++;
	}



PrintBold(s:CmpNameA, s:" outbested all the winners!  /", i:NewLegendNum);

}

/*
 _______  __    __  .__   __.   ______ .___________. __    ______   .__   __.      _______.            .______       _______     _______. _______ .___________.
|   ____||  |  |  | |  \ |  |  /      ||           ||  |  /  __  \  |  \ |  |     /       | _          |   _  \     |   ____|   /       ||   ____||           |
|  |__   |  |  |  | |   \|  | |  ,----'`---|  |----`|  | |  |  |  | |   \|  |    |   (----`(_)         |  |_)  |    |  |__     |   (----`|  |__   `---|  |----`
|   __|  |  |  |  | |  . `  | |  |         |  |     |  | |  |  |  | |  . `  |     \   \                |      /     |   __|     \   \    |   __|      |  |
|  |     |  `--'  | |  |\   | |  `----.    |  |     |  | |  `--'  | |  |\   | .----)   |    _          |  |\  \----.|  |____.----)   |   |  |____     |  |
|__|      \______/  |__| \__|  \______|    |__|     |__|  \______/  |__| \__| |_______/    (_)         | _| `._____||_______|_______/    |_______|    |__|

*/








function void ResetFloors (int Root)
{
for (int flr = 0; flr < 16; flr++)
	{
	Floor_MoveToValue(Root + flr, MoveInstantly, 0);
	ChangeFloor(Root + flr, DefaultFloorTexture);
	}
}










function void SetAtmosphere (int CurrRound)
{
int tx; str tex = "";

	RoundInfo[FlatBASEtx] = RNG(1,1);
	RoundInfo[FlatSECOtx] = RNG(1,1);
	RoundInfo[FlatEDGEtx] = RNG(1,1);
	RoundInfo[FlatFAILtx] = RNG(0,0);
	RoundInfo[FlatPORTtx] = RNG(1,1);
	RoundInfo[FlatWATEtx] = RNG(1,1);
	RoundInfo[FlatBOMBtx] = 1;
	RoundInfo[FlatWORMtx] = 1;
	RoundInfo[CeilBASEtx] = RNG(0,1);
	RoundInfo[CeilSECOtx] = RNG(1,1);
	RoundInfo[WallBASEtx] = RNG(1,11);
	RoundInfo[WallSECOtx] = RNG(1,11);
	RoundInfo[WallEDGEtx] = RNG(1,11);
	RoundInfo[WallFENCtx] = RNG(1,4);
	RoundInfo[WallRAIStx] = 1;

//FIXES
Switch(AdventureInfo[CurrRound][adv_TYPE])
		{
		CASE adventure_INVASION:	RoundInfo[CeilBASEtx] = 1;
		break;
		}

for (tx = 1; tx <= PlaygroundBlocks; tx++)
	{
	SetLineTexture(tx, SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallBASEtx));
	SetLineTexture(tx, SIDE_BACK, TEXTURE_BOTTOM, 	TextureIs(WallBASEtx));
	SetLineTexture(tx*100, SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
	SetLineTexture(tx*100, SIDE_BACK, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));

	SetLineTexture(tx*100, SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
	SetLineTexture(tx*100, SIDE_BACK, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
	}
/*
for (tx = PlaygroundBlocks + 1; tx <= PlaygroundBlocks*2; tx++)
	{
	SetLineTexture(tx, SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
	SetLineTexture(tx, SIDE_BACK, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
	}
*/
	//SetLineTexture(LINETAG_PlaygroundFence, SIDE_FRONT, TEXTURE_MIDDLE, 	TextureIs(WallFENCtx));
	//Line_SetTextureOffset(LINETAG_PlaygroundFence, , , SIDE_FRONT);


	//if (CurrRound > 1)	ResetPlayground();

ChangeCeiling(SECTORTAG_ShaftCoreEdge,	TextureIs(FlatEDGEtx));
ChangeCeiling(SECTORTAG_ShaftSlope, 	TextureIs(FlatBASEtx));
ChangeCeiling(SECTORTAG_ShaftOuterEdge,	TextureIs(FlatEDGEtx));
SetLineTexture(LINETAG_ShaftEdge, SIDE_FRONT, TEXTURE_TOP, 	TextureIs(WallEDGEtx));			SetLineTexture(LINETAG_ShaftEdge, SIDE_BACK, TEXTURE_TOP, 	TextureIs(WallEDGEtx));
SetLineTexture(LINETAG_ShaftBase, SIDE_FRONT, TEXTURE_TOP, 	TextureIs(WallBASEtx));			SetLineTexture(LINETAG_ShaftBase, SIDE_BACK, TEXTURE_TOP, 	TextureIs(WallBASEtx));

	Switch(GAMEINFO[Mood])
			{
			CASE mood_EARTH:
			CASE mood_COLONY:
			tex = TextureIs(FlatBASEtx);
			for (tx = SECTORTAG_ShaftOuterPaling; tx <= SECTORTAG_ShaftCoreEdge; tx++)
					{
					ChangeFloor(tx, tex);
					//SetSectorVisual(tx);
					}
			//ChangeFloor(SECTORTAG_ShaftCore, tex);	ChangeFloor(SECTORTAG_ShaftCoreEdge, tex);	ChangeFloor(SECTORTAG_ShaftSlope, tex);	ChangeFloor(SECTORTAG_ShaftOuterEdge, tex);	ChangeFloor(SECTORTAG_SkyfallGround, tex);	ChangeFloor(SECTORTAG_ShaftOuterPaling, TextureIs(FlatSECOtx));
			ChangeFloor(SECTORTAG_ShaftCore, tex);
			ChangeFloor(SECTORTAG_ShaftOuterPaling, TextureIs(FlatSECOtx));
			Floor_MoveToValue(SECTORTAG_ShaftOuterPaling, MoveInstantly, (GetSectorFloorZ(SECTORTAG_ShaftCoreEdge, 0, 0) >>16) + 64);
			Ceiling_MoveToValue(SECTORTAG_ShaftCoreEdge, MoveInstantly, GetSectorFloorZ(SECTORTAG_ShaftCoreEdge, 0, 0) >>16);
			SetLineTexture(LINETAG_SkyfallPaling, SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
			break;

			CASE mood_SPACE:
			tex = "F_SKY1";
			for (tx = SECTORTAG_ShaftOuterPaling; tx <= SECTORTAG_ShaftCoreEdge; tx++)
					{
					ChangeFloor(tx, tex);
					//SetSectorVisual(tx);
					}
			//ChangeFloor(SECTORTAG_ShaftCore, tex);	ChangeFloor(SECTORTAG_ShaftCoreEdge, tex);	ChangeFloor(SECTORTAG_ShaftSlope, tex);	ChangeFloor(SECTORTAG_ShaftOuterEdge, tex);	ChangeFloor(SECTORTAG_SkyfallGround, tex);	ChangeFloor(SECTORTAG_ShaftOuterPaling, tex);
			ChangeFloor(SECTORTAG_ShaftCore, tex);
			ChangeFloor(SECTORTAG_ShaftOuterPaling, tex);
			//Floor_MoveToValue(SECTORTAG_ShaftOuterPaling, MoveInstantly, GetSectorFloorZ(SECTORTAG_ShaftCoreEdge, 0, 0) >>16);
			Ceiling_MoveToValue(SECTORTAG_ShaftCoreEdge, MoveInstantly, -4096);
			SetLineTexture(LINETAG_SkyfallPaling, SIDE_FRONT, TEXTURE_BOTTOM, 	"-");
			break;
			}
}








function str TextureIs (int Type)			//Mood, Texture Axis, Type, Index		"1FLBS1"
{
str Result = "";		str PrefixType = "";



	Switch(Type)
		{
		CASE FlatBASEtx:	PrefixType = "FLBA";		break;
		CASE FlatSECOtx:	PrefixType = "FLSE";		break;
		CASE FlatEDGEtx:	PrefixType = "FLED";		break;
		CASE FlatFAILtx:	PrefixType = "FLFA";		break;
		CASE FlatPORTtx:	PrefixType = "FLPO";		break;
		CASE FlatWATEtx:	PrefixType = "WATE";		break;
		CASE FlatBOMBtx:	PrefixType = "BOMB";		break;
		CASE FlatWORMtx:	PrefixType = "WORM";		break;
		CASE CeilBASEtx:	PrefixType = "CEBA";		break;
		CASE CeilSECOtx:	PrefixType = "CESE";		break;
		CASE WallBASEtx:	PrefixType = "WALL";		break;
		CASE WallSECOtx:	PrefixType = "WALL";		break;
		CASE WallEDGEtx:	PrefixType = "WALL";		break;
		CASE WallFENCtx:	PrefixType = "WAFE";		break;
		CASE WallRAIStx:	PrefixType = "RAIS";		break;
		}


		if 	(Type == None)													Result = "-";

else 	if 	((Type == CeilBASEtx) 	&& 	(RoundInfo[CeilBASEtx]	== 0))		Result = "F_SKY1";
else 	if 	((Type == FlatFAILtx) 	&& 	(RoundInfo[FlatFAILtx]	== 0))		Result = "BLACKFLT";

else																		Result = StrParam(i:GAMEINFO[Mood], s:PrefixType, i:RoundInfo[Type]);



return Result;
}





function str SetMonster (int Type)
{
int A, B;
int Percent;
str Result;
			if (ServerInfo[STAGE] > 0) // if SEASON ON
				{
				A = ServerInfo[STAGE]*4 - 4;
				B = ServerInfo[STAGE]*4 + 15;
				Percent = RNG(A, B);
				}
			else Percent = RNG(1, 99); // if DEFAULT


					if (Percent < 20)
							Switch(RNG(1,6))
							{
							Case 1: 	Result = "Zombieman";			break;
							Case 2: 	Result = "LostSoul";			break;
							Case 3: 	Result = "DoomImp";				break;
							Case 4: 	Result = "Demon";				break;
							Case 5: 	Result = "-";					break;
							Case 6: 	Result = "-";					break;
							}
					else if (Percent >= 20	&&	Percent < 40)
							Switch(RNG(1,4))
							{
							Case 1: 	Result = "ShotgunGuy";			break;
							Case 2: 	Result = "Spectre";				break;
							Case 3: 	Result = "ChaingunGuy";			break;
							Case 4: 	Result = "-";					break;
							}
					else if (Percent >= 40	&&	Percent < 60)
							Switch(RNG(1,6))
							{
							Case 1: 	Result = "HellKnight";			break;
							Case 2: 	Result = "Mancubus";			break;
							Case 3: 	Result = "LostSoul";			break;
							Case 4: 	Result = "Cacodemon";			break;
							Case 5: 	Result = "-";					break;
							Case 6: 	Result = "-";					break;
							}
					else if (Percent >= 60	&&	Percent < 80)
							Switch(RNG(1,7))
							{
							Case 1: 	Result = "Revenant";			break;
							Case 2: 	Result = "ArchVile";			break;
							Case 3: 	Result = "BaronOfHell";			break;
							Case 4: 	Result = "Arachnotron";			break;
							Case 5: 	Result = "-";					break;
							Case 6: 	Result = "-";					break;
							Case 7: 	Result = "-";					break;
							}
					else if (Percent >= 80	&&	Percent < 100)
							Switch(RNG(1,7))
							{
							Case 1: 	Result = "CyberDemon";			break;
							Case 2: 	Result = "WolfensteinSS";		break;
							Case 3: 	Result = "SpiderMastermind";	break;
							Case 4: 	Result = "-";					break;
							Case 5: 	Result = "-";					break;
							Case 6: 	Result = "-";					break;
							Case 7: 	Result = "-";					break;
							}

return Result;
}








function int ContainerMass (int WhatToReturn, int ContainerType, int Direction)
{
int Result, XXX, YYY;
	if ((Direction == ToRight)||(Direction == ToLeft))
		{
		Switch(ContainerType)
			{
			CASE OneBlock: 		XXX = 1; YYY = 1; break;
			CASE TwoBlocks: 	XXX = 2; YYY = 1; break;
			CASE ThreeBlocks: 	XXX = 3; YYY = 1; break;
			CASE FourBlocks: 	XXX = 2; YYY = 2; break;
			}
		}
	else if ((Direction == ToDown)||(Direction == ToUp))
		{
		Switch(ContainerType)
			{
			CASE OneBlock: 		XXX = 1; YYY = 1; break;
			CASE TwoBlocks: 	XXX = 1; YYY = 2; break;
			CASE ThreeBlocks: 	XXX = 1; YYY = 3; break;
			CASE FourBlocks: 	XXX = 2; YYY = 2; break;
			}
		}


Switch(WhatToReturn)
	{
	Case AxisX: Result = XXX; break;
	Case AxisY: Result = YYY; break;
	}
Return Result;
}



/*

																	BordersType


		  |    	             |    	             |    	             |    	             |    	             |
          |    	             |    	             |    	             |    	             |    	             |
               	             |    	                  	             |    	             |
          |    	             |    	             |    	             |    	             |    	             |
	      |    	             |    	             |    	             |    	             |    	             |
----  ----         ----------          ----------          ----  ----                                                  ----------             ----  ----

    1                   2                  3                     4               5                   6                      7                     8                    9


												|
												|
												|
												|
												c
												|
												|
												|
												|
											<---y---	ContainerEntryY
												|
												|
												|
												|
												|
												d
												|
												|
						^						|
						|						|
----------a-------------x---------------b--------
						|
						|

				ContainerEntryX





*/





int Order[5];
int BordersTypeOf_Order[5];


function int ContainerInfo (int InfoType, int ContainerType, int OrderNum, int BlockCounter, int Direction)
{
int Result, BlocksAmount, ContainerEntryX, ContainerEntryY;


Switch(ContainerType)
	{
	case OneBlock:		BlocksAmount = 1;
				Order[1] = 	BlockCounter + 0;
				BordersTypeOf_Order[1] = 1;
				ContainerEntryX = BlockCounter + 0;
				ContainerEntryY = BlockCounter + 0;
	break;


	case TwoBlocks:		BlocksAmount = 2;

			if (Direction == ToRIGHT)
				{
				Order[1] = 	BlockCounter + 0;
				Order[2] = 	BlockCounter + 1;
				BordersTypeOf_Order[1] = 7;
				BordersTypeOf_Order[2] = 1;
				}
			if (Direction == ToDOWN)
				{
				Order[1] = 	BlockCounter + 0;
				Order[2] = 	BlockCounter + sqrt(PlaygroundBlocks);
				BordersTypeOf_Order[1] = 6;
				BordersTypeOf_Order[2] = 4;
				}
			if (Direction == ToLEFT)
				{
				Order[1] = 	BlockCounter + 1;
				Order[2] = 	BlockCounter + 0;
				BordersTypeOf_Order[1] = 1;
				BordersTypeOf_Order[2] = 7;
				}
			if (Direction == ToUP)
				{
				Order[1] = 	BlockCounter + sqrt(PlaygroundBlocks);
				Order[2] = 	BlockCounter + 0;
				BordersTypeOf_Order[1] = 4;
				BordersTypeOf_Order[2] = 6;
				}


			if ((Direction == ToRIGHT)||(Direction == ToLEFT))
				{
				ContainerEntryX = BlockCounter + 0;
				ContainerEntryY = BlockCounter + 1;
				}
			if ((Direction == ToDOWN)||(Direction == ToUP))
				{
				ContainerEntryX = BlockCounter + sqrt(PlaygroundBlocks);
				ContainerEntryY = BlockCounter + 0;
				}
	break;



	case ThreeBlocks:		BlocksAmount = 3;

			if (Direction == ToRIGHT)
				{
				Order[1] = 	BlockCounter + 0;
				Order[2] = 	BlockCounter + 1;
				Order[3] = 	BlockCounter + 2;
				BordersTypeOf_Order[1] = 7;
				BordersTypeOf_Order[2] = 8;
				BordersTypeOf_Order[3] = 3;
				}
			if (Direction == ToDOWN)
				{
				Order[1] = 	BlockCounter + 0;
				Order[2] = 	BlockCounter + sqrt(PlaygroundBlocks);
				Order[3] = 	BlockCounter + sqrt(PlaygroundBlocks)*2;
				BordersTypeOf_Order[1] = 5;
				BordersTypeOf_Order[2] = 6;
				BordersTypeOf_Order[3] = 4;
				}
			if (Direction == ToLEFT)
				{
				Order[1] = 	BlockCounter + 2;
				Order[2] = 	BlockCounter + 1;
				Order[3] = 	BlockCounter + 0;
				BordersTypeOf_Order[1] = 3;
				BordersTypeOf_Order[2] = 8;
				BordersTypeOf_Order[3] = 7;
				}
			if (Direction == ToUP)
				{
				Order[1] = 	BlockCounter + sqrt(PlaygroundBlocks)*2;
				Order[2] = 	BlockCounter + sqrt(PlaygroundBlocks);
				Order[3] = 	BlockCounter + 0;
				BordersTypeOf_Order[1] = 4;
				BordersTypeOf_Order[2] = 6;
				BordersTypeOf_Order[3] = 5;
				}


			if ((Direction == ToRIGHT)||(Direction == ToLEFT))
				{
				ContainerEntryX = BlockCounter + 1;
				ContainerEntryY = BlockCounter + 2;
				}
			if ((Direction == ToDOWN)||(Direction == ToUP))
				{
				ContainerEntryX = BlockCounter + sqrt(PlaygroundBlocks)*2;
				ContainerEntryY = BlockCounter + sqrt(PlaygroundBlocks);
				}
	break;

	case FourBlocks:		BlocksAmount = 4;

			if (Direction == ToRIGHT)
				{
				Order[1] = 	BlockCounter + 0;
				Order[2] = 	BlockCounter + 1;
				Order[3] = 	BlockCounter + sqrt(PlaygroundBlocks) + 1;
				Order[4] = 	BlockCounter + sqrt(PlaygroundBlocks);
				BordersTypeOf_Order[1] = 9;
				BordersTypeOf_Order[2] = 6;
				BordersTypeOf_Order[3] = 4;
				BordersTypeOf_Order[4] = 7;
				}
			if (Direction == ToDOWN)
				{
				Order[1] = 	BlockCounter + 1;
				Order[2] = 	BlockCounter + sqrt(PlaygroundBlocks) + 1;
				Order[3] = 	BlockCounter + sqrt(PlaygroundBlocks);
				Order[4] = 	BlockCounter + 0;
				BordersTypeOf_Order[1] = 6;
				BordersTypeOf_Order[2] = 4;
				BordersTypeOf_Order[3] = 7;
				BordersTypeOf_Order[4] = 9;
				}
			if (Direction == ToLEFT)
				{
				Order[1] = 	BlockCounter + sqrt(PlaygroundBlocks) + 1;
				Order[2] = 	BlockCounter + sqrt(PlaygroundBlocks);
				Order[3] = 	BlockCounter + 0;
				Order[4] = 	BlockCounter + 1;
				BordersTypeOf_Order[1] = 4;
				BordersTypeOf_Order[2] = 7;
				BordersTypeOf_Order[3] = 9;
				BordersTypeOf_Order[4] = 6;
				}
			if (Direction == ToUP)
				{
				Order[1] = 	BlockCounter + sqrt(PlaygroundBlocks);
				Order[2] = 	BlockCounter + 0;
				Order[3] = 	BlockCounter + 1;
				Order[4] = 	BlockCounter + sqrt(PlaygroundBlocks) + 1;
				BordersTypeOf_Order[1] = 7;
				BordersTypeOf_Order[2] = 9;
				BordersTypeOf_Order[3] = 6;
				BordersTypeOf_Order[4] = 4;
				}

				ContainerEntryX = BlockCounter + sqrt(PlaygroundBlocks) + 1;
				ContainerEntryY = BlockCounter + 1;
	break;
	}



Switch(InfoType)
	{
	CASE InfoType_ORDER:			Result = Order[OrderNum];					break;
	CASE InfoType_BORDERTYPE:		Result = BordersTypeOf_Order[OrderNum];		break;
	CASE InfoType_EntryX:			Result = ContainerEntryX;					break;
	CASE InfoType_EntryY:			Result = ContainerEntryY;					break;
	CASE InfoType_BLOCKSAMOUNT:		Result = BlocksAmount;						break;
	}



Return Result;
}




function int BorderTypeWNoEntrance (int BorderType)
{
int Result;
Switch(BorderType)
		{
		CASE 1: Result = 2;	break;
		CASE 2: Result = 2;	break;
		CASE 3: Result = 2;	break;
		CASE 4: Result = 2;	break;
		CASE 5: Result = 5;	break;
		CASE 6: Result = 5;	break;
		CASE 7: Result = 7;	break;
		CASE 8: Result = 7;	break;
		CASE 9: Result = 9;	break;
		}
return Result;
}





function int B2S (int BlockNum)	// BLOCK TO SECTOR
{
int Result = BlockNum*100;
return Result;
}




#libdefine	StartA		1
#libdefine	EndA		2
#libdefine	StartB		3
#libdefine	EndB		4
#libdefine	StartC		5
#libdefine	EndC		6
#libdefine	StartD		7
#libdefine	EndD		8
#libdefine	EntryY	9
#libdefine	EntryX	10
#libdefine	BorderCross	11

function int BorderSegment(int Segment)
{
int Result;
Switch(Segment)
		{
		CASE StartA:		Result = 64;								break;
		CASE EndA:			Result = 66;								break;

		CASE EntryY:		Result = 67;								break;

		CASE StartB:		Result = 68 + RoundInfo[OptEntranceY];		break;
		CASE EndB:			Result = 71; 								break;
//----------------------------------------------------------------------------------
		CASE StartC:		Result = 73;								break;
		CASE EndC:			Result = 75; 								break;

		CASE EntryX:		Result = 76; 								break;

		CASE StartD:		Result = 77 + RoundInfo[OptEntranceX];		break;
		CASE EndD:			Result = 80; 								break;
//==================================================================================
		CASE BorderCross:	Result = 72; 								break;
		}
return Result;
}


/*

		  |    	             |    	             |    	             |    	             |    	             |
          |    	             |    	             |    	             |    	             |    	             |
               	             |    	                  	             |    	             |
          |    	             |    	             |    	             |    	             |    	             |
	      |    	             |    	             |    	             |    	             |    	             |
----  ----         ----------          ----------          ----  ----                                                  ----------             ----  ----

    1                   2                  3                     4               5                   6                      7                     8                    9

*/






/*				*/		#libdefine		BorderFill_None			0
/*	----------	*/		#libdefine		BorderFill_Full			1
/*	----  ----	*/		#libdefine		BorderFill_wEntrance	2


#libdefine		BorderSideX	0
#libdefine		BorderSideY	1






function void SetWarmupBlockLines (bool what)
{
int i, counter;
while (counter < 4) //Rotating directions
	{
	counter++;
	for (i = 24; 	i <= 25;  i++)
		{
		Switch(What)
			{
			CASE TRUE:
			SetLineTexture	(LineAt (RoundInfo[StartpointTAG]/100, counter, i), SIDE_FRONT, TEXTURE_MIDDLE, "ANLAZA01");
			Line_SetBlocking(LineAt (RoundInfo[StartpointTAG]/100, counter, i),	BLOCKF_SIGHT, 		false);
			Line_SetBlocking(LineAt (RoundInfo[StartpointTAG]/100, counter, i),	BLOCKF_EVERYTHING, 	false);
			TranslucentLine	(LineAt (RoundInfo[StartpointTAG]/100, counter, i), 255, TRUE);
			break;

			CASE FALSE:
			SetLineTexture	(LineAt (RoundInfo[StartpointTAG]/100, counter, i), SIDE_FRONT, TEXTURE_MIDDLE, "-");
			Line_SetBlocking(LineAt (RoundInfo[StartpointTAG]/100, counter, i),	false, 		BLOCKF_SIGHT);
			Line_SetBlocking(LineAt (RoundInfo[StartpointTAG]/100, counter, i),	false, 		BLOCKF_EVERYTHING);
			TranslucentLine	(LineAt (RoundInfo[StartpointTAG]/100, counter, i), 255, FALSE);
			break;
			}
		}
	}
}







#libdefine dlt_MAIN			0
#libdefine dlt_mainMID		1
#libdefine dlt_edgeALL		2
#libdefine dlt_edgeMAIN		3
#libdefine dlt_edgeSIDEY	4
#libdefine dlt_edgeCAPE		5

#libdefine dlt_DRAW			0
#libdefine dlt_CLEAR		1

function void ClearBlockTextures (int BlockCounter)
{
DrawLineTexture (dlt_CLEAR,  dlt_edgeALL, 	BlockCounter, ToRIGHT,	64);
DrawLineTexture (dlt_CLEAR,  dlt_edgeALL, 	BlockCounter, ToRIGHT,	65);
DrawLineTexture (dlt_CLEAR,  dlt_edgeALL, 	BlockCounter, ToRIGHT,	66);
DrawLineTexture (dlt_CLEAR,  dlt_edgeALL,	BlockCounter, ToRIGHT, 	67);
DrawLineTexture (dlt_CLEAR,  dlt_edgeALL,	BlockCounter, ToRIGHT, 	68);
DrawLineTexture (dlt_CLEAR,  dlt_edgeALL,	BlockCounter, ToRIGHT, 	69);
DrawLineTexture (dlt_CLEAR,  dlt_edgeALL,	BlockCounter, ToRIGHT, 	70);
DrawLineTexture (dlt_CLEAR,  dlt_edgeALL,	BlockCounter, ToRIGHT, 	71);

DrawLineTexture (dlt_CLEAR,  dlt_edgeALL, 	BlockCounter, ToDOWN, 	64);
DrawLineTexture (dlt_CLEAR,  dlt_edgeALL, 	BlockCounter, ToDOWN, 	65);
DrawLineTexture (dlt_CLEAR,  dlt_edgeALL, 	BlockCounter, ToDOWN, 	66);
DrawLineTexture (dlt_CLEAR,  dlt_edgeALL,	BlockCounter, ToDOWN, 	67);
DrawLineTexture (dlt_CLEAR,  dlt_edgeALL,	BlockCounter, ToDOWN, 	68);
DrawLineTexture (dlt_CLEAR,  dlt_edgeALL,	BlockCounter, ToDOWN, 	69);
DrawLineTexture (dlt_CLEAR,  dlt_edgeALL,	BlockCounter, ToDOWN, 	70);
DrawLineTexture (dlt_CLEAR,  dlt_edgeALL,	BlockCounter, ToDOWN, 	71);


DrawLineTexture (dlt_CLEAR,  dlt_main, 		BlockCounter, DOESNT_MATTER, DOESNT_MATTER);
}

function void DrawLineTexture (int WhatToDo, int Which, int BlockCounter, int Direction, int seg)
{
int LineTag;



if (WhatToDo == dlt_DRAW)
	{


			//MAIN
		if (Which == dlt_MAIN)
			{
			SetLineTexture		(LineAt (BlockCounter, Direction, 0), 	SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallBASEtx));
			SetLineTexture		(LineAt (BlockCounter, Direction, 0), 	SIDE_FRONT, TEXTURE_TOP, 		TextureIs(WallSECOtx));
			SetLineTexture		(LineAt (BlockCounter, Direction, 0), 	SIDE_BACK, 	TEXTURE_BOTTOM, 	TextureIs(WallBASEtx));
			SetLineTexture		(LineAt (BlockCounter, Direction, 0), 	SIDE_BACK, 	TEXTURE_TOP, 		TextureIs(WallSECOtx));

			}

			//BORDER

		if ((Which == dlt_edgeALL) || (Which == dlt_edgeMAIN))
			{
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_FRONT, 	seg), 	SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_FRONT, 	seg), 	SIDE_FRONT, TEXTURE_TOP, 		TextureIs(WallEDGEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_BACK, 		seg), 	SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_BACK, 		seg), 	SIDE_FRONT, TEXTURE_TOP, 		TextureIs(WallEDGEtx));
			}

		if ((Which == dlt_edgeALL) || (Which == dlt_edgeSIDEY))
			{
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_SIDEY, 	seg), 	SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_SIDEY, 	seg), 	SIDE_FRONT, TEXTURE_TOP, 		TextureIs(WallEDGEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_SIDEY, 	seg), 	SIDE_BACK, 	TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_SIDEY, 	seg), 	SIDE_BACK, 	TEXTURE_TOP, 		TextureIs(WallEDGEtx));
			}

		if (Which == dlt_edgeCAPE)
			{
			SetLineTexture		(CapeHeader 		+ BlockCounter, 	SIDE_FRONT, TEXTURE_TOP, 		TextureIs(WallEDGEtx));
			SetLineTexture		(CapeHeader 		+ BlockCounter, 	SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
			SetLineTexture		(CapeHeaderINNER 	+ BlockCounter, 	SIDE_FRONT, TEXTURE_TOP, 		TextureIs(WallEDGEtx));
			SetLineTexture		(CapeHeaderINNER 	+ BlockCounter, 	SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
			}
	}



if (WhatToDo == dlt_CLEAR)
	{

			//MAIN MID
		if (Which == dlt_main)
			{

			SetLineTexture		(BlockCounter, 	SIDE_FRONT, TEXTURE_MIDDLE, 	TextureIs(None));
			SetLineTexture		(BlockCounter, 	SIDE_BACK, 	TEXTURE_MIDDLE, 	TextureIs(None));
			Line_SetBlocking	(BlockCounter, 	false,  BLOCKF_EVERYTHING);
			Line_SetBlocking	(BlockCounter, 	false, BLOCKF_SIGHT);
			Line_SetBlocking 	(BlockCounter, 	false, BLOCKF_PROJECTILES);
			SetLineBlocking		(BlockCounter,	BLOCK_NOTHING);
			SetLineSpecial		(BlockCounter,  0, 0, 0, 0, 0, 0);
			}


			//BORDER

		if ((Which == dlt_edgeALL) || (Which == dlt_edgeMAIN))
			{
			//frontside
			SetLineTexture(		LineAt (BlockCounter, Direction, AssignLine (SIDE_FRONT, 	seg)),	SIDE_FRONT,	TEXTURE_MIDDLE, TextureIs(None));
			SetLineTexture(		LineAt (BlockCounter, Direction, AssignLine (SIDE_FRONT, 	seg)),	SIDE_BACK,	TEXTURE_MIDDLE, TextureIs(None));
			Line_SetBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_FRONT, 	seg)), 	false, BLOCKF_EVERYTHING);
			Line_SetBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_FRONT, 	seg)), 	false, BLOCKF_SIGHT);
			Line_SetBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_FRONT, 	seg)),  false, BLOCKF_PROJECTILES);
			SetLineBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_FRONT, 	seg)),	BLOCK_NOTHING);
			SetLineSpecial(		LineAt (BlockCounter, Direction, AssignLine (SIDE_FRONT, 	seg)),  0, 0, 0, 0, 0, 0);
			//backside
			SetLineTexture(		LineAt (BlockCounter, Direction, AssignLine (SIDE_BACK, 	seg)),	SIDE_FRONT,	TEXTURE_MIDDLE, TextureIs(None));
			SetLineTexture(		LineAt (BlockCounter, Direction, AssignLine (SIDE_BACK, 	seg)),	SIDE_BACK,	TEXTURE_MIDDLE, TextureIs(None));
			Line_SetBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_BACK, 	seg)), 	false, BLOCKF_EVERYTHING);
			Line_SetBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_BACK, 	seg)), 	false, BLOCKF_SIGHT);
			Line_SetBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_BACK, 	seg)),  false, BLOCKF_PROJECTILES);
			SetLineBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_BACK, 	seg)),	BLOCK_NOTHING);
			SetLineSpecial(		LineAt (BlockCounter, Direction, AssignLine (SIDE_BACK, 	seg)),  0, 0, 0, 0, 0, 0);
			}


		if ((Which == dlt_edgeALL) || (Which == dlt_edgeSIDEY))
			{
			SetLineTexture(		LineAt (BlockCounter, Direction, AssignLine (SIDE_SIDEY, 	seg)), 	SIDE_FRONT, TEXTURE_MIDDLE, TextureIs(None));
			SetLineTexture(		LineAt (BlockCounter, Direction, AssignLine (SIDE_SIDEY, 	seg)), 	SIDE_BACK, 	TEXTURE_MIDDLE, TextureIs(None));
			Line_SetBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_SIDEY, 	seg)),  false, BLOCKF_EVERYTHING);
			Line_SetBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_SIDEY, 	seg)),  false, BLOCKF_SIGHT);
			Line_SetBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_SIDEY, 	seg)),  false, BLOCKF_PROJECTILES);
			SetLineBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_SIDEY, 	seg)),	BLOCK_NOTHING);
			SetLineSpecial(		LineAt (BlockCounter, Direction, AssignLine (SIDE_SIDEY, 	seg)),  0, 0, 0, 0, 0, 0);
			}

	}

}


/*

function void SetOutsideLines (int Which, int Turn, str Tex)
{
int Block, Unblock, Reblock;

		Switch(Which)
				{
				CASE LINETAG_PlaygroundFence:				Block = BLOCKF_EVERYTHING;		Unblock = None; 			Reblock = None;					break;
				CASE LINETAG_PlaygroundPerimeter:			Block = BLOCKF_PLAYERS;			Unblock = BLOCKF_MONSTERS;	Reblock = BLOCKF_MONSTERS;		break;
				}

Switch(Turn)
	{
	CASE ON:
	SetLineTexture(		Which, SIDE_FRONT, TEXTURE_MIDDLE, tex);
	Line_SetBlocking(	Which, Block, Unblock);
	break;

	CASE OFF:
	SetLineTexture(		Which, SIDE_FRONT, TEXTURE_MIDDLE, "-");
	Line_SetBlocking(	Which, None, BLOCKF_EVERYTHING);
	Line_SetBlocking(	Which, Reblock, None);
	break;
	}
}

*/






function void FillContainerBorders (int ContainerType, int BlockCounter, int Direction)
{

int counter, Xmethod, YMethod, clm, tempBC /*, START1, END1, START2, END2*/;
bool cross;

While (counter	<	ContainerInfo (InfoType_BLOCKSAMOUNT, ContainerType, DOESNT_MATTER, BlockCounter, Direction))
	{
	counter++;

	tempBC = ContainerInfo(InfoType_ORDER, ContainerType, counter, BlockCounter, Direction);



/*DEBUG*/ 	Switch(ContainerInfo(InfoType_BORDERTYPE, ContainerType, counter, BlockCounter, Direction))	//Switch(1)//
		{
		CASE 1:	Xmethod = 2;	YMethod = 2;	break;
		CASE 2:	Xmethod = 1;	YMethod = 1;	break;
		CASE 3:	Xmethod = 1;	YMethod = 2;	break;
		CASE 4:	Xmethod = 2;	YMethod = 1;	break;
		CASE 5:	Xmethod = 0;	YMethod = 1;	break;
		CASE 6:	Xmethod = 0;	YMethod = 2;	break;
		CASE 7:	Xmethod = 1;	YMethod = 0;	break;
		CASE 8:	Xmethod = 2;	YMethod = 0;	break;
		CASE 9:	Xmethod = 0;	YMethod = 0;	break;
		}


if (BlockCounterAtTheEdge(ToDOWN, 	tempBC) == FALSE)		//Don't do this in the last rows
SetBorderWall(BorderSideX, Xmethod, tempBC, Direction);


if (BlockCounterAtTheEdge(ToRIGHT, 	tempBC) == FALSE)		//Don't do this in the last columns
SetBorderWall(BorderSideY, Ymethod, tempBC, Direction);


	}

}


Script "ChangeCapeCeiling" (int BlockCounter)
{
delay(GenDel_Height);
Ceiling_MoveToValue		(CapeHeader + BlockCounter,   MoveInstantly, RoundInfo[GlobalCeilingHeight]);
ChangeCeiling			(CapeHeader + BlockCounter,   TextureIs(CeilBASEtx));
}



function void SetBorderWall (int Side, int Method, int BlockCounter, int Direction)
{
int seg, exc, Start1, End1, Start2, End2, AddBorderEntryHeight, Entry, OptEntry;
bool DontMoveSector;
int excA = 0;
int excB = RoundInfo[BorderExceptionCounter];




Switch(SIDE)
	{
	CASE BorderSideY:
	Start1 = StartA;	End1 = EndA;	Start2 = StartB;	End2 = EndB;	Entry = BorderSegment(EntryY);		OptEntry = RoundInfo[OptEntranceY];		AddBorderEntryHeight = RoundInfo[AddBorderEntryHeightY];
	break;

	CASE BorderSideX:
	Start1 = StartC;	End1 = EndC;	Start2 = StartD;	End2 = EndD;	Entry = BorderSegment(EntryX);		OptEntry = RoundInfo[OptEntranceX];		AddBorderEntryHeight = RoundInfo[AddBorderEntryHeightX];
	break;
	}



//wide open entrance if its a flow adventure
if (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_FLOW)
		if(Method == BorderFill_wEntrance)
					{
					AddBorderEntryHeight = 0;
					AddBorderEntryHeight = 0;
					Method = BorderFill_None;
					}




				if
				(
				(BlockCounterAtTheEdge(ToRIGHT, BlockCounter) == TRUE) ||
				(BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE) ||
				(BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE) ||
				(BlockCounterAtTheEdge(ToUP, 	BlockCounter) == TRUE)
				)
					{
					Floor_MoveToValue	(CapeHeader + BlockCounter,   MoveInstantly, RoundInfo[GlobalCeilingHeight]);
					ChangeFloor			(CapeHeader + BlockCounter,   TextureIs(FlatEDGEtx));
					ACS_NamedExecuteAlways("ChangeCapeCeiling", 0, BlockCounter);
					DrawLineTexture 	(dlt_DRAW, dlt_edgeCAPE,	BlockCounter, Direction, seg);
					}



//but it will do the same shit twice, idfcare meh
if (Method > BorderFill_None)

			Floor_MoveToValue(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + BorderSegment(BorderCross),	MoveInstantly, RoundInfo[GlobalCeilingHeight]);


	Switch(Method)
		{


//	-                       -
//  -                      -
		CASE BorderFill_None:

			if (((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == FALSE)		&&		(SIDE == BorderSideY)) ||
				((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == FALSE)		&&		(SIDE == BorderSideX)))
					{
					seg = BorderSegment(Start1);
					while(seg <= BorderSegment(End2))
						{
						for (exc = excA; exc <= excB; exc++)
								{
								if ((B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg) == Projectila[exc][ProjParam_EMITSPOT])		DontMoveSector = true;
								if ((B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg) == Projectila[exc][ProjParam_DEVOURSPOT])	DontMoveSector = true;
								}

						if (DontMoveSector == false)
								{
								Floor_MoveToValue	(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg,   MoveInstantly, RoundInfo[CurrFloorHeight] + AddBorderEntryHeight);
								ChangeFloor			(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg,   TextureIs(FlatBASEtx));
								}

						DontMoveSector = false;
						seg++;
						}

					}


		break;

//	-------------------------
//  -------------------------
		CASE BorderFill_Full:


			if (((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == FALSE)		&&		(SIDE == BorderSideY)) ||
				((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == FALSE)		&&		(SIDE == BorderSideX)))
					{
					seg = BorderSegment(Start1);
					while(seg <= BorderSegment(End2))
						{
						for (exc = excA; exc <= excB; exc++)
								{
								if ((B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg) == Projectila[exc][ProjParam_EMITSPOT])		DontMoveSector = true;
								if ((B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg) == Projectila[exc][ProjParam_DEVOURSPOT])	DontMoveSector = true;
								}

						if (DontMoveSector == false)
								{
								Floor_MoveToValue	(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg,   MoveInstantly, RoundInfo[GlobalCeilingHeight]);
								ChangeFloor			(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg,   TextureIs(FlatEDGEtx));

								}
						DrawLineTexture 	(dlt_DRAW, dlt_edgeMAIN,	BlockCounter, Direction, seg);
						DontMoveSector = false;
						seg++;
						}

					}












		break;




//	---------|     |---------
//  ---------|     |---------
		CASE BorderFill_wEntrance:

			if (((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == FALSE)		&&		(SIDE == BorderSideY)) ||
				((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == FALSE)		&&		(SIDE == BorderSideX)))
				{
					seg = BorderSegment(Start1);
					while(seg <= BorderSegment(End1))
						{
						for (exc = excA; exc <= excB; exc++)
								{
								if ((B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg) == Projectila[exc][ProjParam_EMITSPOT])		DontMoveSector = true;
								if ((B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg) == Projectila[exc][ProjParam_DEVOURSPOT])	DontMoveSector = true;
								}

						if (DontMoveSector == false)
								{
								Floor_MoveToValue	(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg,   MoveInstantly, RoundInfo[GlobalCeilingHeight]);
								ChangeFloor			(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg,   TextureIs(FlatEDGEtx));


								}
						DrawLineTexture 	(dlt_DRAW, dlt_edgeALL,	BlockCounter, Direction, seg);
						DontMoveSector = false;
						seg++;
						}





					seg = BorderSegment(Start2);
					while(seg <= BorderSegment(End2))
						{
						for (exc = excA; exc <= excB; exc++)
								{
								if ((B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg) == Projectila[exc][ProjParam_EMITSPOT])		DontMoveSector = true;
								if ((B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg) == Projectila[exc][ProjParam_DEVOURSPOT])	DontMoveSector = true;
								}

						if (DontMoveSector == false)
								{
								Floor_MoveToValue	(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg,   MoveInstantly, RoundInfo[GlobalCeilingHeight]);
								ChangeFloor			(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg,   TextureIs(FlatEDGEtx));
								}

						DrawLineTexture 	(dlt_DRAW, dlt_edgeALL,	BlockCounter, Direction, seg);
						DontMoveSector = false;
						seg++;
						}
				}



				Floor_MoveToValue	(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + Entry,						MoveInstantly, RoundInfo[CurrFloorHeight] + AddBorderEntryHeight);
				ChangeFloor			(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + Entry,   					TextureIs(FlatBASEtx));
				DrawLineTexture 	(dlt_DRAW, dlt_edgeALL,	BlockCounter, Direction, Entry);


			if(OptEntry == TRUE)
				{
				Floor_MoveToValue	(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + Entry + OptEntry,			MoveInstantly, RoundInfo[CurrFloorHeight] + AddBorderEntryHeight);
				ChangeFloor			(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + Entry + OptEntry,   		TextureIs(FlatBASEtx));
				DrawLineTexture 	(dlt_DRAW, dlt_edgeALL,	BlockCounter, Direction, Entry + OptEntry);
				}


		break;
		}



}













/*

 __________   ___  _______   ______  __    __  .___________. __    ______   .__   __.
|   ____\  \ /  / |   ____| /      ||  |  |  | |           ||  |  /  __  \  |  \ |  |
|  |__   \  V  /  |  |__   |  ,----'|  |  |  | `---|  |----`|  | |  |  |  | |   \|  |
|   __|   >   <   |   __|  |  |     |  |  |  |     |  |     |  | |  |  |  | |  . `  |
|  |____ /  .  \  |  |____ |  `----.|  `--'  |     |  |     |  | |  `--'  | |  |\   |
|_______/__/ \__\ |_______| \______| \______/      |__|     |__|  \______/  |__| \__|



*/


Script "PlayerENTER" 	ENTER			{delay(1);	SetPlayerStuff();}
Script "PlayerRESPAWN" 	RESPAWN			{DamageThing(InstantDeath, MOD_UNKNOWN);} //delay(1);	SetPlayerStuff();}







Script "BOOT" OPEN
{
SetActivator(0, AAPTR_NULL);
//--------------------------------------------------------------------------------------------------C H E C K   P O R T
SpawnSpotForced("GZDoomSpot", 				ACTORTID_PortSpot, 	ACTORTID_GZDoomTag, 	0);			//GZDOOM
SpawnSpotForced("ZandronumSpot", 			ACTORTID_PortSpot, 	ACTORTID_ZandronumTag,	0);			//ZANDRONUM
																									//ZDAEMON
SetPort();
//------------------------------------------------------------------------------------------------------------------------------------------

Switch(GetLevelInfo(LEVELINFO_LEVELNUM))
		{
		CASE MainMap:
		break;

		CASE TitleMap:
		ACS_NamedExecute("CUTSCENE", 0, 2);	terminate;
		break;
		}


MapPreset(1);

Switch(GetPort())
		{
		CASE Zandronum:
		if (!GetCvar("Survival"))	ACS_NamedExecute("EXE", 0);
		break;

		CASE ZDaemon:
		CASE GZDoom:
		ACS_NamedExecute("EXE", 0);
		break;
		}
}





Script "EXE" (void)
{
int consoleSEASON			= GetCvar("SEASON");
int consoleSTAGE			= GetCvar("STAGE");
int consoleTRY				= GetCvar("TRY");
int counter, counterB, tempCounter, i, Iteration, tmp;
str tempStr, StringA;


GAMEINFO[GameSim] = TRUE;

//Change the Mood and Location
GAMEINFO[Mood] 			= RNG(1, 3);		//3
GAMEINFO[Location] 		= RNG(1, 9);		//9


MapPreset(2);


/*
  _____ ___ ____  ____ _____   _        _   _   _ _   _  ____ _   _                _                           _            _
 |  ___|_ _|  _ \/ ___|_   _| | |      / \ | | | | \ | |/ ___| | | |  _   ___  ___| |_   ___ ___ _ __      ___| |_ __ _    | |_ _ __ _   _
 | |_   | || |_) \___ \ | |   | |     / _ \| | | |  \| | |   | |_| | (_) / __|/ _ \ __| / __/ __| '_ \    / __| __/ _` |   | __| '__| | | |
 |  _|  | ||  _ < ___) || |   | |___ / ___ \ |_| | |\  | |___|  _  |  _  \__ \  __/ |_  \__ \__ \ | | |_  \__ \ || (_| |_  | |_| |  | |_| |
 |_|   |___|_| \_\____/ |_|   |_____/_/   \_\___/|_| \_|\____|_| |_| (_) |___/\___|\__| |___/___/_| |_( ) |___/\__\__, ( )  \__|_|   \__, |
                                                                                                      |/          |___/|/            |___/

*/

	if (ServerInfo[SEASON]	>	0)	if (ServerInfo[STAGE]		<= 0)	ServerInfo[STAGE]		= 1;
	if (ServerInfo[TRY]		<=	0)										ServerInfo[TRY]			= 1;






// Set Maximum letter limit in the name by the port.

Switch(GetPort())
	{
	Case ZDaemon:		GAMEINFO[MaxNameChars] = MaxNameCharsZDA;	break;
	Case Zandronum: 	GAMEINFO[MaxNameChars] = MaxNameCharsZAN;	break;
	CASE GZDoom:		for(i = 0; i < MaxPlayers; i++)		Thing_Remove(ACTORTID_PlayerSpawner + i);		break;
	}

/*

  _____ ___ ____  ____ _____   _        _   _   _ _   _  ____ _   _        __ _ _ _                              _                _ _   _       ____  ____   _    ____ _____        _
 |  ___|_ _|  _ \/ ___|_   _| | |      / \ | | | | \ | |/ ___| | | |  _   / _(_) | |  _ __ ___  ___ ___  _ __ __| |___  __      _(_) |_| |__   / ___||  _ \ / \  / ___| ____|   ___| |__   __ _ _ __
 | |_   | || |_) \___ \ | |   | |     / _ \| | | |  \| | |   | |_| | (_) | |_| | | | | '__/ _ \/ __/ _ \| '__/ _` / __| \ \ /\ / / | __| '_ \  \___ \| |_) / _ \| |   |  _|    / __| '_ \ / _` | '__|
 |  _|  | ||  _ < ___) || |   | |___ / ___ \ |_| | |\  | |___|  _  |  _  |  _| | | | | | |  __/ (_| (_) | | | (_| \__ \  \ V  V /| | |_| | | |  ___) |  __/ ___ \ |___| |___  | (__| | | | (_| | |
 |_|   |___|_| \_\____/ |_|   |_____/_/   \_\___/|_| \_|\____|_| |_| (_) |_| |_|_|_| |_|  \___|\___\___/|_|  \__,_|___/   \_/\_/ |_|\__|_| |_| |____/|_| /_/   \_\____|_____|  \___|_| |_|\__,_|_|

*/

if (WinnerNames[0] == 0) 	for (i = 0; i < GAMEINFO[MaxNameChars]*MaxStages; i++)	WinnerNames[i] = 32;
if (LegendNames[0] == 0) 	for (i = 0; i < GAMEINFO[MaxNameChars]*MaxLegends; i++)	LegendNames[i] = 32;

if (GetPort() == Zandronum) // for zandronum also fill the database
		{

		BeginDBTransaction();

		if (GetChar(GetDBEntryString(StrParam(s:"db_Season", i:ServerInfo[SEASON], s:"Winners"), "db_WinnerOfStage1"), 0) == 0)
			{

			/*
				 _      __ _           __      ___
			  __| |___ / _(_)_ _  ___  \ \    / (_)_ _  _ _  ___ _ _ ___
			 / _` / -_)  _| | ' \/ -_)  \ \/\/ /| | ' \| ' \/ -_) '_(_-<
			 \__,_\___|_| |_|_||_\___|   \_/\_/ |_|_||_|_||_\___|_| /__/

			*/

			tempStr = "";
			counter = 0;
			While(counter < GAMEINFO[MaxNameChars])
				{
				tempStr = StrParam(s:tempStr, s:" ");
				counter++;
				}
			Iteration = 0;
			While (Iteration < MaxStages)
			{
			Iteration++;
			SetDBEntryString(StrParam(s:"db_Season", i:ServerInfo[SEASON], s:"Winners"), StrParam(s:"db_WinnerOfStage", i:Iteration), tempStr);
			}

			/*
				 _      __ _            _                         _
			  __| |___ / _(_)_ _  ___  | |   ___ __ _ ___ _ _  __| |___
			 / _` / -_)  _| | ' \/ -_) | |__/ -_) _` / -_) ' \/ _` (_-<
			 \__,_\___|_| |_|_||_\___| |____\___\__, \___|_||_\__,_/__/
												|___/
			*/

			tempStr = "";
			counter = 0;
			While(counter < GAMEINFO[MaxNameChars]*MaxLegends)
				{
				tempStr = StrParam(s:tempStr, s:" ");
				counter++;
				}

			SetDBEntryString("db_TEXTINFO", "db_Legends", tempStr);

			}

		EndDBTransaction();
		}



//otherwise
/*
  ___                            _    __        ___                             _          _                 _
 |_ _|_ __ ___  _ __   ___  _ __| |_  \ \      / (_)_ __  _ __   ___ _ __ ___  | |_ ___   | | ___   ___ __ _| |  _ __ ___   ___ _ __ ___   ___  _ __ _   _
  | || '_ ` _ \| '_ \ / _ \| '__| __|  \ \ /\ / /| | '_ \| '_ \ / _ \ '__/ __| | __/ _ \  | |/ _ \ / __/ _` | | | '_ ` _ \ / _ \ '_ ` _ \ / _ \| '__| | | |
  | || | | | | | |_) | (_) | |  | |_    \ V  V / | | | | | | | |  __/ |  \__ \ | || (_) | | | (_) | (_| (_| | | | | | | | |  __/ | | | | | (_) | |  | |_| |
 |___|_| |_| |_| .__/ \___/|_|   \__|    \_/\_/  |_|_| |_|_| |_|\___|_|  |___/  \__\___/  |_|\___/ \___\__,_|_| |_| |_| |_|\___|_| |_| |_|\___/|_|   \__, |
               |_|                                                                                                                                   |___/

*/


Switch(GetPort())
	{
	Case ZDaemon:
	SetRAM(fromArray_WinnerNames);
	SetRAM(fromArray_LegendNames);
	break;


	Case Zandronum:







			BeginDBTransaction();

			ServerInfo[SEASON] = GetDBEntry("db_ERINFO", "db_SEASON");
			ServerInfo[STAGE] = GetDBEntry("db_ERINFO", "db_STAGE");
			//ServerInfo[TRY] = GetDBEntry("db_ERINFO", "db_TRY");



			/*
			  _                     _     _                      _
			 (_)_ __  _ __  ___ _ _| |_  | |___ __ _ ___ _ _  __| |___
			 | | '  \| '_ \/ _ \ '_|  _| | / -_) _` / -_) ' \/ _` (_-<
			 |_|_|_|_| .__/\___/_|  \__| |_\___\__, \___|_||_\__,_/__/
					 |_|                       |___/
			*/
			counter = 0;
			while(counter < (MaxLegends*GAMEINFO[MaxNameChars]))
				{
				LegendNames[counter] = GetChar(GetDBEntryString("db_TEXTINFO", "db_Legends"), counter);
				counter++;
				}


			/*
			  _                     _            _
			 (_)_ __  _ __  ___ _ _| |_  __ __ _(_)_ _  _ _  ___ _ _ ___
			 | | '  \| '_ \/ _ \ '_|  _| \ V  V / | ' \| ' \/ -_) '_(_-<
			 |_|_|_|_| .__/\___/_|  \__|  \_/\_/|_|_||_|_||_\___|_| /__/
					 |_|
			*/
			Iteration = 0;
			While (Iteration <= MaxStages)
			{
			Iteration++;
			counter = 0;
				While(counter < GAMEINFO[MaxNameChars])
					{
					WinnerNames[(Iteration - 1)*GAMEINFO[MaxNameChars] + counter] = GetChar(GetDBEntryString(StrParam(s:"db_Season", i:ServerInfo[SEASON], s:"Winners"), StrParam(s:"db_WinnerOfStage", i:Iteration)), counter);
					counter++;
					}
			}


			counter = 0;
			while(counter < (MaxLegends*GAMEINFO[MaxNameChars]))
				{
				LegendNames[(Iteration - 1)*GAMEINFO[MaxNameChars] + counter] = GetChar(GetDBEntryString("db_TEXTINFO", "db_Legends"), counter);
				counter++;
				}


			/*
			  _                     _
			 (_)_ __  _ __  ___ _ _| |_   _ __  ___ _ _  ___ _  _
			 | | '  \| '_ \/ _ \ '_|  _| | '  \/ _ \ ' \/ -_) || |
			 |_|_|_|_| .__/\___/_|  \__| |_|_|_\___/_||_\___|\_, |
					 |_|                                     |__/
			*/

			ServerInfo[MoneyNameCount] = GetDBEntry("db_ERINFO", "MONEY_NameCount");


			for(tmp = 0; tmp <= ServerInfo[MoneyNameCount]; tmp++)
								{
								MoneyInfo_VALUE[tmp] = GetDBEntry("db_ERINFO", StrParam(s:"MONEY_Value", i:tmp));
								for(i = 0; i < 32; i++)		MoneyInfo_NAME[tmp * 32 + i] = GetChar(GetDBEntryString("db_ERINFO", StrParam(s:"MONEY_Name", i:tmp)), i);
								}




			EndDBTransaction();





/*
  ___ ___  ___  ___ ___     ___  __  __ ___ _      _   ___ ___
 | __/ _ \| _ \/ __| __|   |   \|  \/  | __| |    /_\ / __/ __|
 | _| (_) |   / (__| _|    | |) | |\/| | _|| |__ / _ \ (_ \__ \
 |_| \___/|_|_\\___|___|   |___/|_|  |_|_| |____/_/ \_\___|___/ for Zandronum

*/


/*			ZDaemon
			sv_joinlimit 1


*/


			if (!GetCvar("sv_ForceSoftwarePitchLimits")) 	consolecommand("set sv_ForceSoftwarePitchLimits 1");
			if ( GetCvar("sv_AirControl") != 0) 			consolecommand("set sv_AirControl 0");
			if (!GetCvar("Compat_Limited_AirMovement")) 	consolecommand("set Compat_Limited_AirMovement 1");
			if (!GetCvar("sv_ShootThroughAllies"))			consolecommand("set sv_ShootThroughAllies 1");
			if (!GetCvar("sv_DontPushAllies"))				consolecommand("set sv_DontPushAllies 1");
			if ( GetCvar("sv_WeaponDrop"))					consolecommand("set sv_WeaponDrop 0");
			if (!GetCvar("sv_NoDrop"))						consolecommand("set sv_NoDrop 1");
			if (!GetCvar("sv_NoRocketJumping"))				consolecommand("set sv_NoRocketJumping 1");
			if (!GetCvar("sv_ForceVideoDefaults"))			consolecommand("set sv_ForceVideoDefaults 1");
			if ( GetCvar("sv_Cheats"))						consolecommand("set sv_Cheats 0");
			if (!GetCvar("sv_NoCrouch"))					consolecommand("set sv_NoCrouch 1");
			if (!GetCvar("sv_ForceVideoDefaults"))			consolecommand("set sv_ForceVideoDefaults 1");
			if (!GetCvar("sv_Coop_LoseInventory"))			consolecommand("set sv_Coop_LoseInventory 1");
			if (!GetCvar("sv_unblockplayers"))				consolecommand("set sv_unblockplayers 1");

			break;
	}


if (GetPort() < GZDoom)		RenderLegends();


GAMEINFO[RoundsCount] = GetRoundsCount();


	//------ROUNDS-------------------------------------------------------------------------------------------------------

counter = 0;
while(counter < GAMEINFO[RoundsCount])
		{
		counter++;	tempCounter = counter;

		if ((tempCounter == GAMEINFO[RoundsCount]) && (GAMEINFO[RoundsCount] > 2))	//BOSSES
				{
				//Main Boss
				AdventureInfo[tempCounter][adv_TYPE] 	= 	adventure_BOSS;
				AdventureInfo[tempCounter][adv_MUSIC] 	= 	AssignMusic(MusicType(AdventureInfo[tempCounter][adv_TYPE]));				//RNG(MUSIC_minBOSS, MUSIC_maxBOSS);

				//Optional Boss
				if (GAMEINFO[RoundsCount] >= MaxRounds - 1)
						Switch(RNG(false, true))
								{
								CASE TRUE:
								tempCounter = RNG(2,GAMEINFO[RoundsCount] - 2);
								AdventureInfo[tempCounter][adv_TYPE] = adventure_BOSS;
								AdventureInfo[tempCounter][adv_MUSIC] = AssignMusic(MusicType(AdventureInfo[tempCounter][adv_TYPE]));
								break;
								}
				}

		else
				{


				//Decide Adventure Type
				AdventureInfo[tempCounter][adv_TYPE]  = RNG(22,22);
						if  (AdventureInfo[tempCounter][adv_TYPE] <  30)													AdventureInfo[tempCounter][adv_TYPE]  = adventure_MAZE;
				else	if ((AdventureInfo[tempCounter][adv_TYPE] >= 30) && (AdventureInfo[tempCounter][adv_TYPE] <  60)) 	AdventureInfo[tempCounter][adv_TYPE]  = adventure_LINEAR;
				else	if ((AdventureInfo[tempCounter][adv_TYPE] >= 60) && (AdventureInfo[tempCounter][adv_TYPE] <  75)) 	AdventureInfo[tempCounter][adv_TYPE]  = adventure_INVASION;
				else	if ((AdventureInfo[tempCounter][adv_TYPE] >= 75) && (AdventureInfo[tempCounter][adv_TYPE] <  90)) 	AdventureInfo[tempCounter][adv_TYPE]  = adventure_RAISE;
				else																									 	AdventureInfo[tempCounter][adv_TYPE]  = adventure_FLOW;

						//Dont duplicate some adventure types
						for (i = 0; i < tempCounter; i++)
											{
											if (AdventureInfo[i][adv_TYPE] ==  adventure_INVASION)	AdventureInfo[tempCounter][adv_TYPE]  = RNG(adventure_MAZE, adventure_LINEAR);
											if (AdventureInfo[i][adv_TYPE] ==  adventure_RAISE)		AdventureInfo[tempCounter][adv_TYPE]  = RNG(adventure_MAZE, adventure_LINEAR);
											if (AdventureInfo[i][adv_TYPE] ==  adventure_FLOW)		AdventureInfo[tempCounter][adv_TYPE]  = RNG(adventure_MAZE, adventure_LINEAR);
											}


				//Decide the othermusic
				if (counterB == 0)	{		AdventureInfo[tempCounter][adv_MUSIC] = AssignMusic(MusicType(AdventureInfo[tempCounter][adv_TYPE]));	if (RNG(false, true))	counterB++;	}
				else 				{		AdventureInfo[tempCounter][adv_MUSIC] = AdventureInfo[tempCounter - 1][adv_MUSIC];													CounterB--;	}
				}

	tempCounter = counter;
	//------DIFFICULTY-------------------------------------------------------------------------------------------------------

	//Decide the average difficulty
	if(ServerInfo[STAGE] > 0)
								{
								tmp	=	(FixedMul(int2fix(tempCounter), 3.5) >> 16)		+	(FixedMul(int2fix(ServerInfo[STAGE]), 3.5) >> 16) ;


								// Adventure Correction
								Switch(AdventureInfo[tempCounter][adv_TYPE])
										{
										CASE adventure_BOSS:		tmp = tmp;		break;
										CASE adventure_MAZE:		tmp = tmp;		break;
										CASE adventure_LINEAR:		tmp = tmp;		break;
										CASE adventure_RAISE:		tmp = tmp - 50;	break;
										CASE adventure_INVASION:	tmp = tmp;		break;
										CASE adventure_FLOW	:		tmp = tmp;		break;
										}



								}

	else						tmp		=	RNG(1,100);


								//Final Correction
										if 	(tmp < 1)		tmp = 1;
								else 	if 	(tmp > 100)		tmp = 100;

								AdventureInfo[tempCounter][adv_DIFFICULTY] = 1;//tmp;

	//Decide the weapons	/////////////////////////////////////////////////////////////

								AdventureInfo[tempCounter][adv_WEAPON] = SetRoundWeapon(AdventureInfo[tempCounter][adv_DIFFICULTY]);


	//Decide the Boss max health	/////////////////////////////////////////////////////////////
							if (ServerInfo[STAGE] > 0) 			AdventureInfo[tempCounter][adv_BOSSMAXHP] = 		1250 + ServerInfo[STAGE]*180;
							else								AdventureInfo[tempCounter][adv_BOSSMAXHP] = 		RNG(1250, 1000 + AdventureInfo[tempCounter][adv_DIFFICULTY]*44);


							if (AdventureInfo[tempCounter][adv_TYPE] == adventure_FLOW) 			AdventureInfo[tempCounter][adv_MINICHECKPOINTS] = 2;

	//Decide the random event	/////////////////////////////////////////////////////////////
																																		// 		event_BOMB			1
																																		// 		event_WORM			2
							tmp = RNG(0,100);	if (tmp > 75)	Switch(AdventureInfo[tempCounter][adv_TYPE])
																	{
																	CASE adventure_BOSS: 		AdventureInfo[tempCounter][adv_RANDOMEVENT]	=	RNG(1,2);		break;
																	CASE adventure_MAZE: 		AdventureInfo[tempCounter][adv_RANDOMEVENT]	=	RNG(1,2);		break;
																	CASE adventure_LINEAR: 		AdventureInfo[tempCounter][adv_RANDOMEVENT]	=	RNG(1,2);		break;
																	CASE adventure_RAISE: 		AdventureInfo[tempCounter][adv_RANDOMEVENT]	=	-1;				break;
																	CASE adventure_INVASION: 	AdventureInfo[tempCounter][adv_RANDOMEVENT]	=	event_WORM;		break;
																	CASE adventure_FLOW: 		AdventureInfo[tempCounter][adv_RANDOMEVENT]	=	-1;				break;
																	}
		}



	//Reset weapons for boss rounds if that's a shit weapon
counter = 0;
while(counter < GAMEINFO[RoundsCount])
		{
		counter++;
		if (AdventureInfo[counter][adv_TYPE] == adventure_BOSS)
			if (AdventureInfo[counter][adv_WEAPON] < id_Shotgun)		AdventureInfo[counter][adv_WEAPON] = id_Shotgun;
		}












//SET FLOW SPEED
							if (ServerInfo[STAGE] > 0) 			RoundInfo[FlowSpeed] = 640	+ ServerInfo[STAGE]*3;
							else								RoundInfo[FlowSpeed] = 640	+ RNG(1, 25)*3;




//ITEM SPAWNING LINEUP, default spawning item is the most usual, ammo
RoundInfo[HealthSpawnerQueue]	=	1 +	10 + (FixedMul(int2fix(ServerInfo[STAGE]), 1.5) >> 16);
RoundInfo[MoneySpawnerQueue]	=	1 +	/*1*/5 + (FixedMul(int2fix(ServerInfo[STAGE]), 1.5) >> 16);
RoundInfo[WeaponSpawnerQueue]	=	1 +	20 + (FixedMul(int2fix(ServerInfo[STAGE]), 1.5) >> 16);
RoundInfo[AmmoSpawnerQueue]		=	1 +	3 + (FixedMul(int2fix(ServerInfo[STAGE]), 0.5) >> 16);


RoundInfo[CurrentRound]	= 1;


//Set music for Spectators, Stage outro, credits
AdventureInfo[None][adv_MUSIC]	= AssignMusic(MusicType(mus_CALM));


SetMusic(StrParam(s:"D_MUS", i:AdventureInfo[None][adv_MUSIC]));
Light_ChangeToValue(TIDRAM_HubMusic, AdventureInfo[None][adv_MUSIC]);




ACS_NamedExecute("INFOLOGIC", 0);



while 	((consoleSEASON == GetCvar("SEASON")) && (consoleSTAGE == GetCvar("STAGE")) && (consoleTRY == GetCvar("TRY")))		delay(1);

/*
  __  __                         _   ____                _
 |  \/  | __ _ _ __  _   _  __ _| | |  _ \ ___  ___  ___| |_
 | |\/| |/ _` | '_ \| | | |/ _` | | | |_) / _ \/ __|/ _ \ __|
 | |  | | (_| | | | | |_| | (_| | | |  _ <  __/\__ \  __/ |_
 |_|  |_|\__,_|_| |_|\__,_|\__,_|_| |_| \_\___||___/\___|\__|

*/

//it comes to this point if an admin has changed/restored game status himself


	ServerInfo[SEASON]			= GetCvar("SEASON");
	ServerInfo[STAGE]			= GetCvar("STAGE");
	ServerInfo[TRY]				= GetCvar("TRY");


	Switch(GetPort())
		{
		CASE ZDaemon:
			SetRAM(fromCvar_WINNERS);
			SetRAM(fromCvar_LEGENDS);
		break;


		CASE Zandronum:

			BeginDBTransaction();

			SetDBEntry("db_ERINFO", "db_SEASON", ServerInfo[SEASON]);
			SetDBEntry("db_ERINFO", "db_STAGE", ServerInfo[STAGE]);
			//SetDBEntry("db_ERINFO", "db_TRY", ServerInfo[TRY]);

			EndDBTransaction();
		break;
		}




delay(1);

MapReset();
terminate;
}









function void RegisterMoney (int PlayaNum, int Minus)
{
str StringA = ""; str Money = "BlasterAmmo";
int counter, MaxChars, i;
int IsMatch = -1;
Light_ChangeToValue(TIDRAM_MoneyChar, FALSE);

Switch(GetPort())
		{
		CASE ZDaemon:
		CASE GZDoom:		MaxChars = MaxPortNameCharsZDA;		break;
		CASE Zandronum:		MaxChars = MaxPortNameCharsZAN;		break;
		}

		if (PlayerInGame(PlayaNum) || (PlayerIsSpectator(PlayaNum) > 0))
			{
			StringA = GetPlayerName(TRUE, PlayaNum);
			i = StrLen(StringA);
			while (i < MaxChars)
				{
				StringA = (StrParam(s:StringA, c:32));
				i++;
				}


										while ( counter <= ServerInfo[MoneyNameCount])
											{
											i = 0;
											IsMatch = 0;

														while (i < MaxChars)
															{
																	if (GetChar(StringA, i) < 32) 										{IsMatch = -2; 		break;}
															else	if (GetChar(StringA, i) == MoneyInfo_NAME[counter * MaxChars + i])	 IsMatch++;
															i++;
															}

													if (IsMatch == -2)															{IsMatch = FALSE; 				break;}
											else	if (IsMatch  < MaxChars)	{if ( counter >= ServerInfo[MoneyNameCount])	{IsMatch = FALSE; 			 	break;}			else 	counter++;}
											else	if (IsMatch >= MaxChars)													{IsMatch = TRUE;				break;}


											}





								Switch(IsMatch)
									{



									CASE TRUE: 		// NAME ALREADY EXISTS

													if (MoneyInfo_VALUE[counter] - Minus 													< 		 MoneyInfo_VALUE[counter])	// -
															{
																MoneyInfo_VALUE[counter] -= Minus;
															}

											else 	if (MoneyInfo_VALUE[counter] + CheckActorInventory(PLAYER_TID + PlayaNum, Money) 		> 		 MoneyInfo_VALUE[counter])	// +
															{
																MoneyInfo_VALUE[counter] += CheckActorInventory(PLAYER_TID + PlayaNum, Money);
																TakeActorInventory(PLAYER_TID + PlayaNum, Money, MaxByte);
															}

											Light_ChangeToValue(TIDRAM_Money + Playanum, MoneyInfo_VALUE[counter]);

									break;



									CASE FALSE:		// NAME DOESN"T EXIST, CREATING IT


									i = 0;
									while (i < MaxChars)
										{
										Light_ChangeToValue(TIDRAM_MoneyChar, GetChar(StringA, i));
										MoneyInfo_NAME[counter * MaxChars + i] = GetSectorLightLevel(TIDRAM_MoneyChar);
										i++;
										}

									ServerInfo[MoneyNameCount]++;
									Light_ChangeToValue(TIDRAM_Money + Playanum, 0);

									//if (GetPort() == Zandronum)		if (!PlayerIsSpectator(PlayaNum))	ClientScript (PlayaNum, "MSG_NewMoneyAcc", 0, 0, 0);
									break;
									}


			}

}









function str ShowWinnerName (int Position)
{
int counter;
str Space 		= "";
str Result 		= "";
str NamePart 	= "";



		if (Position < 10)	Space = " ";
		else 				Space = "";




				int Header = (Position - 1)*GAMEINFO[MaxNameChars];

						While(counter < GAMEINFO[MaxNameChars])
							{
							NamePart = StrParam(s:NamePart, c:WinnerNames[Header + counter]);
							counter++;
							}

Result = StrParam(s:"STAGE ", s:Space, i:Position, s:".   ", s:NamePart, s:"\n");

return Result;
}











function void RenderLegends (void)
{
int counter, Source, Iteration, MonumentHeight, LocalStart, StartFrom;
str LegendName = "";
/*
if (GetPort() == Zandronum)
{
LegendNames[0] = 90;
LegendNames[1] = 69;
LegendNames[2] = 66;
LegendNames[3] = 69;
LegendNames[4] = 82;
LegendNames[5] = 80;
LegendNames[6] = 65;
LegendNames[7] = 76;
LegendNames[8] = 32;
LegendNames[9] = 32;
LegendNames[10] = 32;
LegendNames[11] = 32;

LegendNames[12] = 76;
LegendNames[13] = 79;
LegendNames[14] = 79;
LegendNames[15] = 80;
LegendNames[16] = 69;
LegendNames[17] = 82;
LegendNames[18] = 32;
LegendNames[19] = 32;
LegendNames[20] = 32;
LegendNames[21] = 32;
LegendNames[22] = 32;
LegendNames[23] = 32;

LegendNames[24] = 91;
LegendNames[25] = 77;
LegendNames[26] = 65;
LegendNames[27] = 82;
LegendNames[28] = 73;
LegendNames[29] = 78;
LegendNames[30] = 69;
LegendNames[31] = 71;
LegendNames[32] = 85;
LegendNames[33] = 89;
LegendNames[34] = 93;
LegendNames[35] = 32;
}
*/

Switch(GetPort()) //ZDA and ZAN seems to render scale from TEXTURES ina a different way.
	{
	CASE ZDaemon:	Source = LINETAG_ZDaemonLegends;	break;
	CASE Zandronum:	Source = LINETAG_ZandronumLegends;	break;
	}



While(Iteration < MaxLegends)
	{

	LegendName = "";
	MonumentHeight = 0;
	counter = 0;

Switch(GetPort()) //ZDA and ZAN seems to render scale from TEXTURES ina a different way.
	{
	CASE ZDaemon:	LocalStart = Iteration*(GAMEINFO[MaxNameChars]); 	break;
	CASE Zandronum:	LocalStart = Iteration*(GAMEINFO[MaxNameChars]);	break;
	}





	while(counter < GAMEINFO[MaxNameChars])
		{
		LegendName = StrParam(s:LegendName, c:LegendNames[LocalStart + Counter]);
		counter++;
		}

	LegendName = StringNoEdgeSpaces(LegendName);




			counter = 0;
			//Calculating MonumentHeight
			MonumentHeight = StrLen(LegendName);
			//Start Letter Placement at
			StartFrom = GAMEINFO[MaxNameChars] - MonumentHeight;




			//Now place the letters
					counter = 0;
					while(counter < MonumentHeight)
						{
												SetLineTexture(Source + LocalStart + StartFrom + counter, 											SIDE_FRONT,TEXTURE_MIDDLE, StrParam(s:"LETTR", i:LegendNames[LocalStart + counter]));
												SetLineTexture(Source + LocalStart + StartFrom + counter + (MaxLegends*GAMEINFO[MaxNameChars]), 	SIDE_FRONT,TEXTURE_MIDDLE, "LETTNULL");
												SetLineTexture(Source + LocalStart + StartFrom + counter + (MaxLegends*GAMEINFO[MaxNameChars]), 	SIDE_BACK, TEXTURE_MIDDLE, "LETTNULL");

						counter++;
						}

	iteration++;
	}


}










/*

  ______   ______     ______   .______             __        ______     _______  __    ______
 /      | /  __  \   /  __  \  |   _  \           |  |      /  __  \   /  _____||  |  /      |
|  ,----'|  |  |  | |  |  |  | |  |_)  |          |  |     |  |  |  | |  |  __  |  | |  ,----'
|  |     |  |  |  | |  |  |  | |   ___/           |  |     |  |  |  | |  | |_ | |  | |  |
|  `----.|  `--'  | |  `--'  | |  |               |  `----.|  `--'  | |  |__| | |  | |  `----.
 \______| \______/   \______/  | _|               |_______| \______/   \______| |__|  \______|


*/






function str LeadingZeros (int Value, int ZeroesCount)
{
    int i;
    str result = StrParam(d:Value);
    int len = StrLen(result);
    for (i=len; i<ZeroesCount; i++)
        result = StrParam(s:"0", s:result);
    return result;
}




function str ZDA_LogSeasonStage (void)
{
str Result;
if(ServerInfo[STAGE] > 0) Result = StrParam(s:"set SEASON ", s:LeadingZeros(ServerInfo[SEASON], 3), s:";", s:"set STAGE ", s:LeadingZeros(ServerInfo[STAGE], 2), s:";");
else Result = "";
return Result;
}

function str ZDA_LogWinners (void)
{
int counter;
str Result = "";
if(ServerInfo[STAGE] > 0)
	{

	while(counter < GAMEINFO[MaxNameChars]*MaxStages)
		{
		//Result = StrParam(s:Result, c:Crypt(Encrypt, WinnerNames[counter]));
		Result = StrParam(s:Result, c:WinnerNames[counter]);
		counter++;
		}

	Result = StrParam(s:"set Winners \"", s:Result, s:"\";");
	}





else Result = "";
return Result;
}

function str ZDA_LogLegends (void)
{
int counter;
str Result = "";
if(ServerInfo[STAGE] > 0)
	{

		while(counter < GAMEINFO[MaxNameChars]*MaxLegends)
		{
		//Result = StrParam(s:Result, c:Crypt(Encrypt, LegendNames[counter]));
		Result = StrParam(s:Result, c:LegendNames[counter]);
		counter++;
		}

	Result = StrParam(s:"set Legends \"", s:Result, s:"\";");
	}
else Result = "";
return Result;
}


function void ZDA_StatsInfo (void)
{
log(s:"------------------------------------\n------------------------------------\n---  STATS COMMAND FOR AN ADMIN  ---\n-just copy/paste it in RCON command line-\n------------------------------------\n------------------------------------");
log(s:"/", s:ZDA_LogSeasonStage(), s:"set TRY ", s:LeadingZeros(ServerInfo[TRY], 4), s:";", s:ZDA_LogWinners(), s:ZDA_LogLegends());
log(s:"\n------------------------------------\n------------------------------------");
}












Script "INFOLOGIC" (void)
{
int counter, EverySecond, EveryHalfSecond, IconCounter, BossMaxHealth, BossHealth;
str TimeIconChar = "",
	TimeLetter = "",
	AdventureIcon = "",
	EnemyPrint = "",
	CurrRoundChar = "",
	CurrRoundStr = "",
	StringA = "",
	StringB = "";

bool PrintHUD_TOP, PrintHUD_MID;
str FrameString = "aggggggggb\neiiiiiiiif\nchhhhhhhhd";

//A Zdaemon message to restore progress via console upon server restart, yeah clunky as f, but what can u do with an oldass port
if(GetPort() == ZDaemon)	ZDA_StatsInfo();



//Map loaded, waiting for someone to enter the game.
While(PlayerStatus(DOESNT_MATTER) <= ps_DEAD)	delay(1);

//delay(1);
SetPlayerProperty(1, false, PROP_TOTALLYFROZEN);
Set_AllGodmode(false);
//A player joined


ACS_NamedExecute("GAMELOGIC", 0);


While(PlayerStatus(DOESNT_MATTER) > ps_DEAD)
	{




	if(EveryHalfSecond > 0) EveryHalfSecond--;
	else

// This here will happen every half a sec
		{



			if(GAMESTATE > gs_IDLE)
				{
						//Print Scores
						if ((RoundInfo[CurrentRound] == GAMEINFO[RoundsCount]) && GAMESTATE == gs_END)	{}
						else SortPlayerScores(SPS_AlsoPrint);

						Switch(GAMESTATE)
						{
						CASE gs_IDLE:
						PrintHUD_TOP = false;	PrintHUD_MID = false;
						break;



						CASE gs_LOADING:
						PrintHUD_TOP = true;	PrintHUD_MID = true;
						CurrRoundChar = StrParam(c:ICON_Round);
						CurrRoundStr = StrParam(i:RoundInfo[CurrentRound], s:"/", i:GAMEINFO[RoundsCount]);
						TimeIconChar = StrParam(c:ICON_HEADER_Load + IconCounter);
						if (LoadBit >= RoundInfo[LoadSegments]) 	TimeLetter = "100%";
						else										TimeLetter = StrParam(i:((FixedDiv(Int2Fix(LoadBit), Int2Fix(RoundInfo[LoadSegments]))* 100) >> 16), s:"%");

						if (IconCounter < 3) IconCounter++;
						else IconCounter = 0;

						break;



						CASE gs_ACTIVE:
						CurrRoundChar = StrParam(c:ICON_Round);
						CurrRoundStr = StrParam(i:RoundInfo[CurrentRound], s:"/", i:GAMEINFO[RoundsCount]);
						if 	((AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_RAISE)	&& (RoundInfo[PlaygroundReached]) && ((!RoundInfo[CheckpointReached]) && (RoundInfo[CurrSubstanceHeight] < RoundInfo[MaxSubstanceHeight])))
								{
								TimeIconChar = 	StrParam(c:ICON_Substance);
								TimeLetter	 = 	StrParam(i:((FixedDiv(Int2Fix(RoundInfo[CurrSubstanceHeight]), Int2Fix(RoundInfo[MaxSubstanceHeight]))* 100) >> 16), s:"%");
								}
						else	{
								TimeIconChar = 	StrParam(c:ICON_HEADER_Clock + ((FixedDiv(Int2Fix(TimeLeft), Int2Fix(RoundInfo[TimeGiven]))* 100) >> 16)/10);
								TimeLetter	 = 	StrParam(s:TimeColor(TimeLeft), s:PrintClock(TimeLeft));
								}

							if(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_BOSS)
									{
										AdventureIcon = StrParam(c:ICON_Boss);
										EnemyPrint = StrParam(i:((FixedDiv(Int2Fix(GetActorProperty(ACTORTID_Boss, APROP_Health)), Int2Fix(AdventureInfo[RoundInfo[CurrentRound]][adv_BOSSMAXHP]))* 100) >> 16), s:"%");
										if (((FixedDiv(Int2Fix(GetActorProperty(ACTORTID_Boss, APROP_Health)), Int2Fix(AdventureInfo[RoundInfo[CurrentRound]][adv_BOSSMAXHP]))* 100) >> 16)	< 0)	EnemyPrint = "0%";
									}
							else
									{
									AdventureIcon = StrParam(c:ICON_EnemyCount);
									EnemyPrint = StrParam(i:ThingCount(0, ACTORTID_Enemy));
									}

						break;

						CASE gs_END:

							if ((RoundInfo[CurrentRound] == GAMEINFO[RoundsCount]) && GAMESTATE == gs_END)	//STAGE WIN
									{
									if (GAMEINFO[InputNameTime] > 0)	//if player in the input room
										{
										PrintHUD_TOP = true;	PrintHUD_MID = true;
										CurrRoundChar = StrParam(c:ICON_Exit);
										CurrRoundStr = StrParam(s:"INPUT");
										TimeIconChar = StrParam(c:ICON_Exit);
										TimeLetter = StrParam(s:PrintClock(GAMEINFO[InputNameTime]));
										}

									else
										{
										CurrRoundStr = StrParam(i:RoundInfo[CurrentRound], s:"/", i:GAMEINFO[RoundsCount]);
										PrintHUD_TOP = false;	PrintHUD_MID = false;
										}
									}

							else
									{
									PrintHUD_TOP = true;	PrintHUD_MID = true;
									TimeIconChar = StrParam(c:ICON_Exit);
									if (AccomplishType(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE]) == AccomplishByENEMYONLY)
																																	{
																																	TimeIconChar = StrParam(c:ICON_None);
																																	TimeLetter = StrParam(s:"");
																																	}

									else
																																	{
																																	TimeIconChar = StrParam(c:ICON_Exit);
																																	TimeLetter = StrParam(s:TimeColor(TimeLeft), s:PrintClock(TimeLeft));
																																	}
									}
						break;
						}



								SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, FALSE);

								/////////////////////////////////////TOP
							if (PrintHUD_TOP == true)
								{
								SetFont("ERICON");
								HudMessageBold(s:CurrRoundChar;	HUDMSG_FADEOUT, 				HUDid_TOP_ICON, COLORTEXT_MAIN, int2fix(X_TOP_ICON), int2fix(Y_TOP_ICON), 1.0, 1.0);
								SetFont("ERFONT");
								HudMessageBold(s:CurrRoundStr;	HUDMSG_FADEOUT, 				HUDid_TOP_LETTER, COLORTEXT_MAIN, int2fix(X_TOP_LETTER), int2fix(Y_TOP_LETTER), 1.0, 1.0);
								SetFont("ERICON");
								HudMessageBold(s:FrameString;	HUDMSG_FADEOUT|HUDMSG_ALPHA, 	HUDid_TOP_BACK, COLORTEXT_MAIN, int2fix(X_TOP_BACK), int2fix(Y_TOP_BACK), 1.0, 1.0, 0.5);
								}
								/////////////////////////////////////MIDDLE
							if (PrintHUD_MID == true)
								{
								SetFont("ERICON");
								HudMessageBold(s:TimeIconChar;	HUDMSG_FADEOUT, 				0, COLORTEXT_MAIN, int2fix(X_MIDDLE_ICON), int2fix(Y_MIDDLE_ICON), 1.0, 1.0);
								SetFont("ERFONT");
								HudMessageBold( s:TimeLetter;	HUDMSG_FADEOUT, 				HUDid_MIDDLE_LETTER, COLORTEXT_MAIN, int2fix(X_MIDDLE_LETTER), int2fix(Y_MIDDLE_LETTER), 1.0, 1.0);
								SetFont("ERICON");
								HudMessageBold(s:FrameString;	HUDMSG_FADEOUT|HUDMSG_ALPHA, 	HUDid_MIDDLE_BACK, COLORTEXT_MAIN, int2fix(X_MIDDLE_BACK), int2fix(Y_MIDDLE_BACK), 1.0, 1.0, 0.5);
								}
								if (GAMESTATE == gs_ACTIVE)
								{
								/////////////////////////////////////BOTTOM
								SetFont("ERICON");
								HudMessageBold(s:AdventureIcon;	HUDMSG_FADEOUT, 				HUDid_BOTTOM_ICON, COLORTEXT_MAIN, int2fix(X_BOTTOM_ICON), int2fix(Y_BOTTOM_ICON), 1.0, 1.0);
								SetFont("ERFONT");
								HudMessageBold(s:EnemyPrint ;	HUDMSG_FADEOUT, 				HUDid_BOTTOM_LETTER, COLORTEXT_MAIN, int2fix(X_BOTTOM_LETTER), int2fix(Y_BOTTOM_LETTER), 1.0, 1.0);
								SetFont("ERICON");
								HudMessageBold(s:FrameString;	HUDMSG_FADEOUT|HUDMSG_ALPHA,	HUDid_BOTTOM_BACK , COLORTEXT_MAIN, int2fix(X_BOTTOM_BACK), int2fix(Y_BOTTOM_BACK), 1.0, 1.0, 0.5);
								}





					if ((GAMESTATE > gs_LOADING)	&& (GetPort() == ZDaemon))		ZDA_Dmg2PlayerScore();

				}



		EveryHalfSecond = Sec/2;
		}




	if(EverySecond > 0) EverySecond--;
	else

// This here will happen every sec
		{
		if (GAMEINFO[InputNameTime] > BottomLine) GAMEINFO[InputNameTime]--;


		if(GAMESTATE > gs_LOADING)
			{
//////////////////////////////////////////////////////////////////////// DEMO VERSION
		if (GAMEINFO[DemoVersion] > 0)
				{
				if (GAMEINFO[DemoVersion] < DemoTime - 10)	DrawNotification(For_Everyone, StrParam(s:"DEMO WILL END IN...", s:PrintClock(GAMEINFO[DemoVersion] - 1)), notepose_TOP, notepara_ALIGN, ICON_Clock, StrParam(c:ICON_Clock), "j", "ERFONT",  OFF, ON, 0.0, 1.0, 1.0);
				if (GAMEINFO[DemoVersion] == 1)
							{
							SetPlayerProperty(1, true, PROP_TOTALLYFROZEN);		Set_AllGodmode(true);
							DemoMessage(0);
							ScreenFade (For_Everyone, BLACK, 2.0, 999.0, 0);

							while(true)	delay(SEC);
							}
				GAMEINFO[DemoVersion]--;
				}
/////////////////////////////////////////////////////////////////////////////////
				if(TimeLeft > BottomLine)
					{


						Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])
						{
						CASE adventure_MAZE:
						CASE adventure_LINEAR:

						if (RoundInfo[adventureCounter] > -1)
								{
								if (RoundInfo[adventureCounter] == 0)		SetWarmupBlockLines(FALSE);
								RoundInfo[adventureCounter]--;
								}
						break;

						CASE adventure_INVASION:

						if (RoundInfo[adventureCounter] > -1)
							{

							StringA = "WATCH OUT! AN INVASION IS EXPECTED IN...";
							DrawNotification(For_Everyone, StrParam(s:StringA, i:RoundInfo[adventureCounter]), notepose_TOP, notepara_ALIGN, ICON_None, StrParam(c:ICON_HEADER_Clock + ((FixedDiv(Int2Fix(RoundInfo[adventureCounter]), Int2Fix(InvasionStartTime))* 100) >> 16)/10), "j", "ERFONT",  OFF, ON, 0.0, 1.0, 1.0);

						if (RoundInfo[adventureCounter] == 0)
								{
									SetLineTexture(LINETAG_PlaygroundPerimeter, 	SIDE_FRONT, TEXTURE_MIDDLE, "-");
									Line_SetBlocking(LINETAG_PlaygroundPerimeter, None, BLOCKF_SIGHT);
									Line_SetBlocking(LINETAG_PlaygroundPerimeter, None, BLOCKF_EVERYTHING);
									Line_SetBlocking(LINETAG_PlaygroundPerimeter, BLOCKF_PLAYERS, 	None);
									Line_SetBlocking(LINETAG_PlaygroundPerimeter, None, BLOCKF_MONSTERS);
									//SetWarmupBlockLines(FALSE);
								}
							RoundInfo[adventureCounter]--;
							}
						break;



						CASE adventure_FLOW:

						if (RoundInfo[adventureCounter] > 1)
							{


							RoundInfo[adventureCounter]--;
							StringB = "";
							Switch(RoundInfo[MiniCheckpoint])
								{
								CASE 0:	StringB = "FOR THE FIRST TIME ";	break;
								CASE 1:	StringB = "FOR THE LAST TIME ";		break;
								}
							StringA = StrParam(s:"AREA WILL BE FLOODED ", s:StringB, s: "IN...");
							DrawNotification(For_Everyone, StrParam(s:StringA, i:RoundInfo[adventureCounter] - 1, s:"!"), notepose_TOP, notepara_ALIGN, ICON_None, StrParam(c:ICON_HEADER_Clock + ((FixedDiv(Int2Fix(RoundInfo[adventureCounter]), Int2Fix(FlowInverseTime))* 100) >> 16)/10), "j", "ERFONT",  OFF, ON, 0.0, 1.0, 1.0);
							}


						break;
						}






							Switch(GAMESTATE)
							{


								CASE gs_END:

									if ((AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_BOSS) || (RoundInfo[CurrentRound] >= GAMEINFO[RoundsCount]))	TimeLeft++;
									if (PlayerStatus(-1) == ps_HUB)	TimeLeft = BottomLine; // if everyone returned to hub no need to wait
									if (TimeLeft > PanicTime) TimeLeft = PanicTime;

								break;
							}



					if (!HoldTime)		TimeLeft--;

					GAMEINFO[MapTime]++;

					}






			}


		EverySecond = Sec;
		}




	delay(1);
	}


// MISSION FAILED


SetMusic("D_NONE");
AmbientSound("SFXFAIL", 127);



// RESET MAP
if (GAMEINFO[MapTime] > PanicTime)			ServerInfo[TRY]++;






StringA = "ERFONT"; StringB = "j";
//if  ((StrLen(GetCurrentGameMode()) == 8) && (GetChar(GetCurrentGameMode(), 1) == 85))		{	StringA = "SMALLFONT";	StringB = "g";	}
if  (GetPort() >= Zandronum)	if(GetCVar("Survival") == TRUE)		{	StringA = "SMALLFONT";	StringB = "g";}

DrawNotification(For_Everyone, StrParam(s:"PLAY TIME"), 		notepose_MID, notepara_CENTER, ICON_None, StrParam(c:ICON_None), 	StringB, StringA,  ON, ON, noteFadeIn_None, noteHold_Failed, noteFadeOut_Failed);
DrawNotification(For_Everyone, StrParam(s:PrintClock(GAMEINFO[MapTime])), notepose_BOT, notepara_CENTER, ICON_None, StrParam(c:ICON_None), 	StringB, StringA,  ON, ON, noteFadeIn_None, noteHold_Failed, noteFadeOut_Failed);


/*DEBUG if (ServerInfo[SEASON] > 0)*/
	{
	SetHUDSize(HUDX_MEDIUM,		HUDY_MEDIUM,	FALSE);			SetFont("ERFONT");
	HudMessageBold(s:"SEASON ", i:ServerInfo[SEASON], s:" WINNERS";	HUDMSG_FADEINOUT, 0, CR_WHITE, int2fix(HUDX_MEDIUM/2), int2fix(HUDY_MEDIUM/2), 3.0, 1.0, 1.0);
	HudMessageBold(s:ShowWinnerName(25), s:ShowWinnerName(24),s:ShowWinnerName(23), s:ShowWinnerName(22),s:ShowWinnerName(21),
				   s:ShowWinnerName(20), s:ShowWinnerName(19),s:ShowWinnerName(18), s:ShowWinnerName(17),s:ShowWinnerName(16),
				   s:ShowWinnerName(15), s:ShowWinnerName(14),s:ShowWinnerName(13), s:ShowWinnerName(12),s:ShowWinnerName(11),
				   s:ShowWinnerName(10), s:ShowWinnerName( 9),s:ShowWinnerName( 8), s:ShowWinnerName( 7),s:ShowWinnerName( 6),
				   s:ShowWinnerName( 5), s:ShowWinnerName( 4),s:ShowWinnerName( 3), s:ShowWinnerName( 2),s:ShowWinnerName( 1)
	;		HUDMSG_FADEINOUT, 0, CR_WHITE, int2fix(HUDX_MEDIUM/2), int2fix(HUDY_MEDIUM/2 + HUDY_MEDIUM/4), 3.0, 1.0, 1.0);
	}


if (GetPort() == Zandronum)		if (IsNetworkGame())		StoreMoneyInfo();

Light_ChangeToValue(TIDRAM_MapReset, TRUE);
delay(Sec*5);

MapReset();

terminate;



}







function int GetWinnerScore (int PlayerNum)
{
int result = RNG(1, 10000);
return Result;
}














Script "MSG_LateToJoin" (void) CLIENTSIDE
{
DrawNotification(For_ActivatorOnly, StrParam(s:"TOO LATE TO CONTINUE!"), 		notepose_BOT, notepara_ALIGN, ICON_Sad, StrParam(c:ICON_Sad), "g", "ERFONT",  OFF, ON, noteFadeIn_None, noteHold_Standart, noteFadeOut_Standart);
}




SCRIPT "ChangeMusic" (int Num) CLIENTSIDE
{
LocalSetMusic(StrParam(s:"D_MUS", i:Num));
}




function int BlockAt_to_BC (int Row, int Cmn)
{
int Result;
Switch (Row)
	{
	CASE 0:	Switch(Cmn)		{	CASE 0:Result =  1;break;CASE 1:Result =  2;break;CASE 2:Result =  3;break;CASE 3:Result =  4;break;CASE 4:Result =  5;break;CASE 5:Result =  6;break;CASE 6:Result =  7;break;	}	break;
	CASE 1:	Switch(Cmn)		{	CASE 0:Result =  8;break;CASE 1:Result =  9;break;CASE 2:Result = 10;break;CASE 3:Result = 11;break;CASE 4:Result = 12;break;CASE 5:Result = 13;break;CASE 6:Result = 14;break;	}	break;
	CASE 2:	Switch(Cmn)		{	CASE 0:Result = 15;break;CASE 1:Result = 16;break;CASE 2:Result = 17;break;CASE 3:Result = 18;break;CASE 4:Result = 19;break;CASE 5:Result = 20;break;CASE 6:Result = 21;break;	}	break;
	CASE 3:	Switch(Cmn)		{	CASE 0:Result = 22;break;CASE 1:Result = 23;break;CASE 2:Result = 24;break;CASE 3:Result = 25;break;CASE 4:Result = 26;break;CASE 5:Result = 27;break;CASE 6:Result = 28;break;	}	break;
	CASE 4:	Switch(Cmn)		{	CASE 0:Result = 29;break;CASE 1:Result = 30;break;CASE 2:Result = 31;break;CASE 3:Result = 32;break;CASE 4:Result = 33;break;CASE 5:Result = 34;break;CASE 6:Result = 35;break;	}	break;
	CASE 5:	Switch(Cmn)		{	CASE 0:Result = 36;break;CASE 1:Result = 37;break;CASE 2:Result = 38;break;CASE 3:Result = 39;break;CASE 4:Result = 40;break;CASE 5:Result = 41;break;CASE 6:Result = 42;break;	}	break;
	CASE 6:	Switch(Cmn)		{	CASE 0:Result = 43;break;CASE 1:Result = 44;break;CASE 2:Result = 45;break;CASE 3:Result = 46;break;CASE 4:Result = 47;break;CASE 5:Result = 48;break;CASE 6:Result = 49;break;	}	break;
	}
return Result;
}







#libdefine	GLP_Root			1
#libdefine	GLP_ContainerType	2
#libdefine	GLP_Direction		3
#libdefine	GLP_BorderXMethod	4
#libdefine	GLP_BorderYMethod	5
#libdefine	GLP_Stairs			6
#libdefine	GLP_BlockCounter	7
#libdefine	GLP_VecIn			8
#libdefine	GLP_VecOut			9
#libdefine	GLP_ElementTag		10
#libdefine	GLP_BlocksAmount	11

function int GetLayoutProperties	(int LayoutID, int What, int SnakeHeader)
{
int Result, 	Root, BlockCounter, VecIn, VecOut, ContainerType, Direction, BorderXMethod, BorderYMethod, Stairs, ElementTag, BlocksAmount;
bool ForceXwall, ForceYwall;



// The first and the last blocks should always have predefined rotation, and must be a OneBlock
Switch(LayoutID)
{
CASE 1:						//Snakey
BlocksAmount = 25;
	Switch(SnakeHeader)
	{
	CASE 1:  	Root = TRUE;	BlockCounter =  1;		ElementTag =  1;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = StartBlock;		Direction = ToRIGHT;				BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 2: 	Root = TRUE;	BlockCounter =  2;		ElementTag =  2;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 3:  	Root = FALSE;	BlockCounter =  3;		ElementTag =  2;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 4:  	Root = TRUE;	BlockCounter =  4;		ElementTag =  3;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 5:  	Root = TRUE;	BlockCounter =  5;		ElementTag =  4;	VecIn = ToRIGHT;	VecOut = ToDOWN;	ContainerType = TwoBlocks;		Direction = ToUP_or_ToDOWN;			BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 6:  	Root = FALSE;	BlockCounter = 10;		ElementTag =  4;	VecIn = ToDOWN;		VecOut = ToLEFT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 7:  	Root = FALSE;	BlockCounter =  9;		ElementTag =  5;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 8:  	Root = FALSE;	BlockCounter =  8;		ElementTag =  5;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 9:  	Root = TRUE;	BlockCounter =  7;		ElementTag =  5;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = ThreeBlocks;	Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 10:	Root = TRUE;	BlockCounter =  6;		ElementTag =  6;	VecIn = ToLEFT;		VecOut = ToDOWN;	ContainerType = TwoBlocks;		Direction = ToUP_or_ToDOWN;			BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 11:	Root = FALSE;	BlockCounter = 11;		ElementTag =  6;	VecIn = ToDOWN;		VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 12:  	Root = TRUE;	BlockCounter = 12;		ElementTag =  7;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 13:  	Root = TRUE;	BlockCounter = 13;		ElementTag =  8;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = ThreeBlocks;	Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 14:  	Root = FALSE;	BlockCounter = 14;		ElementTag =  8;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 15:  	Root = FALSE;	BlockCounter = 15;		ElementTag =  8;	VecIn = ToRIGHT;	VecOut = ToDOWN;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 16:  	Root = FALSE;	BlockCounter = 20;		ElementTag =  9;	VecIn = ToDOWN;		VecOut = ToLEFT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 17:  	Root = TRUE;	BlockCounter = 19;		ElementTag =  9;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = TwoBlocks;		Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 18:  	Root = FALSE;	BlockCounter = 18;		ElementTag = 10;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 19:  	Root = TRUE;	BlockCounter = 17;		ElementTag = 10;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = TwoBlocks;		Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 20:  	Root = TRUE;	BlockCounter = 16;		ElementTag = 11;	VecIn = ToLEFT;		VecOut = ToDOWN;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_wEntrance;	break;
	CASE 21:  	Root = TRUE;	BlockCounter = 21;		ElementTag = 12;	VecIn = ToDOWN;		VecOut = ToRIGHT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_wEntrance;	ForceXwall = TRUE;	break;
	CASE 22:  	Root = TRUE;	BlockCounter = 22;		ElementTag = 13;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_wEntrance;	ForceXwall = TRUE;	break;
	CASE 23:  	Root = TRUE;	BlockCounter = 23;		ElementTag = 14;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceXwall = TRUE;	break;
	CASE 24:  	Root = FALSE;	BlockCounter = 24;		ElementTag = 14;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_wEntrance;	ForceXwall = TRUE;	break;
	CASE 25: 	Root = TRUE;	BlockCounter = 25;		ElementTag = 15;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = FinishBlock;	Direction = ToRIGHT;				BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceXwall = TRUE;	ForceYwall = TRUE;	break;
	}
break;


CASE 2:						//Spiral
BlocksAmount = 25;
	Switch(SnakeHeader)
	{
	CASE 1:  	Root = TRUE;	BlockCounter =  1;		ElementTag =  1;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = StartBlock;		Direction = ToRIGHT;				BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 2: 	Root = TRUE;	BlockCounter =  2;		ElementTag =  2;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 3:  	Root = FALSE;	BlockCounter =  3;		ElementTag =  2;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 4:  	Root = TRUE;	BlockCounter =  4;		ElementTag =  3;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 5:  	Root = TRUE;	BlockCounter =  5;		ElementTag =  4;	VecIn = ToRIGHT;	VecOut = ToDOWN;	ContainerType = ThreeBlocks;	Direction = ToUP_or_ToDOWN;			BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 6:  	Root = FALSE;	BlockCounter = 10;		ElementTag =  4;	VecIn = ToDOWN;		VecOut = ToDOWN;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 7:  	Root = FALSE;	BlockCounter = 15;		ElementTag =  4;	VecIn = ToDOWN;		VecOut = ToDOWN;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 8:  	Root = TRUE;	BlockCounter = 20;		ElementTag =  5;	VecIn = ToDOWN;		VecOut = ToDOWN;	ContainerType = TwoBlocks;		Direction = ToUP_or_ToDOWN;			BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 9:  	Root = FALSE;	BlockCounter = 25;		ElementTag =  5;	VecIn = ToDOWN;		VecOut = ToLEFT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceXwall = TRUE;	ForceYwall = TRUE;	break;
	CASE 10:	Root = FALSE;	BlockCounter = 24;		ElementTag =  6;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_wEntrance;	ForceXwall = TRUE;	break;
	CASE 11:	Root = FALSE;	BlockCounter = 23;		ElementTag =  6;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceXwall = TRUE;	break;
	CASE 12:  	Root = TRUE;	BlockCounter = 22;		ElementTag =  6;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = ThreeBlocks;	Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceXwall = TRUE;	break;
	CASE 13:  	Root = FALSE;	BlockCounter = 21;		ElementTag =  7;	VecIn = ToLEFT;		VecOut = ToUP;		ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_wEntrance;	ForceXwall = TRUE;	break;
	CASE 14:  	Root = TRUE;	BlockCounter = 16;		ElementTag =  7;	VecIn = ToUP;		VecOut = ToUP;		ContainerType = TwoBlocks;		Direction = ToUP_or_ToDOWN;			BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_Full;		break;
	CASE 15:  	Root = FALSE;	BlockCounter = 11;		ElementTag =  8;	VecIn = ToUP;		VecOut = ToUP;		ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_Full;		break;
	CASE 16:  	Root = TRUE;	BlockCounter =  6;		ElementTag =  8;	VecIn = ToUP;		VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = ToUP_or_ToDOWN;			BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 17:  	Root = TRUE;	BlockCounter =  7;		ElementTag =  9;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = ThreeBlocks;	Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 18:  	Root = FALSE;	BlockCounter =  8;		ElementTag =  9;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 19:  	Root = FALSE;	BlockCounter =  9;		ElementTag =  9;	VecIn = ToRIGHT;	VecOut = ToDOWN;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_Full;		break;
	CASE 20:  	Root = TRUE;	BlockCounter = 14;		ElementTag = 10;	VecIn = ToDOWN;		VecOut = ToDOWN;	ContainerType = TwoBlocks;		Direction = ToUP_or_ToDOWN;			BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_Full;		break;
	CASE 21:  	Root = FALSE;	BlockCounter = 19;		ElementTag = 10;	VecIn = ToDOWN;		VecOut = ToLEFT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_Full;		break;
	CASE 22:  	Root = FALSE;	BlockCounter = 18;		ElementTag = 11;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 23:  	Root = TRUE;	BlockCounter = 17;		ElementTag = 11;	VecIn = ToLEFT;		VecOut = ToUP;		ContainerType = TwoBlocks;		Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 24:  	Root = TRUE;	BlockCounter = 12;		ElementTag = 12;	VecIn = ToUP;		VecOut = ToRIGHT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_wEntrance;	break;
	CASE 25: 	Root = TRUE;	BlockCounter = 13;		ElementTag = 13;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = FinishBlock;	Direction = ToRIGHT;				BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_Full;		break;
	}
break;
}




/*
  _  __      _        _          _              _         _              _          _                 _
 (_)/ _|  __| |_ __ _(_)_ _ ___ | |_  __ _ ___ | |_ ___  | |__  ___   __| |___ _ __| |___ _  _ ___ __| |
 | |  _| (_-<  _/ _` | | '_(_-< | ' \/ _` (_-< |  _/ _ \ | '_ \/ -_) / _` / -_) '_ \ / _ \ || / -_) _` |
 |_|_|   /__/\__\__,_|_|_| /__/ |_||_\__,_/__/  \__\___/ |_.__/\___| \__,_\___| .__/_\___/\_, \___\__,_|
                                                                              |_|         |__/
*/


if 	(
	(RoundInfo[StairsChance] >= 50)	&&
	//((ContainerType >= OneBlock) && (ContainerType < FourBlocks))
	(ContainerType < FourBlocks)
	)


	{


	Switch(VecIn)
		{
		CASE	ToRIGHT:
				Switch(VecOut)
						{
						CASE ToRIGHT: 	Stairs = Stairs_NORMAL;				if(ForceXwall == FALSE)	BorderXMethod = BorderFill_Full;		if(ForceYwall == FALSE)	BorderYMethod = BorderFill_wEntrance;	break;
						CASE ToDOWN: 	Stairs = Stairs_DIAGONAL_right;		if(ForceXwall == FALSE)	BorderXMethod = BorderFill_wEntrance;	if(ForceYwall == FALSE)	BorderYMethod = BorderFill_Full;		break;
						CASE ToLEFT: 	Stairs = None;						break;		// I M P O S S I B L E
						CASE ToUP:		Stairs = Stairs_DIAGONAL_left;		if(ForceXwall == FALSE)	BorderXMethod = BorderFill_Full;		if(ForceYwall == FALSE)	BorderYMethod = BorderFill_Full;		break;
						}
		break;
		CASE	ToDOWN:
				Switch(VecOut)
						{
						CASE ToRIGHT: 	Stairs = Stairs_DIAGONAL_left;		if(ForceXwall == FALSE)	BorderXMethod = BorderFill_Full;		if(ForceYwall == FALSE)	BorderYMethod = BorderFill_wEntrance;	break;
						CASE ToDOWN: 	Stairs = Stairs_NORMAL;				if(ForceXwall == FALSE)	BorderXMethod = BorderFill_wEntrance;	if(ForceYwall == FALSE)	BorderYMethod = BorderFill_Full;		break;
						CASE ToLEFT: 	Stairs = Stairs_DIAGONAL_right;		if(ForceXwall == FALSE)	BorderXMethod = BorderFill_Full;		if(ForceYwall == FALSE)	BorderYMethod = BorderFill_Full;		break;
						CASE ToUP: 		Stairs = None;						break;		// I M P O S S I B L E
						}
		break;
		CASE	ToLEFT:
				Switch(VecOut)
						{
						CASE ToRIGHT: 	Stairs = None;						break;		// I M P O S S I B L E
						CASE ToDOWN: 	Stairs = Stairs_DIAGONAL_left;		if(ForceXwall == FALSE)	BorderXMethod = BorderFill_wEntrance;	if(ForceYwall == FALSE)	BorderYMethod = BorderFill_wEntrance;	break;
						CASE ToLEFT: 	Stairs = Stairs_NORMAL;				if(ForceXwall == FALSE)	BorderXMethod = BorderFill_Full;		if(ForceYwall == FALSE)	BorderYMethod = BorderFill_wEntrance;	break;
						CASE ToUP: 		Stairs = Stairs_DIAGONAL_right;		if(ForceXwall == FALSE)	BorderXMethod = BorderFill_Full;		if(ForceYwall == FALSE)	BorderYMethod = BorderFill_wEntrance;	break;
						}
		break;
		CASE	ToUP:
				Switch(VecOut)
						{
						CASE ToRIGHT: 	Stairs = Stairs_DIAGONAL_right;		if(ForceXwall == FALSE)	BorderXMethod = BorderFill_wEntrance;	if(ForceYwall == FALSE)	BorderYMethod = BorderFill_wEntrance;	break;
						CASE ToDOWN: 	Stairs = None;						break;		// I M P O S S I B L E
						CASE ToLEFT: 	Stairs = Stairs_DIAGONAL_left;		if(ForceXwall == FALSE)	BorderXMethod = BorderFill_wEntrance;	if(ForceYwall == FALSE)	BorderYMethod = BorderFill_Full;		break;
						CASE ToUP: 		Stairs = Stairs_NORMAL;				if(ForceXwall == FALSE)	BorderXMethod = BorderFill_wEntrance;	if(ForceYwall == FALSE)	BorderYMethod = BorderFill_Full;		break;
						}
		break;
		}




/*

								if ((Stairs == Stairs_NORMAL) && (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_LINEAR) && (RNG(0,1) > 0)) 	//If there is an inverted route setting
										{


										Switch(VecIn)
											{
											CASE ToRIGHT: 	VecIn = ToLEFT; 	break;
											CASE ToDOWN: 	VecIn = ToUP; 		break;
											CASE ToLEFT: 	VecIn = ToRIGHT; 	break;
											CASE ToUP: 		VecIn = ToDOWN; 	break;
											}

										Switch(VecOut)
											{
											CASE ToRIGHT: 	VecOut = ToLEFT; 	break;
											CASE ToDOWN: 	VecOut = ToUP; 		break;
											CASE ToLEFT: 	VecOut = ToRIGHT; 	break;
											CASE ToUP: 		VecOut = ToDOWN; 	break;
											}

										RoundInfo[InvertedStairs] = TRUE;
										}


*/




	if (Stairs != None)
			{


			if (RoundInfo[InvertedRoute] == true) 	//If there is an inverted route setting
					{


					Switch(VecIn)
						{
						CASE ToRIGHT: 	VecIn = ToLEFT; 	break;
						CASE ToDOWN: 	VecIn = ToUP; 		break;
						CASE ToLEFT: 	VecIn = ToRIGHT; 	break;
						CASE ToUP: 		VecIn = ToDOWN; 	break;
						}

					Switch(VecOut)
						{
						CASE ToRIGHT: 	VecOut = ToLEFT; 	break;
						CASE ToDOWN: 	VecOut = ToUP; 		break;
						CASE ToLEFT: 	VecOut = ToRIGHT; 	break;
						CASE ToUP: 		VecOut = ToDOWN; 	break;
						}

					Switch(Stairs)
						{
						CASE Stairs_DIAGONAL_right: 	Stairs = Stairs_DIAGONAL_left; 		break;
						CASE Stairs_DIAGONAL_left: 		Stairs = Stairs_DIAGONAL_right; 	break;
						}




					int tempVecIn = VecOut; int tempVecOut = VecIn;
						VecIn = tempVecIn; 		VecOut = tempVecOut;




					}



			Direction = VecIn;
			ContainerType = OneBlock;	//STAIRS are always a OneBlock




					//if(ContainerType == OneBlock)
								Switch(VecIn)
									{
									CASE	ToRIGHT:
											Switch(VecOut)
													{
													CASE ToRIGHT: 	RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = StairsHeight;	break;
													CASE ToDOWN: 	RoundInfo[AddBorderEntryHeightX] = StairsHeight;	RoundInfo[AddBorderEntryHeightY] = None;			break;
													CASE ToLEFT: 	RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													CASE ToUP:		RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													}
									break;
									CASE	ToDOWN:
											Switch(VecOut)
													{
													CASE ToRIGHT: 	RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = StairsHeight;	break;
													CASE ToDOWN: 	RoundInfo[AddBorderEntryHeightX] = StairsHeight;	RoundInfo[AddBorderEntryHeightY] = None;			break;
													CASE ToLEFT: 	RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													CASE ToUP:		RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													}
									break;
									CASE	ToLEFT:
											Switch(VecOut)
													{
													CASE ToRIGHT: 	RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													CASE ToDOWN: 	RoundInfo[AddBorderEntryHeightX] = StairsHeight;	RoundInfo[AddBorderEntryHeightY] = None;			break;
													CASE ToLEFT: 	RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													CASE ToUP: 		RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													}
									break;
									CASE	ToUP:
											Switch(VecOut)
													{
													CASE ToRIGHT: 	RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = StairsHeight;	break;
													CASE ToDOWN: 	RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													CASE ToLEFT: 	RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													CASE ToUP: 		RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													}
									break;
									}




			}

	}

if(Stairs == None)	{RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;	}






















if (RoundInfo[InvertedRoute] == true) 	//If there is an inverted route setting
		{
					Switch(ContainerType)
						{
						CASE StartBlock: 		ContainerType = FinishBlock; 	break;
						CASE FinishBlock: 		ContainerType = StartBlock; 	break;
						}
		}




			if (Direction == 0) 				Direction = RNG(1,4);

	else	if (Direction == ToRIGHT_or_ToLEFT)	if (RNG(0,1) == false)	Direction = ToRIGHT;	else Direction = ToLEFT;
	else	if (Direction == ToUP_or_ToDOWN)	if (RNG(0,1) == false)	Direction = ToUP; 		else Direction = ToDOWN;










Switch(What)
		{
		CASE GLP_Root:				Result = Root;				break;
		CASE GLP_ContainerType: 	Result = ContainerType;		break;
		CASE GLP_Direction: 		Result = Direction;			break;
		CASE GLP_BorderXMethod:		Result = BorderXMethod;		break;
		CASE GLP_BorderYMethod:		Result = BorderYMethod;		break;
		CASE GLP_Stairs:			Result = Stairs;			break;
		CASE GLP_BlockCounter:		Result = BlockCounter;		break;
		CASE GLP_VecIn:				Result = VecIn;				break;
		CASE GLP_VecOut:			Result = VecOut;			break;
		CASE GLP_ElementTag:		Result = ElementTag;		break;
		CASE GLP_BlocksAmount:		Result = BlocksAmount;		break;
		}


return Result;
}












int InputNameTurn, InputHeader;

int LayoutID = 0;				int SnakeHeader = 0;			int OldElementTag = 0;		int ElementTag = 0;			int VecIn = 0;
int VecOut = 0;					int Stairs = 0;					int BorderXmethod = 0;		int BorderYmethod = 0;		int ListCounter = 0;
int ContainerRoot = 0;			int Zpecial = 0;





#libdefine BOSS_RootBlockCounter 7
#libdefine BOSS_PlaygroundBlocks 9

#libdefine GLPB_BlockCounter 	0
#libdefine GLPB_BorderXMethod 	1
#libdefine GLPB_BorderYMethod 	2

function int GetLayoutPropertiesBoss	(int Counter, int ReturnWhat)
{
int Result, BlockCounter;
Switch(counter)
		{
		CASE 1:		BlockCounter = BOSS_RootBlockCounter;									BorderXMethod	=	BorderFill_wEntrance;		BorderYMethod	=	BorderFill_wEntrance;		break;
		CASE 2:		BlockCounter = BOSS_RootBlockCounter + 1;								BorderXMethod	=	BorderFill_wEntrance;		BorderYMethod	=	BorderFill_wEntrance;		break;
		CASE 3:		BlockCounter = BOSS_RootBlockCounter + 2;								BorderXMethod	=	BorderFill_wEntrance;		BorderYMethod	=	BorderFill_Full;			break;
		CASE 4:		BlockCounter = BOSS_RootBlockCounter + 0 + sqrt(PlaygroundBlocks);		BorderXMethod	=	BorderFill_wEntrance;		BorderYMethod	=	BorderFill_wEntrance;		break;
		CASE 5:		BlockCounter = BOSS_RootBlockCounter + 1 + sqrt(PlaygroundBlocks);		BorderXMethod	=	BorderFill_wEntrance;		BorderYMethod	=	BorderFill_wEntrance;		break;
		CASE 6:		BlockCounter = BOSS_RootBlockCounter + 2 + sqrt(PlaygroundBlocks);		BorderXMethod	=	BorderFill_wEntrance;		BorderYMethod	=	BorderFill_Full;			break;
		CASE 7:		BlockCounter = BOSS_RootBlockCounter + 0 + sqrt(PlaygroundBlocks)*2;	BorderXMethod	=	BorderFill_Full;			BorderYMethod	=	BorderFill_wEntrance;		break;
		CASE 8:		BlockCounter = BOSS_RootBlockCounter + 1 + sqrt(PlaygroundBlocks)*2;	BorderXMethod	=	BorderFill_Full;			BorderYMethod	=	BorderFill_wEntrance;		break;
		CASE 9:		BlockCounter = BOSS_RootBlockCounter + 2 + sqrt(PlaygroundBlocks)*2;	BorderXMethod	=	BorderFill_Full;			BorderYMethod	=	BorderFill_Full;			break;
		}

Switch(ReturnWhat)
	{
	CASE GLPB_BlockCounter:		Result = BlockCounter;	break;
	CASE GLPB_BorderXMethod:	Result = BorderXMethod;	break;
	CASE GLPB_BorderYMethod:	Result = BorderYMethod;	break;
	}

return Result;
}






/*

  _______      ___      .___  ___.  _______           __        ______     ______   .______
 /  _____|    /   \     |   \/   | |   ____|         |  |      /  __  \   /  __  \  |   _  \
|  |  __     /  ^  \    |  \  /  | |  |__            |  |     |  |  |  | |  |  |  | |  |_)  |
|  | |_ |   /  /_\  \   |  |\/|  | |   __|           |  |     |  |  |  | |  |  |  | |   ___/
|  |__| |  /  _____  \  |  |  |  | |  |____          |  `----.|  `--'  | |  `--'  | |  |
 \______| /__/     \__\ |__|  |__| |_______|         |_______| \______/   \______/  | _|


*/

Script "GAMELOGIC" (void)
{
int BlockCounter = 0;			int ContainerType = 0;			int Direction = 0;			int ColumnNum = 0;			int RowNum = 0;
int ContainerTry = 0;			int counter = 0;
int a = 0;						int b = 0;						//int c = 0;


LoadBit = 0;


bool ForceAutoName = false;
str StringA = "";
str StringB = "";

GAMESTATE = gs_LOADING;

RoundInfo[CheckpointReached] = FALSE;
RoundInfo[PlaygroundReached] = FALSE;

RoundInfo[LoadSegments] = PlaygroundBlocks*2;	//Clears and deploys
//if (RoundInfo[CurrentRound] > 1)
//ChangeCamera(ACTORTID_DebugCamera, 1, 1);





/*
  ___             _      ___                   _
 | _ \___ ___ ___| |_   / __|___ ___ _ __  ___| |_ _ _ _  _
 |   / -_|_-</ -_)  _| | (_ / -_) _ \ '  \/ -_)  _| '_| || |
 |_|_\___/__/\___|\__|  \___\___\___/_|_|_\___|\__|_|  \_, |
                                                       |__/

*/





			{


//---------- SET IT ALWAYS !------------------------------------------------

			//ACTORS
			Thing_Deactivate	(ACTORTID_Enemy);
			Thing_Deactivate	(ACTORTID_Boss);
			Thing_Remove		(ACTORTID_Enemy);
			Thing_Remove		(ACTORTID_Boss);





			//HUB
			PortalVisuals(OFF);

			Light_ChangeToValue(TIDRAM_ExitMarkerA, FALSE);
			Light_ChangeToValue(TIDRAM_ExitMarkerB, FALSE);



//---------- SET IT JUST ONCE !------------------------------------------------





			if (RoundInfo[MiniCheckPoint] == 0)
					{
					LayoutID = RNG(1,2);
					//Change Textures, Fog, etc
					SetAtmosphere(RoundInfo[CurrentRound]);
					RoundInfo[GlobalCeilingHeight] 	= AdventureCeilingHeight();
					RoundInfo[GlobalFloorHeight] 	= DefaultFloorHeight;
					RoundInfo[AddBorderEntryHeightX] = None;
					RoundInfo[AddBorderEntryHeightY] = None;
					RoundInfo[InvertedStairs] = None;
					RoundInfo[CurrFloorHeight] = None;
					RoundInfo[PitFloorHeight]	=	DefaultPitFloorHeight;
					RoundInfo[PitCeilingHeight]	=	DefaultPitCeilingHeight;

					//SetOutsideLines(LINETAG_PlaygroundFence, 		OFF, "-");
					//SetOutsideLines(LINETAG_PlaygroundPerimeter,	OFF, "-");

					//Ouside Lines
					SetLineTexture(LINETAG_PlaygroundPerimeter, SIDE_BACK, TEXTURE_BOTTOM,	TextureIs(WallEDGEtx));
					SetLineTexture(LINETAG_PlaygroundPerimeter, SIDE_BACK, TEXTURE_TOP, 	TextureIs(WallEDGEtx));
					SetLineTexture(LINETAG_PlaygroundPerimeter, SIDE_FRONT, TEXTURE_MIDDLE, "-");
					SetLineTexture(LINETAG_PlaygroundFence, 	SIDE_FRONT, TEXTURE_MIDDLE, "-");
					Line_SetBlocking(LINETAG_PlaygroundPerimeter, None,	BLOCKF_SIGHT);
					Line_SetBlocking(LINETAG_PlaygroundPerimeter, None,	BLOCKF_EVERYTHING);
					Line_SetBlocking(LINETAG_PlaygroundPerimeter, None,	BLOCKF_CREATURES);
					Line_SetBlocking(LINETAG_PlaygroundFence, 	  None, BLOCKF_CREATURES);


					if (GetPort() > ZDaemon)
						{
						Thing_Remove		(ACTORTID_AmbientSound);
						Thing_Remove		(ACTORTID_AmbientWater);
						}

					SetWarmupBlockLines(FALSE);
					}




//---------- SET IT ALWAYS !------------------------------------------------


			RoundInfo[adventureCounter] = 0;
			ListCounter = 0;
			SetPlaygroundColor();

			//RoundInfo[StartpointTAG] 	= ImpossibleNum;
			//RoundInfo[FinishpointTAG] 	= ImpossibleNum;



			/* DEBUG */




			FillArea(0, DOESNT_MATTER, DOESNT_MATTER, DOESNT_MATTER, DOESNT_MATTER, DOESNT_MATTER, DOESNT_MATTER, DOESNT_MATTER);


			//Refresh Border Exceptions for projectiles
			//-------------------------------------------------------------------
			ACS_NamedTerminate("Projectiles", 0);	Thing_Remove(ACTORTID_Projectile);
			for(a = 0; a < ProjectilaSlots; a++)	for(b = 0; b < ProjectilaParams; b++)	Projectila[a][b] = 0;
			RoundInfo[BorderExceptionCounter] = 0;

			// Clear items
			ACS_NamedTerminate("Items", 0);			//Thing_Remove(ACTORTID_Projectile);

			for(a = 0; a <= RoundInfo[SectorItemCounter]; a++)	for(b = 0; b < SectorItemParams; b++)	{	Thing_Remove(ACTORTID_DynamicTid + SectorItem [a][si_SECTOR]);		SectorItem [a][b] = 0;		}
			RoundInfo[SectorItemCounter] = 0;



/*
			RoundInfo[WeaponSpawnerCounter] 	= RoundInfo[WeaponSpawnerQueue];
			RoundInfo[MoneySpawnerCounter] 		= RoundInfo[MoneySpawnerQueue];
			RoundInfo[HealthSpawnerCounter] 	= RoundInfo[HealthSpawnerQueue];
			RoundInfo[AmmoSpawnerCounter] 		= RoundInfo[AmmoSpawnerQueue];
*/
			//-------------------------------------------------------------------
			while(BlockCounter < PlaygroundBlocks)
				{
				counter = 1;
				BlockCounter++;
				if (RoundInfo[MiniCheckPoint] == 0)		ClearBlockTextures (BlockCounter);

//////////////////// OUTSIDE SECTORS /////////////////////////////////////////////////
					if (BlockCounterAtTheEdge(ToRIGHT,  BlockCounter) == TRUE)
								{
								delay(	SetArea 		(area_FLOOR, 							BlockCounter, ToRIGHT, 	1, 	8,  9,  9, RoundInfo[PitFloorHeight], 		"F_SKY1", SectorSpecial_CLEAR));
								delay(	SetArea 		(area_CEILING, 							BlockCounter, ToRIGHT, 	1, 	8,  9,  9, RoundInfo[GlobalCeilingHeight], 	"F_SKY1", None));				//RoundInfo[PitCeilingHeight]
								b = 8;
								}
					else b = 9;

					if (BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)
								{
								delay(	SetArea 		(area_FLOOR, 							BlockCounter, ToRIGHT, 	9, 	9,  1,  8, RoundInfo[PitFloorHeight], 		"F_SKY1", SectorSpecial_CLEAR));
								delay(	SetArea 		(area_CEILING, 							BlockCounter, ToRIGHT, 	9, 	9,  1,  8, RoundInfo[GlobalCeilingHeight], 	"F_SKY1", None));				//RoundInfo[PitCeilingHeight]
								a = 8;
								}
					else a = 9;
////////////////////MAIN SECTORS /////////////////////////////////////////////////
					while(counter <= a)
						{
						delay(	SetArea 		(area_FLOOR, 							BlockCounter, ToRIGHT, 	counter, 	counter,  1,  b, RoundInfo[GlobalFloorHeight], 		TextureIs(FlatBASEtx), SectorSpecial_CLEAR));
						delay(	SetArea 		(area_CEILING, 							BlockCounter, ToRIGHT, 	counter, 	counter,  1,  b, RoundInfo[GlobalCeilingHeight], 	TextureIs(CeilBASEtx), None));
						counter ++;
						}


				loadbit++;
				}
			counter = 0;
			BlockCounter = 0;
			SetSectorVisual(SECTORTAG_pit);

			}









//LOADING


			delay(SEC*2);
					// -----
			/* DEBUG */	//ChangeCamera(ACTORTID_DebugCamera, 1, 1);










/*
  _____             _                 _                          _                 _                      _
 |  __ \           | |               | |                /\      | |               | |                    | |
 | |  | | ___ _ __ | | ___  _   _    | |__  _   _      /  \   __| |_   _____ _ __ | |_ _   _ _ __ ___    | |_ _   _ _ __   ___
 | |  | |/ _ \ '_ \| |/ _ \| | | |   | '_ \| | | |    / /\ \ / _` \ \ / / _ \ '_ \| __| | | | '__/ _ \   | __| | | | '_ \ / _ \
 | |__| |  __/ |_) | | (_) | |_| |   | |_) | |_| |   / ____ \ (_| |\ V /  __/ | | | |_| |_| | | |  __/   | |_| |_| | |_) |  __/
 |_____/ \___| .__/|_|\___/ \__, |   |_.__/ \__, |  /_/    \_\__,_| \_/ \___|_| |_|\__|\__,_|_|  \___|    \__|\__, | .__/ \___|
             | |             __/ |           __/ |                                                             __/ | |
             |_|            |___/           |___/                                                             |___/|_|
-----------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------
*/

Switch(LayoutType(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE]))
		{

			/*
			  _                            _         ____      _    _   _ ____   ___  __  __
			 | |    __ _ _   _  ___  _   _| |_      |  _ \    / \  | \ | |  _ \ / _ \|  \/  |
			 | |   / _` | | | |/ _ \| | | | __|     | |_) |  / _ \ |  \| | | | | | | | |\/| |
			 | |__| (_| | |_| | (_) | |_| | |_      |  _ <  / ___ \| |\  | |_| | |_| | |  | |
			 |_____\__,_|\__, |\___/ \__,_|\__|     |_| \_\/_/   \_\_| \_|____/ \___/|_|  |_|
						 |___/
			*/
			CASE	LayoutType_Random:

				RoundInfo[InvertedRoute] = FALSE;

				Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])
						{
						CASE adventure_MAZE:	RoundInfo[StartpointTAG] = RNG(1, PlaygroundBlocks/2);	break;

						CASE adventure_INVASION:
						RoundInfo[StartpointTAG] = RNG(1,4);
						Switch(RoundInfo[StartpointTAG])
								{
								CASE 1:	break;
								CASE 2:	break;
								CASE 3:	RoundInfo[StartpointTAG] = sqrt(PlaygroundBlocks) + 1;	break;
								CASE 4:	RoundInfo[StartpointTAG] = sqrt(PlaygroundBlocks) + 2;	break;
								}
						break;

						}


				While(BlockCounter < PlaygroundBlocks)
				{


					while(BlockCounter < (sqrt(PlaygroundBlocks)*(RowNum + 1)) )		//Checking this row

							{


								BlockCounter++;

								if(StrLen(BlockAt[RowNum][ColumnNum]) <= 1) // if this block is vacant

											{
											delay(10);
											ContainerTry = 0;






											While(ContainerTry < MaxContainerTries)
												{
													Direction 		= RNG(1,4);

															if (BlockCounter >= RoundInfo[StartpointTAG])	ContainerType 	= OneBlock;		//FORCE A TELEPORT BLOCK
													else 	if (ContainerTry == MaxContainerTries - 1)		ContainerType 	= OneBlock;
													else 													ContainerType 	= RNG(1, 4);	//AllowedContainerTypes);



													if (CheckArea(ContainerType, Direction, RowNum, ColumnNum) == true)
														{

															/*
															  ___                             _   _
															 | _ \_ _ ___ _ __  __ _ _ _ __ _| |_(_)___ _ _  ___
															 |  _/ '_/ -_) '_ \/ _` | '_/ _` |  _| / _ \ ' \(_-<
															 |_| |_| \___| .__/\__,_|_| \__,_|\__|_\___/_||_/__/
																		 |_|

															*/

															FillArea(1, ContainerType, Direction, RowNum, ColumnNum, NONE, NONE, NONE);
															RoundInfo[OptEntranceX] = false;
															RoundInfo[OptEntranceY] = RNG(false, true);


															/*
															   ___         _        _                ___             _
															  / __|___ _ _| |_ __ _(_)_ _  ___ _ _  | _ ) ___ _ _ __| |___ _ _ ___
															 | (__/ _ \ ' \  _/ _` | | ' \/ -_) '_| | _ \/ _ \ '_/ _` / -_) '_(_-<
															  \___\___/_||_\__\__,_|_|_||_\___|_|   |___/\___/_| \__,_\___|_| /__/


															*/



															FillContainerBorders(ContainerType, BlockCounter, Direction);
															Delay(GenDel_Border);
															/*
															   ___         _        _                 ___
															  / __|___ _ _| |_ __ _(_)_ _  ___ _ _   / __|___ _ _ ___
															 | (__/ _ \ ' \  _/ _` | | ' \/ -_) '_| | (__/ _ \ '_/ -_)
															  \___\___/_||_\__\__,_|_|_||_\___|_|    \___\___/_| \___|


															*/

															Deploying = true;

																	if (BlockCounter >= RoundInfo[StartpointTAG])	ACS_NamedExecuteAlways("TELEPORTBLOCK", 0, BlockCounter, Direction, StartBlock);
																	else											ACS_NamedExecuteAlways(StrParam(s:"DEPLOY_", i:ContainerSet(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE], ContainerType)), 0, BlockCounter, Direction);

															While(Deploying == true) delay(1);
															/*
															  __  __ ___ ___  ___
															 |  \/  |_ _/ __|/ __|
															 | |\/| || |\__ \ (__
															 |_|  |_|___|___/\___|

															*/


															LoadBit	+=	ContainerType;


															ContainerTry = MaxContainerTries;
														}

													else ContainerTry++;


												}





											}



								ColumnNum++;

							}
				RowNum++;
				ColumnNum = 0;


				}

				RoundInfo[FinishpointTAG] = RoundInfo[StartpointTAG];





		break;








			/*
			  _                            _         ______   __   _____ _   _ _____    _     ___ ____ _____
			 | |    __ _ _   _  ___  _   _| |_      | __ ) \ / /  |_   _| | | | ____|  | |   |_ _/ ___|_   _|
			 | |   / _` | | | |/ _ \| | | | __|     |  _ \\ V /     | | | |_| |  _|    | |    | |\___ \ | |
			 | |__| (_| | |_| | (_) | |_| | |_      | |_) || |      | | |  _  | |___   | |___ | | ___) || |
			 |_____\__,_|\__, |\___/ \__,_|\__|     |____/ |_|      |_| |_| |_|_____|  |_____|___|____/ |_|
						 |___/
			*/

			CASE	LayoutType_ByTheList:

					//---------------------------------------------------------------------------------------------------------
					if (RoundInfo[MiniCheckpoint] == 0)									RoundInfo[InvertedRoute] = RNG(false, true);

					if (RoundInfo[MiniCheckpoint] >	 0)
											{
											if (RoundInfo[InvertedRoute] == false)		RoundInfo[InvertedRoute] = TRUE;
											else										RoundInfo[InvertedRoute] = FALSE;
											}

					//---------------------------------------------------------------------------------------------------------





					Switch(RoundInfo[InvertedRoute])
						{
						CASE FALSE:		SnakeHeader = 0;					break;
						CASE TRUE:		SnakeHeader = PlaygroundBlocks + 1; break;
						}




						While(ListCounter < GetLayoutProperties(LayoutID, GLP_BlocksAmount,	DOESNT_MATTER) )
						{


							ListCounter++;
							Zpecial = None;



						Switch(RoundInfo[InvertedRoute])
							{
							CASE FALSE:		SnakeHeader++;	OldElementTag 	=	GetLayoutProperties(LayoutID, GLP_ElementTag, 	SnakeHeader - 1);	break;
							CASE TRUE:		SnakeHeader--;	OldElementTag 	=	GetLayoutProperties(LayoutID, GLP_ElementTag, 	SnakeHeader + 1);	break;
							}

						//------ Retrieving the Layout's Information -----------------------------------------------------------------------------------------------------------------------

								ElementTag		=	GetLayoutProperties(LayoutID, GLP_ElementTag, 	SnakeHeader	   );


								if ((ElementTag != OldElementTag))	// REFRESH STAIRS CHANCE, if switching to new element
								Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])
									{
									CASE  adventure_RAISE: 	RoundInfo[StairsChance] = RNG(40,	100);	break;	//always use stair blocks if it's possible
									CASE  adventure_LINEAR: RoundInfo[StairsChance] = RNG(0, 	60);	break;  //randomize stair blocks
									CASE  adventure_FLOW:	RoundInfo[StairsChance] = RNG(50, 	100);	break;  //fake stairs to use diagonals
									}
								ContainerRoot	=	GetLayoutProperties(LayoutID, GLP_Root,				SnakeHeader);
								VecIn			=	GetLayoutProperties(LayoutID, GLP_VecIn,			SnakeHeader);
								VecOut			=	GetLayoutProperties(LayoutID, GLP_VecOut,			SnakeHeader);
								ContainerType	=	GetLayoutProperties(LayoutID, GLP_ContainerType,	SnakeHeader);
								BlockCounter	=	GetLayoutProperties(LayoutID, GLP_BlockCounter, 	SnakeHeader);
								Direction		= 	GetLayoutProperties(LayoutID, GLP_Direction, 		SnakeHeader);
								Stairs 			= 	GetLayoutProperties(LayoutID, GLP_Stairs,	 		SnakeHeader);
								BorderXMethod	=	GetLayoutProperties(LayoutID, GLP_BorderXMethod,	SnakeHeader);
								BorderYMethod	=	GetLayoutProperties(LayoutID, GLP_BorderYMethod,	SnakeHeader);

						//---------------------------------------------------------------------------------------------------------------------------------

//ChangeCamera(BlockCounter*100 + 24, 1, 1);
								/*
								   ___ ___  _  _ _____ _   ___ _  _ ___ ___     ___  ___  ___ ___  ___ ___  ___
								  / __/ _ \| \| |_   _/_\ |_ _| \| | __| _ \   | _ )/ _ \| _ \   \| __| _ \/ __|
								 | (_| (_) | .` | | |/ _ \ | || .` | _||   /   | _ \ (_) |   / |) | _||   /\__ \
								  \___\___/|_|\_| |_/_/ \_\___|_|\_|___|_|_\   |___/\___/|_|_\___/|___|_|_\|___/

								*/

									RoundInfo[OptEntranceX] = RNG(true,false);		RoundInfo[OptEntranceY] = RNG(true,false);
									SetBorderWall (BorderSideX, BorderXMethod, BlockCounter, Direction);
									SetBorderWall (BorderSideY, BorderYMethod, BlockCounter, Direction);
									Delay(GenDel_Border);



					//If CONTAINER SPACE IS FREE, then deploying it ===========================================================================================





								Deploying = true;





														if ((RoundInfo[StairsChance] >= 50) && (ContainerType < SpecialBlocks))	//If game chose it to be Stairs block. It won't need the
																{


																	if (ContainerType < FourBlocks)
																			{


																						if ((CheckArea( OneBlock, Direction, BlockAtAXIS(AxisY, BlockCounter), BlockAtAXIS(AxisX, BlockCounter)) == true))	//even if forces to be stairs, this block should be free at first.

																							{


																									if (Stairs != None) 		//if there is an actual ladder block
																										{

																													Zpecial = Stairs;

																															Switch(Stairs)
																															{
																															CASE	Stairs_NORMAL:			a = 101;	b = 101;
																															if (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_FLOW)		{a = 501;	b = 501;}
																															ACS_NamedExecuteAlways(StrParam(s:"DEPLOY_", i:RNG(a, b)), 0, BlockCounter, Direction);			break;


																															CASE	Stairs_DIAGONAL_left:	a = 102;	b = 102;
																															if (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_FLOW)		{a = 502;	b = 502;}
																															ACS_NamedExecuteAlways(StrParam(s:"DEPLOY_", i:RNG(a, b)), 0, BlockCounter, Direction);			break;

																															CASE	Stairs_DIAGONAL_right:	a = 103;	b = 103;
																															if (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_FLOW)		{a = 503;	b = 503;}
																															ACS_NamedExecuteAlways(StrParam(s:"DEPLOY_", i:RNG(a, b)), 0, BlockCounter, Direction);			break;
																															}
																										}


																									else						//if it can't be a stair block, but already preassigned as a stair block, just fill it with the basic OneBlock
																										{

																										ACS_NamedExecuteAlways(StrParam(s:"DEPLOY_", i:ContainerSet(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE], OneBlock)), 0, BlockCounter, Direction);

																										}



																							FillArea(1, OneBlock, Direction, BlockAtAXIS(AxisY, BlockCounter), BlockAtAXIS(AxisX, BlockCounter), VecIn, VecOut, Zpecial);

																							}

																						// else skip
																			}


																else
																					{
																					if (ContainerRoot == TRUE)
																							{


																								//	if 		((CheckArea( ContainerType, Direction, BlockAtAXIS(AxisY, BlockCounter), BlockAtAXIS(AxisX, BlockCounter)) == true))	//If there is enough space for the container
																											//{
																											ACS_NamedExecuteAlways(StrParam(s:"DEPLOY_", i:ContainerSet(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE], ContainerType)), 0, BlockCounter, Direction);
																											FillArea(1, ContainerType, Direction, BlockAtAXIS(AxisY, BlockCounter), BlockAtAXIS(AxisX, BlockCounter), VecIn, VecOut, Zpecial);
																											//}
																							}
																					}


																}

														else //if that's a usual ContainerSet

																{

																	if (ContainerRoot == TRUE)	 //If a pointer is at the Container Root
																		{


																				if (ContainerType >= SpecialBlocks)
																							{
																							//RoundInfo[CurrFloorHeight] += 128;
																							Switch(ContainerType)
																									{
																									case	StartBlock:			ACS_NamedExecuteAlways("TELEPORTBLOCK", 0, BlockCounter, Direction, StartBlock);			break;
																									case	FinishBlock:		ACS_NamedExecuteAlways("TELEPORTBLOCK", 0, BlockCounter, Direction, FinishBlock);			break;
																									}

																							Zpecial = ContainerType;
																							FillArea(1, OneBlock, Direction, BlockAtAXIS(AxisY, BlockCounter), BlockAtAXIS(AxisX, BlockCounter), VecIn, VecOut, Zpecial);
																							}


																				else
																							{



																							if 		((CheckArea( ContainerType, Direction, BlockAtAXIS(AxisY, BlockCounter), BlockAtAXIS(AxisX, BlockCounter)) == true))	//If there is enough space for the container
																										{
																										//RoundInfo[CurrFloorHeight] += 128;

																										ACS_NamedExecuteAlways(StrParam(s:"DEPLOY_", i:ContainerSet(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE], ContainerType)), 0, BlockCounter, Direction);
																										FillArea(1, ContainerType, Direction, BlockAtAXIS(AxisY, BlockCounter), BlockAtAXIS(AxisX, BlockCounter), VecIn, VecOut, Zpecial);
																										}

																							else if ((CheckArea( OneBlock, Direction, BlockAtAXIS(AxisY, BlockCounter), BlockAtAXIS(AxisX, BlockCounter)) == true)) //okay then if there is not enough space, does it at least allow to place One Block in the ruined container space?
																										{
																										//RoundInfo[CurrFloorHeight] += 128;

																										ACS_NamedExecuteAlways(StrParam(s:"DEPLOY_", i:ContainerSet(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE], OneBlock)), 0, BlockCounter, Direction);
																										FillArea(1, OneBlock, Direction, BlockAtAXIS(AxisY, BlockCounter), BlockAtAXIS(AxisX, BlockCounter), VecIn, VecOut, Zpecial);
																										}

																							}



																				//else just skip the whole thing

																		}


																	else if (ContainerRoot == FALSE)  //If a pointer is at the Minor counter
																		{
																		Deploying = false;
																		//log(s:"SKIP BLOCK ", i:Blockcounter);

																			if (ElementTag == OldElementTag) // if staying in the same element
																					{
																					//just keep going
																					}


																			if (ElementTag != OldElementTag) // and if entering the new Element
																					{
																					//just keep going as well
																					}



																		}


																}





						Delay(5);

						While(Deploying == true) delay(1);



						//======================================================================================================================================================


						LoadBit++;
						}





			break;



			/*
			  _                            _         ____   ___  ____ ____
			 | |    __ _ _   _  ___  _   _| |_      | __ ) / _ \/ ___/ ___|
			 | |   / _` | | | |/ _ \| | | | __|     |  _ \| | | \___ \___ \
			 | |__| (_| | |_| | (_) | |_| | |_      | |_) | |_| |___) |__) |
			 |_____\__,_|\__, |\___/ \__,_|\__|     |____/ \___/|____/____/
						 |___/
			*/

			CASE	LayoutType_Boss:

			LoadBit += sqrt(PlaygroundBlocks) - BOSS_PlaygroundBlocks;
			ContainerType = OneBlock;
			RoundInfo[OptEntranceX] = TRUE;		RoundInfo[OptEntranceY] = TRUE;

			//RoundInfo[StartpointTAG] = RNG(BlockCounter_Boss(1), BlockCounter_Boss(PlaygroundBlocksBOSS));
			//SET TELEPORT
			Switch(RNG(1,4))
					{
					CASE 1: RoundInfo[StartpointTAG] = GetLayoutPropertiesBoss(1, GLPB_BlockCounter);	break;
					CASE 2: RoundInfo[StartpointTAG] = GetLayoutPropertiesBoss(3, GLPB_BlockCounter);	break;
					CASE 3: RoundInfo[StartpointTAG] = GetLayoutPropertiesBoss(7, GLPB_BlockCounter);	break;
					CASE 4: RoundInfo[StartpointTAG] = GetLayoutPropertiesBoss(9, GLPB_BlockCounter);	break;
					}


				//-----UP AND LEFT BORDER-----------------------------------------------------------------------
					counter = 0;
					while (counter < 3)
							{
							counter++;
							SetBorderWall (BorderSideX, BorderFill_Full, counter + 1,							ToRIGHT);
							}
					counter = 0;
					while (counter < 3)
							{
							counter++;
							SetBorderWall (BorderSideY, BorderFill_Full, counter*sqrt(PlaygroundBlocks) + 1,	ToRIGHT);
							}
				//--------------------------------------------------------------------------------------


			while (ListCounter < BOSS_PlaygroundBlocks)
					{
					Listcounter++;
					BlockCounter = GetLayoutPropertiesBoss(Listcounter, GLPB_BlockCounter);
					Direction = RNG(1,4);

					//Container Borders -----------------------------------------------------------------


					SetBorderWall (BorderSideX, GetLayoutPropertiesBoss(Listcounter, GLPB_BorderXMethod), BlockCounter, Direction);
					SetBorderWall (BorderSideY, GetLayoutPropertiesBoss(Listcounter, GLPB_BorderYMethod), BlockCounter, Direction);
					Delay(GenDel_Border);
					//-----------------------------------------------------------------------------------


					// Placing a container
					Deploying = true;

					if (BlockCounter >= RoundInfo[StartpointTAG])	ACS_NamedExecuteAlways("TELEPORTBLOCK", 0, BlockCounter, Direction, StartBlock);
					else											ACS_NamedExecuteAlways(StrParam(s:"DEPLOY_", i:ContainerSet(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE], ContainerType)), 0, BlockCounter, Direction);

					While(Deploying == true) 	delay(1);


					LoadBit++;
					}


			break;



		}

//--------------------------------------------------------------------
//---------------------------CHECKPOINT LOCATION SWITCHING



if (AdventureInfo[RoundInfo[CurrentRound]][adv_MINICHECKPOINTS] > 0)
		{


				if (RoundInfo[MiniCheckPoint] == 0)
					{
					RoundInfo[MiniStartpoint]		=		ImpossibleNum;
					RoundInfo[MiniFinishpoint]		= 		RoundInfo[FinishpointTag];
					//---------------------------------------------------------------------
					//RoundInfo[StartpointTag]		=		STAYS THE SAME
					RoundInfo[FinishpointTag]		=		ImpossibleNum;
					}

		else 	if ((RoundInfo[MiniCheckPoint] > 0)	&& 	(RoundInfo[MiniCheckPoint] < AdventureInfo[RoundInfo[CurrentRound]][adv_MINICHECKPOINTS]))
					{
					RoundInfo[MiniStartpoint]		=		RoundInfo[StartpointTag];
					RoundInfo[MiniFinishpoint]		= 		RoundInfo[FinishpointTag];
					//---------------------------------------------------------------------
					RoundInfo[StartpointTag]		=		ImpossibleNum;
					RoundInfo[FinishpointTag]		=		ImpossibleNum;
					}


		else 	if (RoundInfo[MiniCheckPoint] == AdventureInfo[RoundInfo[CurrentRound]][adv_MINICHECKPOINTS])
					{
					RoundInfo[MiniStartpoint]		=		RoundInfo[StartpointTag];
					RoundInfo[MiniFinishpoint]		= 		ImpossibleNum;
					//---------------------------------------------------------------------
					RoundInfo[StartpointTag]		=		ImpossibleNum;
					//RoundInfo[FinishpointTag]		=		STAYS THE SAME
					}



//for(a = 1; a <= PlaygroundBlocks; a++)	ClearBlockTextures (a);

counter = 0;
while (counter < PlaygroundBlocks)
		{
		counter++;
		ClearBlockTextures (counter);
		delay(gendel_Height);
		}



		}



// if that's a normal, no minicheckpoints round
else
		{
		//RoundInfo[StartpointTag]		=		STAYS THE SAME
		//RoundInfo[FinishpointTag]		=		STAYS THE SAME
		RoundInfo[MiniStartpoint] 		= 		ImpossibleNum;
		RoundInfo[MiniFinishpoint] 		= 		ImpossibleNum;
		}

//--------------------------------------------------------------------
//--------------------------------------------------------------------



/*
     _              _     _            _     ____                        _
    / \   _ __ ___ | |__ (_) ___ _ __ | |_  / ___|  ___  _   _ _ __   __| |___
   / _ \ | '_ ` _ \| '_ \| |/ _ \ '_ \| __| \___ \ / _ \| | | | '_ \ / _` / __|
  / ___ \| | | | | | |_) | |  __/ | | | |_   ___) | (_) | |_| | | | | (_| \__ \
 /_/   \_\_| |_| |_|_.__/|_|\___|_| |_|\__| |____/ \___/ \__,_|_| |_|\__,_|___/

*/
	if 	 (((GetPort() == ZDaemon) && (RoundInfo[CurrentRound] == 1)) || (GetPort() > ZDaemon))

		{
			if (RoundInfo[MiniCheckPoint] == 0)
					{
					a = TagAt ( 7, ToRIGHT, 28);		RefreshSpotHeight(refreshspot_DEFAULT, a);			SpawnSpotForced("MapSpot", a, ACTORTID_AmbientSound, 0);
					a = TagAt ( 9, ToRIGHT, 28);		RefreshSpotHeight(refreshspot_DEFAULT, a);			SpawnSpotForced("MapSpot", a, ACTORTID_AmbientSound, 0);
					a = TagAt (17, ToRIGHT, 28);		RefreshSpotHeight(refreshspot_DEFAULT, a);			SpawnSpotForced("MapSpot", a, ACTORTID_AmbientSound, 0);
					a = TagAt (19, ToRIGHT, 28);		RefreshSpotHeight(refreshspot_DEFAULT, a);			SpawnSpotForced("MapSpot", a, ACTORTID_AmbientSound, 0);
																											SpawnSpotForced("MapSpot", ACTORTID_AmbientSpot, 	ACTORTID_AmbientSound, 0);

					SoundSequenceOnActor(ACTORTID_AmbientSound, 			StrParam(s:"AmbientSequence", i:GAMEINFO[Mood], i:RNG(1,3)));
					}
		}


//---------------------------------------------------------------------




			Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])
				{
				CASE adventure_BOSS:


							//SetActorProperty(ACTORTID_Boss, APROP_SpawnHealth, a);
							SpawnSpotForced("Demon", 1314, ACTORTID_Boss, 0);
							SetActorProperty(ACTORTID_Boss, APROP_Health, AdventureInfo[RoundInfo[CurrentRound]][adv_BOSSMAXHP]);
							log(s:"BOSS SPAWNED ", i:IsTIDUsed(ACTORTID_Boss));

				break;


				CASE adventure_MAZE:	break;
				CASE adventure_LINEAR:

							RoundInfo[adventureCounter] = InvasionStartTime/2;
							//DRAW TEXTURES
							SetWarmupBlockLines(TRUE);

				break;
				CASE adventure_RAISE:
							RoundInfo[TimeGiven] = 99999;
							//OBTAINING VARIOUS HEIGHTS------------------------------------------------------------------------------------------------
							RoundInfo[PitFloorHeight]		=	GetSectorFloorZ(SECTORTAG_pit, 0, 0) >> 16;								//Obtaining a pit floor height
							RoundInfo[SubstanceLineOffset]	= 	(abs(RoundInfo[PitFloorHeight]) + RoundInfo[GlobalCeilingHeight])* -1;	//Preparing an offset for the Substance line textures;
							RoundInfo[MaxSubstanceHeight]	=	GetSectorFloorZ(RoundInfo[FinishpointTAG], 0, 0) >> 16;					//Obtaining a physical height for the substance to reach
							RoundInfo[AbsSubstanceHeight]	=	RoundInfo[MaxSubstanceHeight] + abs(RoundInfo[PitFloorHeight]);			//Obtaining the absolute range of the substance movement. Important to define difficulty and speed.
							RoundInfo[CurrSubstanceHeight] 	= 	RoundInfo[PitFloorHeight];												//Set dummy Damage Height
							//RoundInfo[SubstanceMoveDelay]	=	SetSubstanceSpeed();														//Set Substance Speed
							//log(s:"ABS HEIGHT IS ", i:RoundInfo[AbsSubstanceHeight]);
							//SET SUBSTANCE LINES TEXTURE AND OFFSET-----------------------------------------------------------------------------------
							for (a = 1; a <= PlaygroundBlocks;  a++)
								{
								SetLineTexture(a, SIDE_FRONT, TEXTURE_MIDDLE, TextureIs (WallRAIStx));
								SetLineTexture(a, SIDE_BACK, TEXTURE_MIDDLE, TextureIs (WallRAIStx));
								Line_SetTextureOffset(a, NO_CHANGE, int2fix(RoundInfo[SubstanceLineOffset]), SIDE_FRONT, TEXFLAG_MIDDLE);
								Line_SetTextureOffset(a, NO_CHANGE, int2fix(RoundInfo[SubstanceLineOffset]), SIDE_BACK, TEXFLAG_MIDDLE);
								}
							//-------------------------------------------------------------------------------------------------------------------------



				break;

				CASE adventure_INVASION:

							RoundInfo[adventureCounter] = InvasionStartTime;
							//DRAW TEXTURES
							//SetOutsideLines(LINETAG_PlaygroundFence, 		ON, TextureIs (WallFENCtx));
							//SetOutsideLines(LINETAG_PlaygroundPerimeter,	ON, TextureIs (WallFENCtx));
							SetLineTexture(LINETAG_PlaygroundPerimeter, SIDE_FRONT, TEXTURE_MIDDLE, TextureIs(WallEDGEtx));
							SetLineTexture(LINETAG_PlaygroundFence, 	SIDE_FRONT, TEXTURE_MIDDLE, TextureIs (WallFENCtx));
							Line_SetBlocking(LINETAG_PlaygroundPerimeter, 	BLOCKF_SIGHT, None);
							Line_SetBlocking(LINETAG_PlaygroundPerimeter, 	BLOCKF_EVERYTHING, None);
							Line_SetBlocking(LINETAG_PlaygroundFence, 		BLOCKF_CREATURES, None);



							//////////////////
							//  C O L U M N //
							//////////////////
							counter = 0;
							while(counter < sqrt(PlaygroundBlocks))
									{
									counter++;
									/*
											   __
									  ___ ___ / /_   ___ ________ ___ _
									 (_-</ -_) __/  / _ `/ __/ -_) _ `/
									/___/\__/\__/   \_,_/_/  \__/\_,_/
																				-------------------------------------------------------------
									*/
									delay(	SetArea 	(area_FLOOR, 	ContainerInfo(InfoType_ORDER, OneBlock, 1, counter * sqrt(PlaygroundBlocks), ToRIGHT), ToRIGHT, 	1, 	8,  9,  9, RoundInfo[GlobalFloorHeight], 	TextureIs(FlatSECOtx), None));


									/*
											   __
									  ___ ___ / /_    ___ ___  ___ __ _  __ __
									 (_-</ -_) __/   / -_) _ \/ -_)  ' \/ // /
									/___/\__/\__/    \__/_//_/\__/_/_/_/\_, /
																	   /___/  	-------------------------------------------------------------
									*/
									a = 64;	b = 0;
									while(a < 72)
										{
										if (b > 0) b--;
										else 	{
												delay(	SetEnemy (ContainerInfo(InfoType_ORDER, OneBlock, 1, counter * sqrt(PlaygroundBlocks), ToRIGHT), ToRIGHT, 	a, ANG_to_LEFT,  		0	+ RandomRange(20)));
												if (AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY] < 33 )																				b = 1;
												else if ((AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY] >= 33 ) && (AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY] < 66 ))		b = RNG(0,1);
												else																																			b = 0;
												}

										a++;
										}


									}

							//////////////////
							//     R O W    //
							//////////////////

							counter = PlaygroundBlocks - sqrt(PlaygroundBlocks);
							while(counter < PlaygroundBlocks)
									{
									counter++;
									/*
											   __
									  ___ ___ / /_   ___ ________ ___ _
									 (_-</ -_) __/  / _ `/ __/ -_) _ `/
									/___/\__/\__/   \_,_/_/  \__/\_,_/
																				-------------------------------------------------------------
									*/
									delay(	SetArea 	(area_FLOOR, 	ContainerInfo(InfoType_ORDER, OneBlock, 1, counter, ToRIGHT), ToRIGHT, 	9, 	9,  1,  8, RoundInfo[GlobalFloorHeight], 	TextureIs(FlatSECOtx), None));


									/*
											   __
									  ___ ___ / /_    ___ ___  ___ __ _  __ __
									 (_-</ -_) __/   / -_) _ \/ -_)  ' \/ // /
									/___/\__/\__/    \__/_//_/\__/_/_/_/\_, /
																	   /___/  	-------------------------------------------------------------
									*/
									a = 73;	b = 0;
									while(a < 81)
										{
										if (b > 0) b--;
										else 	{
												delay(	SetEnemy (ContainerInfo(InfoType_ORDER, OneBlock, 1, counter, ToRIGHT), ToRIGHT, 	a, ANG_to_UP,  		0	+ RandomRange(20)));
												if (AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY] < 33 )																				b = 1;
												else if ((AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY] >= 33 ) && (AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY] < 66 ))		b = RNG(0,1);
												else																																			b = 0;
												}
										a++;
										}


									}

				break;



				CASE adventure_FLOW:

				if (RoundInfo[MiniCheckPoint] == 0)
						{
						for(a = 0; a < PlaygroundBlocks; a+=2)		{
																	RefreshSpotHeight(refreshspot_DEFAULT, TagAt (a + 1, ToRIGHT, 28));
																	SpawnSpotForced("MapSpot", TagAt (a + 1, ToRIGHT, 28), ACTORTID_AmbientWater, 0);
																	}

																	if (GetPort() > ZDaemon)	SoundSequenceOnActor(ACTORTID_AmbientWater, 	"AmbientSequenceWater");
						}



				break;


				}






				/*else*/ /* DEBUG */	//SpawnSpotForced("DoomImp", 230, ACTORTID_Enemy, 0);
				/* DEBUG */	delay(SEC*1);

				ACS_NamedExecute("Projectiles", 0);
				ACS_NamedExecute("Items", 0);
				ACS_NamedExecute("RandomEvent", 0, AdventureInfo[RoundInfo[CurrentRound]][adv_RANDOMEVENT]);


				if (RoundInfo[MiniCheckPoint] == 0)
					{
					RoundInfo[TimeGiven] = 365;
					TimeLeft = JoinTime;

					}



/*
  ____  _____ __  __  ___                     _   _  ___  ____  __  __    _    _
 |  _ \| ____|  \/  |/ _ \      ___  _ __    | \ | |/ _ \|  _ \|  \/  |  / \  | |
 | | | |  _| | |\/| | | | |    / _ \| '__|   |  \| | | | | |_) | |\/| | / _ \ | |
 | |_| | |___| |  | | |_| |   | (_) | |      | |\  | |_| |  _ <| |  | |/ ___ \| |___
 |____/|_____|_|  |_|\___/     \___/|_|      |_| \_|\___/|_| \_\_|  |_/_/   \_\_____|

*/
/*
if (!GAMEINFO[DemoVersion])
{

Switch(GetPort())
		{
		CASE ZDaemon:		if (!Netmode())			GAMEINFO[DemoVersion] = TRUE;				break;
		CASE Zandronum:		if (!IsNetworkGame())	GAMEINFO[DemoVersion] = TRUE;				break;
		CASE GZDoom:								GAMEINFO[DemoVersion] = TRUE;				break;
		}

if (GAMEINFO[DemoVersion] == 1)
		{
		GAMEINFO[DemoVersion] = DemoTime;
		}
}

*/










/*
     _    ____ _____ _____     _______       ____    _    __  __ _____
    / \  / ___|_   _|_ _\ \   / / ____|     / ___|  / \  |  \/  | ____|
   / _ \| |     | |  | | \ \ / /|  _|      | |  _  / _ \ | |\/| |  _|
  / ___ \ |___  | |  | |  \ V / | |___     | |_| |/ ___ \| |  | | |___
 /_/   \_\____| |_| |___|  \_/  |_____|     \____/_/   \_\_|  |_|_____|

*/



			//HUB
			PortalVisuals(ON);

			ACS_NamedTerminate("MCR_KillWhileDeploying", 0);

			if (RoundInfo[CurrentRound] == 1)
					if (RoundInfo[MiniCheckPoint] == 0)
							DrawNotification(For_Everyone, StrParam(s:StrToUpper(CreateLocationName())), notepose_MID, notepara_ALIGN, ICON_Location, StrParam(c:ICON_Location), "j", "ERFONT",  ON, ON, noteFadeIn_long, noteHold_Short, noteFadeOut_Short);



if (RoundInfo[MiniCheckPoint] == 0)

			{
			Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])
				{
				CASE adventure_BOSS:
						Switch(RNG(1,3)){CASE 1:	StringA = "KILL "; break;						CASE 2:	StringA = "DESTROY "; break;					CASE 3:	StringA = "BEAT "; break;	}
						StringA = StrParam(s: StringA, s:"THE BOSS!");

				break;

				CASE adventure_MAZE:
						Switch(RNG(1,3)){CASE 1:	StringA = "CLEAR OFF OF "; break;				CASE 2:	StringA = "DESTROY "; break;					CASE 3:	StringA = "GET RID OF "; break;	}
						Switch(RNG(1,3)){CASE 1:	StringB = "GET BACK "; break;		 			CASE 2:	StringB = "FALL BACK "; break;		 			CASE 3:	StringB = "RETURN "; break;	}
						StringA = StrParam(s: StringA, s:"ALL ENEMIES AND ", s:StringB, s:"TO PORTAL!");
				break;

				CASE adventure_LINEAR:
						Switch(RNG(1,3)){CASE 1:	StringA = "FIGHT THROUGH THE "; break;			CASE 2:	StringA = "DESTROY THE "; break;				CASE 3:	StringA = "LEAVE NO "; break;	}
						Switch(RNG(1,3)){CASE 1:	StringB = "REACH "; break;		 				CASE 2:	StringB = "FIND "; break;		 				CASE 3:	StringB = "MAKE IT TO "; break;	}
						StringA = StrParam(s: StringA, s:"ENEMIES, AND ", s:StringB, s:"THE CHECKPOINT!");
				break;

				CASE adventure_RAISE:
						Switch(RNG(1,3)){CASE 1:	StringA = "CLIMB "; break;		 				CASE 2:	StringA = "MAKE YOUR WAY "; break;		 		CASE 3:	StringA = "GO "; break;	}
						StringA = StrParam(s: StringA, s:"TO THE TOP, BEFORE ", s:FailTextureName(), s:" GETS YOU!");
				break;

				CASE adventure_INVASION:
						StringA = "";
						// see INFOLOGIC
				break;

				CASE adventure_FLOW:
						Switch(RNG(1,3)){CASE 1:	StringA = "RIDE "; break;						CASE 2:	StringA = "FOLLOW "; break;						CASE 3:	StringA = "SURF "; break;	}
						Switch(RNG(1,4)){CASE 1:	StringB = "STAY SHARP!"; break;					CASE 2:	StringB = "DON'T SLOW DOWN!"; break;			CASE 3:	StringB = "KEEP YOUR EYES OPEN!"; break;	CASE 4:	StringB = "AVOID THE OBSTACLES!"; break;}
						StringA = StrParam(s: StringA, s:"THE FLOW AND ", s:StringB);
				break;
				}

			DrawNotification(For_Everyone, StringA, notepose_TOP, notepara_ALIGN, ICON_Mission, StrParam(c:ICON_Mission), "j", "ERFONT",  ON, ON, noteFadeIn_Standart, noteHold_Standart, noteFadeOut_Standart);
			}






			a = 0; 		b = 0;
			GAMESTATE = gs_ACTIVE;













			While(GAMESTATE == gs_ACTIVE)
				{

					if(PlayerStatus(-1) <= ps_DEAD) Terminate;	 //if everyone "died" then terminate whole script,





									counter = 0;
									While(counter < MaxPlayers)
										{


											if (RoundInfo[CheckpointReached] == FALSE)
												{

														if 	(
															((AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] != adventure_BOSS)	&& (ThingCount(0, ACTORTID_Enemy) <= 0))	|
															((AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_BOSS)	&& (ThingCount(0, ACTORTID_Boss)  <= 0))
															)

															{
																	//If current round requires to beat the enemy and they were beaten then switch to gamestate gs_END immidiatelly
																	if 	(AccomplishType(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE]) == AccomplishByENEMYONLY)
																								{
																								RoundInfo[CheckpointReached] = TRUE;
																								GAMESTATE = gs_END;
																								//log(s:"a");
																								}





																	else	 	//or else if there is a checkpoint that has to be reached, and someone first did it // if (AccomplishType(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE]) == AccomplishByTELEPORT)
																		{
																		if (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_MAZE)
																			{
																			if 	(GetSectorLightLevel(TIDRAM_ExitMarkerA) == 0)	Light_ChangeToValue(TIDRAM_ExitMarkerA, RoundInfo[FinishpointTag]/100);
																			if 	(GetSectorLightLevel(TIDRAM_ExitMarkerB) == 0)	Light_ChangeToValue(TIDRAM_ExitMarkerB, RoundInfo[FinishpointTag] - (GetSectorLightLevel(TIDRAM_ExitMarkerA)*100));
																			}


																		//log(s:"A ", i:GetSectorLightLevel(TIDRAM_ExitMarkerA));
																		//log(s:"B ", i:GetSectorLightLevel(TIDRAM_ExitMarkerB));

																				if (PlayerCheckpoint[counter] == RoundInfo[CurrentRound])
																					{
																					//RoundInfo[CheckpointReached] = TRUE;

																							// If First Player to reach Mini Checkpoint, then
																							if (CheckActorPosition(PLAYER_TID + counter, pos_ByActorPos, PlayerDiameter, RoundInfo[MiniFinishpoint], 0, 0, 0) == true)
																									{
																									RoundInfo[CheckpointReached] = TRUE;
																									RoundInfo[AdventureCounter] = FlowInverseTime;
																									}





																							// If First Player to reach a normal Checkpoint
																							else if (CheckActorPosition(PLAYER_TID + counter, pos_ByActorPos, PlayerDiameter, RoundInfo[FinishpointTAG], 0, 0, 0) == true)
																									{
																									RoundInfo[CheckpointReached] = TRUE;
																									RoundInfo[CheckpointWinner] = counter;
																									PlayerCheckpoint[counter] = RoundInfo[CurrentRound] + 1;
																									ClientScript (counter, "DrawSky", OFF, 0, 0);
																									//if (RoundInfo[CurrentRound] < GAMEINFO[RoundsCount])
																												{
																												TeleportOther(PLAYER_TID + counter, ACTORTID_Hub + counter, true);
																												StringA = StripColors(StrParam(n:counter + 1));

																												b = StrLen(StringA);
																												if (b > 20)
																													{
																													a = 0;	StringB = "";
																													while (a < 20 - 2)
																														{
																														StringB = StrParam(s:StringB, c:GetChar(StringA, a));
																														a++;
																														}
																													StringA = StrParam(s:StringB, s:"..");
																													}


																												DrawNotification(For_Everyone, StrParam(s:StringA, s:" made it to the checkpoint!"), notepose_TOP, notepara_ALIGN, ICON_Checkmark, StrParam(c:ICON_Checkmark), "j", "ERFONT",  ON, ON, noteFadeIn_Short, noteHold_Short, noteFadeOut_Short);
																												}

																									a = 0;
																									while (a < MaxPlayers)
																											{
																															//exclude the Checkpoint winner
																											if (a != RoundInfo[CheckpointWinner])
																													if (PlayerStatus(a) == ps_PLAYGROUND)
																														{
																														ClientScript (a, "MSG_Hurry", AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE], 0, 0);
																														//if ((AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE]) == adventure_MAZE)		ClientScript (a, "MSG_ExitMarker", RoundInfo[FinishpointTag], 0, 0);
																														}

																											a++;
																											}
																									GAMESTATE = gs_END;




																									}

																					}

																		}
																}




												}














														// Player is too slow at the FLOW adventure ---------------------------------------------------------------------------------------------------------------------
														if((PlayerStatus(counter) == ps_PLAYGROUND) && (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_FLOW))
																{
																if 	(
																	(CheckActorPosition(PLAYER_TID + counter, pos_ByActorPos, 320, RoundInfo[MiniStartpoint],		0, 0, 0) == false) &&
																	(CheckActorPosition(PLAYER_TID + counter, pos_ByActorPos, 320, RoundInfo[MiniFinishpoint],		0, 0, 0) == false) &&
																	(CheckActorPosition(PLAYER_TID + counter, pos_ByActorPos, 320, RoundInfo[FinishpointTAG],		0, 0, 0) == false) &&
																	(CheckActorPosition(PLAYER_TID + counter, pos_ByActorPos, 320, RoundInfo[StartpointTAG],		0, 0, 0) == false)
																	)
																	if ((abs(GetActorVelX(PLAYER_TID + counter)>>16) < 5) && (abs(GetActorVelY(PLAYER_TID + counter)>>16) < 5))  		Thing_Damage(PLAYER_TID + counter, RNG(1,2), MOD_WATER);

																}


														// Player is on the bad Floor ---------------------------------------------------------------------------------------------------------------------
														if 	(GetPort() >= Zandronum)
																if(PlayerStatus(counter) == ps_PLAYGROUND)
																	{

																		if ((GetActorZ(PLAYER_TID + counter)>>16) <= RoundInfo[PitFloorHeight])
																			{
																						if (CheckActorFloorTexture(PLAYER_TID + counter, "F_SKY1"))
																							{
																							ClientScript (counter, "PlayerScreenFade", WHITE, 0.5, 1.0);
																							SpawnForced("MapSpot", GetActorX(PLAYER_TID + counter) + int2fix(SkyfallOffset), GetActorY(PLAYER_TID + counter), GetActorZ(PLAYER_TID + counter) - int2fix(PlayerHeight), ACTORTID_Skyfall + counter, GetActorAngle(PLAYER_TID + counter)>>16);
																							Thing_Move(PLAYER_TID + counter, ACTORTID_Skyfall + counter, TRUE);
																							Thing_Remove(ACTORTID_Skyfall + counter);
																							}

																				else	if (CheckActorFloorTexture(PLAYER_TID + counter, "BLACKFLT"))
																							{
																							ClientScript (counter, "PlayerScreenFade", BLACK, 0.25, 1.0);
																							Thing_Move(PLAYER_TID + counter, ACTORTID_SkyfallInner, TRUE);
																							SetActorAngle(PLAYER_TID + counter, RNG(0,255) << 8);
																							}

																				if (GAMEINFO[Mood] == mood_SPACE)	SetActorProperty(PLAYER_TID + counter, APROP_Alpha, 0.0);
																				Thing_Damage(PLAYER_TID + counter, InstantDeath, MOD_UNKNOWN);


																			}

																	}


															// if some Player entering a teleport in the hub ---------------------------------------------------------------------------------------------------------------------
															if(	(CheckActorPosition(PLAYER_TID + counter, pos_ByActorPos, 48, ACTORTID_MainTeleport, 0, 0, 0) == true) && (PlayerCheckpoint[counter] == RoundInfo[CurrentRound]) && (RoundInfo[MiniCheckPoint] == 0))
															{
																if (RoundInfo[PlaygroundReached] == false)
																							{
																								TimeLeft = RoundInfo[TimeGiven];
																								RoundInfo[PlaygroundReached] = true;
																							}

																		ClientScript (counter, "ChangeMusic", AdventureInfo[RoundInfo[CurrentRound]][adv_MUSIC], 0, 0);
																		ClientScript (counter, "PlayerScreenFade", WHITE, 0.0, 2.0);
																		Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])
																			{
																			CASE adventure_BOSS:
																			ClientScript (counter, "SFX", GetPort(), SFX_BossEnter, 0);
																			break;
																			}

																		Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_RANDOMEVENT])
																			{
																			CASE event_WORM:
																			ClientScript (counter, "MSG_WormsNotify", 0, 0, 0);
																			break;
																			CASE event_BOMB:
																			ClientScript (counter, "MSG_BombNotify", 0, 0, 0);
																			break;
																			}







																if (CheckActorInventory(PLAYER_TID + counter, ActorString(AdventureInfo[RoundInfo[CurrentRound]] [adv_WEAPON], as_CODE)) == FALSE)	//Give a weapon
																		{
																			GiveActorInventory(PLAYER_TID + counter, ActorString(AdventureInfo[RoundInfo[CurrentRound]] [adv_WEAPON], as_CODE), 1);

																			//if player received hard weap, but doesn't have SSG, give it.
																			if (AdventureInfo[RoundInfo[CurrentRound]] [adv_WEAPON] > id_SuperShotgun)
																			GiveActorInventory(PLAYER_TID + counter, ActorString(id_SuperShotgun, as_CODE), 1);

																			ClientScript (counter, "MSG_NewWeapon", AdventureInfo[RoundInfo[CurrentRound]] [adv_WEAPON], 0, 0);

																		}

															ClientScript (counter, "DrawSky", ON, GAMEINFO[Mood]*10 + GAMEINFO[Location], 0);

															/*if (GAMEINFO[GameTest])*/	TeleportOther(PLAYER_TID + counter, RoundInfo[StartpointTAG], true);
															SetActorAngle(PLAYER_TID + counter, (RNG(0, 255) << 8));
															}


										counter++;

										}


				if (RoundInfo[adventureCounter] == 1)
					{

						if (RoundInfo[MiniCheckpoint] < AdventureInfo[RoundInfo[CurrentRound]][adv_MINICHECKPOINTS])
								{
								if (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_FLOW)
							//SET SUBSTANCE LINES TEXTURE AND OFFSET-----------------------------------------------------------------------------------
								for (a = 1; a < PlaygroundBlocks;  a++) {
								  if (/*a == RoundInfo[MiniStartpoint]/100 ||*/ a == RoundInfo[MiniFinishpoint]/100 /*|| a == RoundInfo[StartpointTag]/100 || a == RoundInfo[FinishpointTag]/100*/) 	continue;
								SetLineTexture(a, SIDE_FRONT, TEXTURE_MIDDLE, TextureIs (WallRAIStx));
								SetLineTexture(a, SIDE_BACK, TEXTURE_MIDDLE, TextureIs (WallRAIStx));
								ACS_NamedExecute("MCR_KillWhileDeploying", 0);
/*										for (b = 0; b < MaxPlayers;  b++)
												if((PlayerStatus(b) == ps_PLAYGROUND) && (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_FLOW))
														{
														if 	(
															(CheckActorPosition(PLAYER_TID + b, pos_ByActorPos, 320, RoundInfo[MiniStartpoint],		0, 0, 0) == false) &&
															(CheckActorPosition(PLAYER_TID + b, pos_ByActorPos, 320, RoundInfo[MiniFinishpoint],	0, 0, 0) == false) &&
															(CheckActorPosition(PLAYER_TID + b, pos_ByActorPos, 320, RoundInfo[FinishpointTAG],		0, 0, 0) == false) &&
															(CheckActorPosition(PLAYER_TID + b, pos_ByActorPos, 320, RoundInfo[StartpointTAG],		0, 0, 0) == false)
															)
															Thing_Damage(PLAYER_TID + b, InstantDeath, MOD_WATER);

														}
*/







								//Line_SetTextureOffset(a, NO_CHANGE, int2fix(RoundInfo[SubstanceLineOffset]), SIDE_FRONT, TEXFLAG_MIDDLE);
								//Line_SetTextureOffset(a, NO_CHANGE, int2fix(RoundInfo[SubstanceLineOffset]), SIDE_BACK, TEXFLAG_MIDDLE);
																			}



								RoundInfo[MiniCheckpoint]++;
								RoundInfo[adventureCounter] = 0;
								restart;
								}
					}











				if (TimeLeft <= BottomLine)	//That means nobody made it through the checkpoint in time
				{
					counter = 0;
					While(counter < MaxPlayers)
					{
					Thing_Damage(PLAYER_TID + counter, InstantDeath, MOD_UNKNOWN);
					counter++;
					}

				terminate;
				}




/*
     _       _                      _                  _           _     ___   ___  ____
    / \   __| |_   _____ _ __ _ __ | |_ _   _ _ __ ___( )___      | |   / _ \ / _ \|  _ \
   / _ \ / _` \ \ / / _ \ '__| '_ \| __| | | | '__/ _ \// __|     | |  | | | | | | | |_) |
  / ___ \ (_| |\ V /  __/ |  | | | | |_| |_| | | |  __/ \__ \     | |__| |_| | |_| |  __/
 /_/   \_\__,_| \_/ \___|_|  |_| |_|\__|\__,_|_|  \___| |___/     |_____\___/ \___/|_|

*/


			Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])
				{
				CASE adventure_BOSS:		break;
				CASE adventure_MAZE:		break;
				CASE adventure_LINEAR:		break;
				CASE adventure_RAISE:




						if (RoundInfo[CurrSubstanceHeight] < RoundInfo[MaxSubstanceHeight] )	//while dummy Substance level is lower than the highest point

								{
										if (RoundInfo[SubstanceMoveTimer] == 0)
											{


											for (a = 1; a <= PlaygroundBlocks;  a++)
												{
												Line_SetTextureOffset(a, NO_CHANGE, int2fix(1), SIDE_FRONT,		TEXFLAG_MIDDLE|TEXFLAG_ADDOFFSET);
												Line_SetTextureOffset(a, NO_CHANGE, int2fix(1), SIDE_BACK,		TEXFLAG_MIDDLE|TEXFLAG_ADDOFFSET);
												}
											RoundInfo[CurrSubstanceHeight]++;
											RoundInfo[SubstanceLineOffset]++;
											if (RoundInfo[CurrSubstanceHeight] < 0)		RoundInfo[SubstanceMoveTimer]	=	0;
											else										RoundInfo[SubstanceMoveTimer]	=	SetSubstanceSpeed();	//RoundInfo[SubstanceMoveDelay];
											}

										else											RoundInfo[SubstanceMoveTimer]--;





								}
						else
							{
								if (TimeLeft > PanicTime) TimeLeft = JoinTime;
							}

									// KILL THE PLAYER IF HE's ON OR BELOW THE SUBSTANCE
									counter = 0;
									While(counter < MaxPlayers)
										{
										if((PlayerStatus(counter) == ps_PLAYGROUND) && (GetActorZ(PLAYER_TID + counter) < int2fix(RoundInfo[CurrSubstanceHeight])))
												{
												Thing_Damage(PLAYER_TID + counter, InstantDeath, MOD_SLIME);
												}
										counter++;
										}
				break;

				}










				delay(1);
				}




				RoundInfo[MiniCheckpoint] = 0;

				GAMESTATE = gs_END;



/*
  ____   ___  _   _ _   _ ____     __        _____ _   _
 |  _ \ / _ \| | | | \ | |  _ \    \ \      / /_ _| \ | |
 | |_) | | | | | | |  \| | | | |    \ \ /\ / / | ||  \| |
 |  _ <| |_| | |_| | |\  | |_| |     \ V  V /  | || |\  |
 |_| \_\\___/ \___/|_| \_|____/       \_/\_/  |___|_| \_|

*/


			if(GAMESTATE == gs_END)
				{
				PortalVisuals(OFF);
				ACS_NamedTerminate("RandomEvent", 0);
				ACS_NamedExecute("RandomEvent", 0, None);


						if (RoundInfo[CurrentRound] < GAMEINFO[RoundsCount])
						{






											//If it was Boss Adventure or Invasion
											if(AccomplishType(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE]) == AccomplishByENEMYONLY)
												{

												Delay(TakeBreath);

												counter = 0;
												While(counter < MaxPlayers)
													{
													//if a secondary boss has been defeated
													if(PlayerStatus(counter) == ps_PLAYGROUND)
																{
																PlayerCheckpoint[counter] = RoundInfo[CurrentRound] + 1;
																TeleportOther(PLAYER_TID + counter, ACTORTID_Hub + counter, true);

																	ClientScript (counter, "ChangeMusic", AdventureInfo[None][adv_MUSIC], 0, 0);
																	ClientScript (counter, "DrawSky", OFF, 0, 0);



																}
													//someone is at the hub and didnt go through checkpoint by this point
													else if (	(PlayerStatus(counter) == ps_HUB) && (PlayerCheckpoint[counter] <= RoundInfo[CurrentRound])	)
																{
																Thing_Damage(PLAYER_TID + counter, InstantDeath, MOD_UNKNOWN);
																ClientScript (counter, "MSG_LateToJoin", 0, 0, 0);
																}
													counter++;
													}

												}



											else if(AccomplishType(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE]) == AccomplishByTELEPORT)
												{
													While(Timeleft > BottomLine)   //Then wait for everyone to give a chance to get out from the playground
															{
															counter = 0;
															While(counter < MaxPlayers)
																{
																//all the other players that enter the checkpoint after the first player
																if (	(CheckActorPosition(PLAYER_TID + counter, pos_ByActorPos, 32, RoundInfo[FinishpointTAG], 0, 0, 0) == true) && (PlayerCheckpoint[counter] <= RoundInfo[CurrentRound]))
																			{

																					PlayerCheckpoint[counter] = RoundInfo[CurrentRound] + 1;
																					TeleportOther(PLAYER_TID + counter, ACTORTID_Hub + counter, true);


																					ClientScript (counter, "DrawSky", OFF, 0, 0);

																					// FIX THIS, need to make a proper condition if cp winner entered, and to apply something to all other the other players at once




																			}

																//someone is at the hub and didnt go through checkpoint by this point
																else if (	(PlayerStatus(counter) == ps_HUB) && (PlayerCheckpoint[counter] <= RoundInfo[CurrentRound])	)
																			{
																			Thing_Damage(PLAYER_TID + counter, InstantDeath, MOD_UNKNOWN);
																			ClientScript (counter, "MSG_LateToJoin", 0, 0, 0);
																			}



																counter++;
																}
															delay(1);
															}


													//everyone who was left at the playground when Timeleft reaches Zero
													counter = 0;
													While(counter < MaxPlayers)
													{

														if (PlayerStatus(counter) == ps_PLAYGROUND)
															{
															Thing_Damage(PLAYER_TID + counter, InstantDeath, MOD_UNKNOWN);
															}
													counter++;
													}







												}

						RoundInfo[CurrentRound]++;
						}






/*
  ____ _____  _    ____ _____    __        _____ _   _
 / ___|_   _|/ \  / ___| ____|   \ \      / /_ _| \ | |
 \___ \ | | / _ \| |  _|  _|      \ \ /\ / / | ||  \| |
  ___) || |/ ___ \ |_| | |___      \ V  V /  | || |\  |
 |____/ |_/_/   \_\____|_____|      \_/\_/  |___|_| \_|

*/


				else if (RoundInfo[CurrentRound] >= GAMEINFO[RoundsCount])
						{


						/*
															_         _
						  ___ __ _ _ ___ ___ _ _    ____ __| |__ _ __| |_
						 (_-</ _| '_/ -_) -_) ' \  (_-< '_ \ / _` (_-< ' \
						 /__/\__|_| \___\___|_||_| /__/ .__/_\__,_/__/_||_|
													  |_|
						*/
						AmbientSound("SFXBOSSF", 127);
						SetHUDSize(HUDX_FULLSCREEN, HUDY_FULLSCREEN, 0);		SetFont("ERICON");
						ScreenFade (For_Everyone, WHITE, 0, 0.5, 2.0);

						counter = 0;
						While(counter < MaxPlayers)
							{
							//if a final boss has been defeated
							if((PlayerStatus(counter) == ps_PLAYGROUND) && (RoundInfo[CurrentRound] == GAMEINFO[RoundsCount]))
										{
										PlayerCheckpoint[counter] = RoundInfo[CurrentRound] + 1;
										}
							counter++;
							}


						Set_AllGodmode(true);





						//SETTING THE 'NEXT' STUFF

							SortPlayerScores(0); //DECIDE THE WINNER

							TempSEASON = ServerInfo[SEASON];
							TempSTAGE = ServerInfo[STAGE];
							TempTRY = ServerInfo[Try];
/*
     _         _                                     ____  _                    __        ___
    / \  _   _| |_ ___  _ __   __ _ _ __ ___   ___  / ___|| |_ __ _  __ _  ___  \ \      / (_)_ __  _ __   ___ _ __
   / _ \| | | | __/ _ \| '_ \ / _` | '_ ` _ \ / _ \ \___ \| __/ _` |/ _` |/ _ \  \ \ /\ / /| | '_ \| '_ \ / _ \ '__|
  / ___ \ |_| | || (_) | | | | (_| | | | | | |  __/  ___) | || (_| | (_| |  __/   \ V  V / | | | | | | | |  __/ |
 /_/   \_\__,_|\__\___/|_| |_|\__,_|_| |_| |_|\___| |____/ \__\__,_|\__, |\___|    \_/\_/  |_|_| |_|_| |_|\___|_|
                                                                    |___/
*/
							if(tempSTAGE > 0)		InputName_Auto();	//first autoname this record




/*

     _            _             _               _   _           _     ____  _
    / \   ___ ___(_) __ _ _ __ (_)_ __   __ _  | \ | | _____  _| |_  / ___|| |_ __ _  __ _  ___
   / _ \ / __/ __| |/ _` | '_ \| | '_ \ / _` | |  \| |/ _ \ \/ / __| \___ \| __/ _` |/ _` |/ _ \
  / ___ \\__ \__ \ | (_| | | | | | | | | (_| | | |\  |  __/>  <| |_   ___) | || (_| | (_| |  __/
 /_/   \_\___/___/_|\__, |_| |_|_|_| |_|\__, | |_| \_|\___/_/\_\\__| |____/ \__\__,_|\__, |\___|
                    |___/               |___/                                        |___/

*/


						if ((ServerInfo[STAGE] < MaxStages) && (ServerInfo[STAGE] > 0))    // If Stage number < Final Stage
							{

							ServerInfo[STAGE]++;
							ServerInfo[TRY] = 1;

							}


						else																// If that was a final stage
							{
							ServerInfo[STAGE] = 0;
							ServerInfo[SEASON] = 0;
							}





// REMEMBER THE UPCOMING SEASON/STAGE/NUM numbers

						Switch(GetPort())
							{


							Case Zandronum:

								BeginDBTransaction();
								SetDBEntry("db_ERINFO", "db_SEASON", ServerInfo[SEASON]);
								SetDBEntry("db_ERINFO", "db_STAGE", ServerInfo[STAGE]);
								//SetDBEntry("db_ERINFO", "db_TRY", ServerInfo[TRY]);
								EndDBTransaction();
								break;
							}




/*

  _____                        ____  _
 |  ___| __ ___  ___ _______  |  _ \| | __ _ _   _  ___ _ __ ___
 | |_ | '__/ _ \/ _ \_  / _ \ | |_) | |/ _` | | | |/ _ \ '__/ __|
 |  _|| | |  __/  __// /  __/ |  __/| | (_| | |_| |  __/ |  \__ \
 |_|  |_|  \___|\___/___\___| |_|   |_|\__,_|\__, |\___|_|  |___/
                                             |___/

*/

						//Freeze Players
						Switch(GetPort())
							{
							Case Zandronum: Case GZDoom:

								SetPlayerProperty(1, true, PROP_TOTALLYFROZEN);
								break;
							}

						Delay(TakeBreath);

						SetMusic(StrParam(s:"D_MUS", i:AdventureInfo[mus_CALM][adv_MUSIC]));

/*
   ____              _ _ _
  / ___|_ __ ___  __| (_) |_ ___
 | |   | '__/ _ \/ _` | | __/ __|
 | |___| | |  __/ (_| | | |_\__ \
  \____|_|  \___|\__,_|_|\__|___/

*/

if (TempSTAGE <= 0)		//random game

						{
						if (ServerInfo[CREDITS] == 0)
									{
									a = TRUE;
									ServerInfo[CREDITS] = 2;
									}
						else
									{
									ServerInfo[CREDITS]--;
									a = FALSE;
									}
						}


else					a = TRUE;	//competitive game


			if (a)
				{



						ScreenFade (For_Everyone, WHITE, 0, 0.5, 2.0);
						Delay(Sec/4);



							//Show Credits
							for(a = 0; a < MaxPlayers; a++)		ClientScript (a, "Cutscene", 1, 0, 0);


							a = CREDITS_StartAt;
							While(a > -CREDITS_StartAt)
							{
								a--;
								delay(1);
							}



				}





/*
  ____  _____ ____ ___ ____ _____ _____ ____    _____ _   _ _____  __        _____ _   _ _   _ _____ ____
 |  _ \| ____/ ___|_ _/ ___|_   _| ____|  _ \  |_   _| | | | ____| \ \      / /_ _| \ | | \ | | ____|  _ \
 | |_) |  _|| |  _ | |\___ \ | | |  _| | |_) |   | | | |_| |  _|    \ \ /\ / / | ||  \| |  \| |  _| | |_) |
 |  _ <| |__| |_| || | ___) || | | |___|  _ <    | | |  _  | |___    \ V  V /  | || |\  | |\  | |___|  _ <
 |_| \_\_____\____|___|____/ |_| |_____|_| \_\   |_| |_| |_|_____|    \_/\_/  |___|_| \_|_| \_|_____|_| \_\

*/

		if (TempSTAGE > 0)
				{

				/*
						   __   _ __
				 ___  ____/ /  (_) /_
				/ _ \/ __/ _ \/ / __/
				\___/_/ /_.__/_/\__/

				*/

				ChangeCamera(0, 1, 0);

				//for(a = 0; a < MaxPlayers; a++)			if (a != GAMEINFO[WinnerPlayerNum])			ClientScript (a, "WaitingForWinner", 0, 0, 0);

				Light_ChangeToValue(TIDRAM_WinCamera, GAMEINFO[WinnerPlayerNum]);

/*
  _   _        __                        __        ___
 | | | |_ __  / _|_ __ ___  ___ _______  \ \      / (_)_ __  _ __   ___ _ __
 | | | | '_ \| |_| '__/ _ \/ _ \_  / _ \  \ \ /\ / /| | '_ \| '_ \ / _ \ '__|
 | |_| | | | |  _| | |  __/  __// /  __/   \ V  V / | | | | | | | |  __/ |
  \___/|_| |_|_| |_|  \___|\___/___\___|    \_/\_/  |_|_| |_|_| |_|\___|_|

*/


							if (GetPort() >= Zandronum)	SetPlayerProperty(1, false, PROP_TOTALLYFROZEN);


/*
  ___ _   _ ____  _   _ _____      _    ____  _____    _
 |_ _| \ | |  _ \| | | |_   _|    / \  |  _ \| ____|  / \
  | ||  \| | |_) | | | | | |     / _ \ | |_) |  _|   / _ \
  | || |\  |  __/| |_| | | |    / ___ \|  _ <| |___ / ___ \
 |___|_| \_|_|    \___/  |_|   /_/   \_\_| \_\_____/_/   \_\

*/





								InputNameTurn = GAMEINFO[MaxNameChars];
								StringA = "";
								GAMEINFO[InputNameTime] = GAMEINFO[MaxNameChars]*20;
								TeleportOther(PLAYER_TID + GAMEINFO[WinnerPlayerNum], ACTORTID_InputArea, true);


//									SetFont("ERFONT");	SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, 0);
//									HudMessageBold(s:"Always input the same name to\n\nincrement your season score!" ;		HUDMSG_FADEOUT, 0, COLORTEXT_MAIN, int2fix(HUDX_MEDIUM/2), int2fix(HUDY_MEDIUM/8), 8.0, 4.0);




								While ((GAMEINFO[InputNameTime] > BottomLine) && (ClassifyActor(PLAYER_TID + GAMEINFO[WinnerPlayerNum]) & ACTOR_ALIVE))
									{
									counter = 0; StringA = "";	StringB = "";
									While(counter < GAMEINFO[MaxNameChars])
											{
											//if (WinnerNames[InputHeader + counter] == 32)		StringA = StrParam(s:"\ck", s:StringA, s:"\cj-");
											StringA = StrParam(s:"\ck", s:StringA, c:WinnerNames[InputHeader + counter]);


											//if (WinnerNames[InputHeader + counter] != 32)		StringA = StrParam(s:"\ck", s:StringA, c:WinnerNames[InputHeader + counter]);
											//else 												StringA = StrParam(s:"\ck", s:StringA, s:"\cj-");
											if (counter == InputNameTurn )	StringB = StrParam(s:"\cj", s:StringB, s:"^");
											else							StringB = StrParam(s:"\cj", s:StringB, s:"_");

											counter++;
											}


									//SetActivator
									SetFont("ERFONT");
									SetHUDSize(HUDX_BIG, HUDY_BIG, 0);			HudMessageBold(s:StringA, s:"\n\cj", s:StringB ;		HUDMSG_PLAIN, HUDid_InputName, CR_YELLOW, int2fix(HUDX_BIG/2), int2fix(HUDY_BIG/2), 1.0 );
									if(InputNameTurn < MinAllowedInput)
											{
											ForceAutoName = true;
											ClientScript (counter, "MSG_MinLettersReq", MinAllowedInput, 0, 0);
											}

									else if ((InputNameTurn == MinAllowedInput) &&  ((WinnerNames[InputHeader + 0]== 32) || (WinnerNames[InputHeader + 2]== 32)))
											{
											ForceAutoName = true;
											ClientScript (counter, "MSG_ManyBlanks", 0, 0, 0);
											}

									else	ForceAutoName = false;


											ClientScript (counter, "MSG_InputSameName", MinAllowedInput, 0, 0);


									//SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, 0);
									//HudMessageBold(s:"\cl", s:StringB;							HUDMSG_FADEOUT, HUDid_INPUTNOTE, CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2), int2fix(Y_TOP_LETTER), 1.0, 1.0 );
									//SetActivator
									delay(sec/2);
									}




								//Checking conditions of the inputed name
									if (ForceAutoName == true) // if only 2 chars inputed
										{
										InputNameTurn = 0;
										InputName_Auto();	//then autoname his record, fk that fool
										}


								//The final name as a String
								counter = 0;	StringA = "";
								while(counter < GAMEINFO[MaxNameChars])
								{
								StringA = StrParam(s:StringA, c:WinnerNames[InputHeader + counter]);
								counter++;
								}



								if ((TempSTAGE == MaxStages) && (GetPort() < GZDoom))		NewLegend(); //Create a new monument at the end of the season


								//A Zdaemon message to restore progress via console upon server restart, yeah clunky as f, but what can u do with an oldass port
								if (GetPort() == ZDaemon)	ZDA_StatsInfo();

								if (GetPort() == Zandronum)	//Preparing a string for Database

											{

											counter = 0;	StringA = "";
											while(counter < GAMEINFO[MaxNameChars])
												{
												StringA = StrParam(s:StringA, c:WinnerNames[InputHeader + counter]);
												counter++;
												}


											BeginDBTransaction();
											SetDBEntryString(StrParam(s:"db_Season", i:TempSEASON, s:"Winners"), StrParam(s:"db_WinnerOfStage", i:TempSTAGE), StringA);
											EndDBTransaction();

											}






				}






				ScreenFade (For_Everyone, WHITE, 0, 0.5, 2.0);



				if (tempSTAGE > 0)
									{
									StringB = StrParam(s:" OF STAGE ", i:TempSTAGE);
									SetHUDSize(HUDX_VERYBIG, HUDY_VERYBIG, 0);
									a = int2fix(HUDX_VERYBIG/2);
									b = int2fix(HUDY_VERYBIG/2);
									}
				else
									{
									StringB = "";
									StringA = StripColors(StrParam(n:GAMEINFO[WinnerPlayerNum] + 1));
									StringA = StrToUpper(StringA);
									SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, 0);
									a = int2fix(HUDX_MEDIUM/2);
									b = int2fix(HUDY_MEDIUM/2);
									}

				Light_ChangeToValue(TIDRAM_WinCamera, 99);
				//ChangeCamera(ACTORTID_SkyboxCamera, 1, 0);
				//-----------------------------------------------------------------
				SetFont("ERFONT");
				HudMessageBold(s:StringNoEdgeSpaces(StringA);			HUDMSG_PLAIN, 0, CR_YELLOW, a, b, 66.0 );
				//-----------------------------------------------------------------
				SetHUDSize(HUDX_BIG, HUDY_BIG, 0);
				HudMessageBold(s:"IS THE WINNER", s:StringB, s:"!";		HUDMSG_PLAIN, 0, CR_WHITE, int2fix(HUDX_BIG/2), int2fix(HUDY_BIG/2 + HUDY_BIG/16), 66.0 );


				if (GetPort() == Zandronum)		if (IsNetworkGame())		StoreMoneyInfo();
				Light_ChangeToValue(TIDRAM_MapReset, TRUE);

				delay(SEC*6);


				//EXIT MAP
				ScreenFade (For_Everyone, BLACK, 2.0, 999.0, 0.0);
				delay(SEC*2);


				Exit_Normal(0);
				terminate;

				}



		RoundInfo[StartpointTag]		=		ImpossibleNum;
		RoundInfo[FinishpointTag]		=		ImpossibleNum;
		RoundInfo[MiniStartpoint] 		= 		ImpossibleNum;
		RoundInfo[MiniFinishpoint] 		= 		ImpossibleNum;


		restart;

		}
}







/*
   ____ _   _ _____ ____   ____ _____ _   _ _____
  / ___| | | |_   _/ ___| / ___| ____| \ | | ____|
 | |   | | | | | | \___ \| |   |  _| |  \| |  _|
 | |___| |_| | | |  ___) | |___| |___| |\  | |___
  \____|\___/  |_| |____/ \____|_____|_| \_|_____|

*/


SCRIPT "Cutscene" (int SSpecial) CLIENTSIDE
{
int VERTendency = RandomNoZero(-1, 1);
int ANGtendency = RandomNoZero(-1, 1);




SetActorAngle(ACTORTID_SkyboxCamera, RNG(0,255) << 8);
SetActorPitch(ACTORTID_SkyboxCamera, RNG(FREELOOK_LIMIT_UP/2,FREELOOK_LIMIT_DOWN/2) << 8);

int CREDITS_VERTICITY = CREDITS_StartAt;
SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, FALSE);


While(CREDITS_VERTICITY > -CREDITS_StartAt)
	{
	ChangeCamera(ACTORTID_SkyboxCamera, 0, 0);
	if ((GetActorPitch(ACTORTID_SkyboxCamera) >> 8) < FREELOOK_LIMIT_UP/2)		VERTendency = 1;
	if ((GetActorPitch(ACTORTID_SkyboxCamera) >> 8) > FREELOOK_LIMIT_DOWN/2)	VERTendency = -1;


	SetActorAngle(ACTORTID_SkyboxCamera, GetActorAngle(ACTORTID_SkyboxCamera) + 0.0005 * ANGtendency);
	SetActorPitch(ACTORTID_SkyboxCamera, GetActorPitch(ACTORTID_SkyboxCamera) + (0.0001 * VERTendency));



Switch(SSpecial)
	{
	CASE 1:


SetFont("ERFNTZ");
HudMessage(
s:"\cg~~~~~CREATED~BY~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~ZEBERPAL~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",

s:"\n\n\n\n",

s:"\cg~~~~~CLASSIC~[LA]~BY~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~FLUNKY~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",

s:"\n\n\n\n\n",

s:"\cg~~~~~ADDITIONAL~THANKS~TO~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~DRINKYBIRD~~~~~~~~~~~~~~KAMINSKY~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~DEA~~~~~~~~~~~~~~~~~~~~~TDRR~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~ZERODEV~~~~~~~~~~~~~~~~~FLAMBEAU~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~AGENT~ASH~~~~~~~~~~~~~~~PHANTOMBETA~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~BUU342~~~~~~~~~~~~~~~~~~UBERGEWEI~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~THEMISTERCAT~~~~~~~~~~~~TRILLSTER~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~2022~(c)~ALL~RIGHTS~VIOLATED~~~~~~~~~~~~~~~~\n\n"



;HUDMSG_PLAIN, HUDid_CLIENTCREDITS, CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2), int2fix(CREDITS_VERTICITY), 0.25);

SetFont("ERTIT1"); // UDB LOGO
HudMessage(
s:"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",

s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~!{#$%&'()*+,-./01~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~23456789:;<=>?@AB~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~CDEFGHIJKLMNOPQRS~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~TUVWXYZ[}]^_`abcd~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~efghijklmnopqrstu~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~vwxyz~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";HUDMSG_PLAIN, HUDid_CLIENTCREDTIT1, CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2), int2fix(CREDITS_VERTICITY), 0.25);






SetFont("ERTIT2"); // ZDAEMON , LAWORLDS
HudMessage(
s:"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",

s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~!#$%&'()*+,-.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~/0123456789:;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~<=>?@ABCDEFGH~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~IJKL~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~MNOPQ~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~RSTUVWXYZ[]^~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`abcdefghijk~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";HUDMSG_PLAIN, HUDid_CLIENTCREDTIT2, CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2), int2fix(CREDITS_VERTICITY), 0.25);


SetFont("ERTIT3"); // DE, Zandro1
HudMessage(
s:"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",

s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~!#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~$%&~*+,~~~~~~~~~~~~Z[]^_~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~'()~-./01234~~~~~~`abcdef~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~56789:;<~~~~~~ghijklm~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~=>?~~~~~~~~~~~~~~~nopqrst~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~@ABCDEFGHIJKL~~~~~uvw~xy~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~MNOPQRSTUVWXY~~~~~~z{|}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";HUDMSG_PLAIN, HUDid_CLIENTCREDTIT3, CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2), int2fix(CREDITS_VERTICITY), 0.25);


SetFont("ERTIT4"); // Slade, Zandro2
HudMessage(
s:"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",

s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-./01~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~2345678~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~9:;<=>?~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~@ABCDEF~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~GHIJKLM~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NOPQRST~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~UVWXYZ[~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~]^_`abc~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~defghij~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~!~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~##~~~~k##~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~$%&'()*+,~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~#########~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";HUDMSG_PLAIN, HUDid_CLIENTCREDTIT4, CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2), int2fix(CREDITS_VERTICITY), 0.25);

	CREDITS_VERTICITY--;
	break;

	CASE 2:
	break;
	}
	delay(1);
	}

}

/*
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------


  ______   ______   .__   __. .___________.    ___       __  .__   __.  _______ .______                _______   _______ .______    __        ______   ____    ____  _______.
 /      | /  __  \  |  \ |  | |           |   /   \     |  | |  \ |  | |   ____||   _  \              |       \ |   ____||   _  \  |  |      /  __  \  \   \  /   / /       |
|  ,----'|  |  |  | |   \|  | `---|  |----`  /  ^  \    |  | |   \|  | |  |__   |  |_)  |             |  .--.  ||  |__   |  |_)  | |  |     |  |  |  |  \   \/   / |   (----`
|  |     |  |  |  | |  . `  |     |  |      /  /_\  \   |  | |  . `  | |   __|  |      /              |  |  |  ||   __|  |   ___/  |  |     |  |  |  |   \_    _/   \   \
|  `----.|  `--'  | |  |\   |     |  |     /  _____  \  |  | |  |\   | |  |____ |  |\  \----.         |  '--'  ||  |____ |  |      |  `----.|  `--'  |     |  | .----)   |
 \______| \______/  |__| \__|     |__|    /__/     \__\ |__| |__| \__| |_______|| _| `._____|         |_______/ |_______|| _|      |_______| \______/      |__| |_______/



----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

*/


Script "TELEPORTBLOCK" (int BlockCounter, int Direction, int SpecialBlock )
{
int ContainerType = OneBlock;
int counter;
/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/
											-------------------------------------------------------------
*/
while(counter < 8)
		{
		counter++;
		delay(	SetArea 		(area_FLOOR, 				ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatSECOtx), None));
		delay(	SetArea 		(area_CEILING, 				ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[GlobalCeilingHeight], 		TextureIs(CeilBASEtx), None));
		}


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



Switch(SpecialBlock)
			{
			CASE StartBlock:
			RoundInfo[StartpointTAG] = TagAt (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 36);
			ChangeFloor(RoundInfo[StartpointTAG],  "GATE4");
			/*
					   __      _ __
			  ___ ___ / /_    (_) /____ __ _
			 (_-</ -_) __/   / / __/ -_)  ' \
			/___/\__/\__/   /_/\__/\__/_/_/_/
														-------------------------------------------------------------
			*/

			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	 0, GetAmmoType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	 1, GetAmmoType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	55, GetAmmoType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	63, GetAmmoType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	 7, GetHealthType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	15, GetHealthType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	56, GetHealthType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	48, GetHealthType()	));

			//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

			break;

			CASE FinishBlock:
			RoundInfo[FinishpointTAG] = TagAt (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 36);
			ChangeFloor(RoundInfo[FinishpointTAG],  "GATE1");
			break;
			}



Deploying = false;
}







Script "DEPLOY_1" (int BlockCounter, int Direction)
{
if (RoundInfo[CurrFloorHeight] != RoundInfo[GlobalFloorHeight])	for(int c = 0; c < 64; c++)		Floor_MoveToValue(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, c), MoveInstantly, RoundInfo[CurrFloorHeight]);

ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 36),  "TESTFLA1");

Deploying = false;
}


//Doh
	/*


	  1111111          1111111
	 1::::::1         1::::::1
	1:::::::1        1:::::::1
	111:::::1        111:::::1
	   1::::1           1::::1
	   1::::1           1::::1
	   1::::1           1::::1
	   1::::l           1::::l
	   1::::l           1::::l
	   1::::l           1::::l
	   1::::l           1::::l
	   1::::l           1::::l
	111::::::111     111::::::111
	1::::::::::1     1::::::::::1
	1::::::::::1     1::::::::::1
	111111111111     111111111111


	*/


Script "DEPLOY_11" (int BlockCounter, int Direction)
{
int Tag, pTag, counter;
int ContainerType = OneBlock;


DrawLineTexture 	(dlt_DRAW, dlt_MAIN,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, DOESNT_MATTER);

/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/			MAIN
											-------------------------------------------------------------
*/

counter = 0;
while (counter < 8)
	{
	counter++;
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
	}

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/
											-------------------------------------------------------------
*/
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	2, 	4,  3,  7, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatBASEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	3,  4,  4, RoundInfo[PitFloorHeight], 			TextureIs(FlatFAILtx), None));
delay(	SetArea 		(area_CEILING, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	2, 	4,  3,  7, RoundInfo[CurrFloorHeight] + 256, 	TextureIs(CeilBASEtx), None));
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
                    _         __  _ __
   ___  _______    (_)__ ____/ /_(_) /__
  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
/_/           |___/							-------------------------------------------------------------
*/

int EmitTag = 65;	int DevourTag = 88;		int ProjAngle = ANG_to_LEFT;	int AddHeight = None;

delay(	SetProjectile 	(area_FLOOR,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_FLOOR,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		SetProjectile 	(area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
                    _         __  _ __
   ___  _______    (_)__ ____/ /_(_) /__
  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
/_/           |___/							-------------------------------------------------------------
*/

	EmitTag = 84;		DevourTag = 69;			ProjAngle = ANG_to_RIGHT;		AddHeight = None;

delay(	SetProjectile (area_FLOOR,			ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile (area_FLOOR,			ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile (area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile (area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		SetProjectile (area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
                    _         __  _ __
   ___  _______    (_)__ ____/ /_(_) /__
  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
/_/           |___/							-------------------------------------------------------------
*/

	EmitTag = 79;		DevourTag = 92;			ProjAngle = ANG_to_UP;			AddHeight = None;

delay(	SetProjectile (area_FLOOR,			ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile (area_FLOOR,			ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile (area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile (area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		SetProjectile (area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
                    _         __  _ __
   ___  _______    (_)__ ____/ /_(_) /__
  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
/_/           |___/							-------------------------------------------------------------
*/

	EmitTag = 88;		DevourTag = 65;			ProjAngle = ANG_to_RIGHT;		AddHeight = None;

delay(	SetProjectile (area_FLOOR,			ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile (area_FLOOR,			ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile (area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile (area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		SetProjectile (area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
           __      _ __
  ___ ___ / /_    (_) /____ __ _
 (_-</ -_) __/   / / __/ -_)  ' \
/___/\__/\__/   /_/\__/\__/_/_/_/
											-------------------------------------------------------------
*/

delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	36, item_RANDOM));
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
           __
  ___ ___ / /_    ___ ___  ___ __ _  __ __
 (_-</ -_) __/   / -_) _ \/ -_)  ' \/ // /
/___/\__/\__/    \__/_//_/\__/_/_/_/\_, /
                                   /___/  	-------------------------------------------------------------
*/


delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	0, ANG_to_RightDown,  		0	+ RandomRange(10)));
delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	7, ANG_to_DownLeft, 		50	));
delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 56, ANG_to_UpRight, 			50	));
delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 63, ANG_to_LeftUp,			0	+ RandomRange(10)));

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Deploying = false;
}




//Doh
/*


  1111111         222222222222222
 1::::::1        2:::::::::::::::22
1:::::::1        2::::::222222:::::2
111:::::1        2222222     2:::::2
   1::::1                    2:::::2
   1::::1                    2:::::2
   1::::1                 2222::::2
   1::::l            22222::::::22
   1::::l          22::::::::222
   1::::l         2:::::22222
   1::::l        2:::::2
   1::::l        2:::::2
111::::::111     2:::::2       222222
1::::::::::1     2::::::2222222:::::2
1::::::::::1     2::::::::::::::::::2
111111111111     22222222222222222222

*/


Script "DEPLOY_12" (int BlockCounter, int Direction)
{
int Tag, pTag, counter, CostCounter;
int ContainerType = OneBlock;
int Cost = WithinHundred(AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY] + RandomRange(20));

DrawLineTexture 	(dlt_DRAW, dlt_MAIN,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, DOESNT_MATTER);


/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/			MAIN
											-------------------------------------------------------------
*/

counter = 0;
while (counter < 8)
	{
	counter++;
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
	}

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/
											-------------------------------------------------------------
*/
							delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	1, 	2,  3,  3, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
							delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	3,  6,  8, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
							delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	7, 	8,  6,  6, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
							delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	6, 	6,  1,  3, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));

if (RNG(false, true))		delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	4, 	4,  3,  3, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
if (RNG(false, true))	{	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	5, 	5,  6,  6, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
							delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	29, ANG_to_LEFT,  		0	+ RandomRange(10)));
						}
/*SAFE PLACE*/				delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	1, 	1,  1,  1, RoundInfo[CurrFloorHeight], 				TextureIs(FlatSECOtx), None));


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/*
           __
  ___ ___ / /_    ___ ___  ___ __ _  __ __
 (_-</ -_) __/   / -_) _ \/ -_)  ' \/ // /
/___/\__/\__/    \__/_//_/\__/_/_/_/\_, /
                                   /___/  	-------------------------------------------------------------
*/


							delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	1, ANG_to_DOWN,  		0	+ RandomRange(10)));
							delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	9, ANG_to_DOWN,  		0	+ RandomRange(10)));
							delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 13, ANG_to_LEFT, 		35	));
							delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction,  6, ANG_to_LEFT, 		35	));
if (RNG(false, true))		delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 15, ANG_to_LEFT, 		35	));
							delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 54, ANG_to_UP, 			0	));
							delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 62, ANG_to_UP, 			0	));
if (RNG(false, true))
							{
							delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 50, ANG_to_RIGHT,		35	+ RandomRange(10)));
							delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 57, ANG_to_RIGHT,		35	+ RandomRange(10)));
if (RNG(false, true))		delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 48, ANG_to_RIGHT,		35	+ RandomRange(10)));
							}

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
           __      _ __
  ___ ___ / /_    (_) /____ __ _
 (_-</ -_) __/   / / __/ -_)  ' \
/___/\__/\__/   /_/\__/\__/_/_/_/
											-------------------------------------------------------------
*/

delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	7, item_RANDOM));
delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction,  56, item_RANDOM));
delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction,  18, item_RANDOM));
delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction,  45, item_RANDOM));
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------





delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	 0, GetAmmoType()	));

Deploying = false;
}







function int SetEnemy (int BlockCounter, int Direction, int Tag, int Angle, int Difficulty)
{
int Deelay 		= 1;
Tag				= TagAt (BlockCounter, Direction, Tag);
int Enemy, Marine, Color;
Difficulty 		= WithinHundred(AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY] + Difficulty);





		if 		((Difficulty <=   0) && (Difficulty <  10))		{	Enemy = RNG(id_Zombieman, 									id_Imp				);		Marine = RNG(id_MarinePlasma, 	id_MarineBerserk	);		}
else 	if 		((Difficulty >=  10) && (Difficulty <  20))		{	Enemy = RNG(id_Imp, 				/*id_ShotgunGuy*/		id_Demon			);		Marine = RNG(id_MarineBerserk, 	id_MarineChaingun	);		}
else 	if 		((Difficulty >=  20) && (Difficulty <  30))		{	Enemy = RNG(id_LostSoul,									id_HeavyWeaponDude	);		Marine = RNG(id_MarineChaingun, id_MarineRocket		);		}
else 	if 		((Difficulty >=  30) && (Difficulty <  40))		{	Enemy = RNG(id_HeavyWeaponDude,								id_Spectre 			);		Marine = RNG(id_MarineRocket, 	id_MarineBFG		);		}
else 	if 		((Difficulty >=  40) && (Difficulty <  50))		{	Enemy = RNG(id_Spectre,										id_Cacodemon		);		Marine = id_MarineBFG;										}
else 	if 		((Difficulty >=  50) && (Difficulty <  60))		{	Enemy = RNG(id_Cacodemon,									id_HellKnight		);		Marine = RNG(id_MarineBFG, 		id_MarineShotgun	);		}
else 	if 		((Difficulty >=  60) && (Difficulty <  70))		{	Enemy = RNG(id_HellKnight,									id_BaronOfHell		);		Marine = id_MarineShotgun;									}
else 	if 		((Difficulty >=  70) && (Difficulty <  80))		{	Enemy = RNG(id_Mancubus,									id_Arachnotron	 	);		Marine = RNG(id_MarineShotgun, 	id_MarineRailgun	);		}
else 	if 		((Difficulty >=  80) && (Difficulty <  90))		{	Enemy = RNG(id_Arachnotron,									id_Archvile 		);		Marine = id_MarineRailgun;									}
else 	if 		((Difficulty >=  90) && (Difficulty < 100))		{	Enemy = RNG(id_Archvile,			/*id_SpiderMastermind*/	id_Cyberdemon		);		Marine = RNG(id_MarineRailgun, 	id_MarineSSG		);		}
else 	if 		(Difficulty	 >= 100)							{	Enemy = RNG(id_Railgunner,									id_Railgunner		);		Marine = id_MarineSSG;										}

Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])
	{
	CASE adventure_BOSS:
	CASE adventure_MAZE:
	CASE adventure_LINEAR:
	CASE adventure_RAISE:
	CASE adventure_FLOW:
	Enemy = Enemy;	break;

	CASE adventure_INVASION:
	Enemy = Marine;

	break;
	}





RefreshSpotHeight(refreshspot_DEFAULT, Tag);
SpawnSpotForced(ActorString(Enemy, as_CODE), Tag, ACTORTID_Temp, ActorAngle(Angle, Direction, BYTE));

if (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_INVASION)
		{
			Switch(Enemy)
				{
				CASE id_MarinePlasma:	Color = tc_BLUE;	break;
				CASE id_MarineBerserk:	Color = tc_PINK;	break;
				CASE id_MarineChaingun:	Color = tc_PEACH;	break;
				CASE id_MarineRocket:	Color = tc_YELLOW;	break;
				CASE id_MarineBFG:		Color = tc_GREEN;	break;
				CASE id_MarineShotgun:	Color = tc_BROWN;	break;
				CASE id_MarineRailgun:	Color = tc_GREY;	break;
				CASE id_MarineSSG:		Color = tc_RED;		break;
				}
		Thing_SetTranslation(ACTORTID_Temp, Color);

		Tag = StrParam(i:((FixedDiv(Int2Fix(GetActorProperty(ACTORTID_Boss, APROP_Health)), Int2Fix(AdventureInfo[RoundInfo[CurrentRound]][adv_BOSSMAXHP]))* 100) >> 16), s:"%");

		Tag = FixedMul(int2fix(AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]), 0.01);
		//if (Enemy == id_MarineRailgun)	Tag = FixedMul(Tag, 0.125);
		SetActorProperty(ACTORTID_Temp, APROP_Speed, FixedMul(GetActorProperty(ACTORTID_Temp, APROP_SPEED), 1.0 + Tag));	//		RNG(1.5, 2.0)

		}



Thing_ChangeTID(ACTORTID_Temp, ACTORTID_Enemy);
return Deelay;
}




















Script "DEPLOY_2" (int BlockCounter, int Direction)
{

if (RoundInfo[CurrFloorHeight] != RoundInfo[GlobalFloorHeight])
for(int c = 0; c < 64; c++)
		{
		Floor_MoveToValue(TagAt (ContainerInfo(InfoType_ORDER, TwoBlocks, 1, BlockCounter, Direction), Direction, c), MoveInstantly, RoundInfo[CurrFloorHeight]);
		Floor_MoveToValue(TagAt (ContainerInfo(InfoType_ORDER, TwoBlocks, 2, BlockCounter, Direction), Direction, c), MoveInstantly, RoundInfo[CurrFloorHeight]);
		}

ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, TwoBlocks, 1, BlockCounter, Direction), Direction, 36),  "TESTFLA2");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, TwoBlocks, 2, BlockCounter, Direction), Direction, 36),  "TESTFLA2");
Deploying = false;
}

Script "DEPLOY_3" (int BlockCounter, int Direction)
{
if (RoundInfo[CurrFloorHeight] != RoundInfo[GlobalFloorHeight])
for(int c = 0; c < 64; c++)
		{
		Floor_MoveToValue(TagAt (ContainerInfo(InfoType_ORDER, ThreeBlocks, 1, BlockCounter, Direction), Direction, c), MoveInstantly, RoundInfo[CurrFloorHeight]);
		Floor_MoveToValue(TagAt (ContainerInfo(InfoType_ORDER, ThreeBlocks, 2, BlockCounter, Direction), Direction, c), MoveInstantly, RoundInfo[CurrFloorHeight]);
		Floor_MoveToValue(TagAt (ContainerInfo(InfoType_ORDER, ThreeBlocks, 3, BlockCounter, Direction), Direction, c), MoveInstantly, RoundInfo[CurrFloorHeight]);
		}
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, ThreeBlocks, 1, BlockCounter, Direction), Direction, 36),  "TESTFLA3");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, ThreeBlocks, 2, BlockCounter, Direction), Direction, 36),  "TESTFLA3");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, ThreeBlocks, 3, BlockCounter, Direction), Direction, 36),  "TESTFLA3");
Deploying = false;
}


Script "DEPLOY_4" (int BlockCounter, int Direction)
{
if (RoundInfo[CurrFloorHeight] != RoundInfo[GlobalFloorHeight])
for(int c = 0; c < 64; c++)
		{
		Floor_MoveToValue(TagAt (ContainerInfo(InfoType_ORDER, FourBlocks, 1, BlockCounter, Direction), Direction, c), MoveInstantly, RoundInfo[CurrFloorHeight]);
		Floor_MoveToValue(TagAt (ContainerInfo(InfoType_ORDER, FourBlocks, 2, BlockCounter, Direction), Direction, c), MoveInstantly, RoundInfo[CurrFloorHeight]);
		Floor_MoveToValue(TagAt (ContainerInfo(InfoType_ORDER, FourBlocks, 3, BlockCounter, Direction), Direction, c), MoveInstantly, RoundInfo[CurrFloorHeight]);
		Floor_MoveToValue(TagAt (ContainerInfo(InfoType_ORDER, FourBlocks, 4, BlockCounter, Direction), Direction, c), MoveInstantly, RoundInfo[CurrFloorHeight]);
		}
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, FourBlocks, 1, BlockCounter, Direction), Direction, 36),  "TESTFLA4");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, FourBlocks, 2, BlockCounter, Direction), Direction, 36),  "TESTFLA4");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, FourBlocks, 3, BlockCounter, Direction), Direction, 36),  "TESTFLA4");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, FourBlocks, 4, BlockCounter, Direction), Direction, 36),  "TESTFLA4");
Deploying = false;
}





Script "DEPLOY_101" (int BlockCounter, int Direction)
{
int Tag, pTag, counter;
int ContainerType = OneBlock;
/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/			MAIN
											-------------------------------------------------------------
*/

counter = 0;
while (counter < 8)
	{
	counter++;
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
	}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/
											-------------------------------------------------------------
*/

delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	4, 	5,  3,  3, RoundInfo[CurrFloorHeight] + 32, 				TextureIs(FlatSECOtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	6,  5,  5, RoundInfo[CurrFloorHeight] + 64, 				TextureIs(FlatSECOtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	6,  7,  7, RoundInfo[CurrFloorHeight] + 96, 				TextureIs(FlatSECOtx), None));
/*
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 34),  "FLOOR6_1");

ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 28),  "FLOOR6_1");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 36),  "FLOOR6_1");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 44),  "FLOOR6_1");

ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 22),  "FLOOR6_1");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 30),  "FLOOR6_1");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 38),  "FLOOR6_1");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 46),  "FLOOR6_1");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 54),  "FLOOR6_1");*/
																													LiftCurrentHeight();

//log(s:"Deployed Stairs_Normal at ", i:BlockCounter);
Deploying = false;
}

Script "DEPLOY_102" (int BlockCounter, int Direction)
{
if (RoundInfo[CurrFloorHeight] != RoundInfo[GlobalFloorHeight])
for(int c = 0; c < 64; c++)		Floor_MoveToValue(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, c), MoveInstantly, RoundInfo[CurrFloorHeight]);
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 4),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 12),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 20),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 28),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 36),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 35),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 34),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 33),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 32),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 16),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 9),  "RROCK20");
//log(s:"Deployed Stairs_DIAGONAL_left at ", i:BlockCounter);
																													LiftCurrentHeight();
Deploying = false;
}

Script "DEPLOY_103" (int BlockCounter, int Direction)
{
if (RoundInfo[CurrFloorHeight] != RoundInfo[GlobalFloorHeight])
for(int c = 0; c < 64; c++)		Floor_MoveToValue(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, c), MoveInstantly, RoundInfo[CurrFloorHeight]);
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 32),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 33),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 34),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 35),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 36),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 44),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 52),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 60),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 40),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 49),  "RROCK20");
//ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction)), Direction, 49),  "RROCK20");
																																LiftCurrentHeight();
//log(s:"Deployed Stairs_DIAGONAL_right at ", i:BlockCounter);
Deploying = false;
}






function void LiftCurrentHeight (void)
{
int Multiply, Result;

if (RoundInfo[InvertedStairs] == TRUE)	Multiply = -1;
else Multiply = 1;


Result = Multiply * StairsHeight;




RoundInfo[CurrFloorHeight] += Result;

RoundInfo[AddBorderEntryHeightX] = None;
RoundInfo[AddBorderEntryHeightY] = None;
RoundInfo[InvertedStairs] = FALSE;
}











Script "DEPLOY_501" (int BlockCounter, int Direction)
{
int ContainerType = OneBlock;
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	0, 	9,  0,  9, ImpossibleNum, 		TextureIs(FlatWATEtx), SectorSpecial_FLOW));


/*
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 34),  "FLOOR6_1");

ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 28),  "FLOOR6_1");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 36),  "FLOOR6_1");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 44),  "FLOOR6_1");

ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 22),  "FLOOR6_1");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 30),  "FLOOR6_1");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 38),  "FLOOR6_1");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 46),  "FLOOR6_1");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 54),  "FLOOR6_1");
*/
Deploying = false;
}

Script "DEPLOY_502" (int BlockCounter, int Direction)
{

ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 4),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 12),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 20),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 28),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 36),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 35),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 34),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 33),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 32),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 16),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 9),  "RROCK20");


Deploying = false;
}

Script "DEPLOY_503" (int BlockCounter, int Direction)
{

ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 32),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 33),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 34),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 35),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 36),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 44),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 52),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 60),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 40),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 49),  "RROCK20");


Deploying = false;
}





















/*

 ___________    ____  _______ .__   __. .___________.    _______.
|   ____\   \  /   / |   ____||  \ |  | |           |   /       |
|  |__   \   \/   /  |  |__   |   \|  | `---|  |----`  |   (----`
|   __|   \      /   |   __|  |  . `  |     |  |        \   \
|  |____   \    /    |  |____ |  |\   |     |  |    .----)   |
|_______|   \__/     |_______||__| \__|     |__|    |_______/


*/



//ZANDRONUM


script "EventLoop" (int EventType, int Arg1, int Arg2) EVENT
{
	if (EventType == GAMEEVENT_ROUND_STARTS)
		{
		if (GetLevelInfo(LEVELINFO_LEVELNUM) == MainMap)	ACS_NamedExecute("EXE", 0);
		}



    if (EventType == GAMEEVENT_ACTOR_DAMAGED)
		{
			if (Arg1 > 0)
				{
				SetActivator(PLAYER_TID + PlayerNumber(), AAPTR_DAMAGE_SOURCE);

				PlayerScore[PlayerNumber()] += Arg1;
				SetPlayerScore(PlayerNumber(), SCORE_POINTS, PlayerScore[PlayerNumber()]);
				}
		}

/*	idk doesnt work
	if (EventType == GAMEEVENT_PLAYERCONNECT)
		{
		//SetActivatorToPlayer(Arg1);
		//ClientScript	(Arg1, "CLIENTLOGIC", 0, 0, 0);
		NamedExecuteClientScript("CLIENTLOGIC", Arg1);
		}
*/
}

//ZDAEMON

function void ZDA_Dmg2PlayerScore (void)
{
   for (int p = 0; p < MaxPlayers;  p++)
     {
			PlayerScore[p] = GetPlayerInfo(p, PLAYERINFO_PTS_1);
    }
}





















Script "Test_ShowBlocks" ENTER
{
if (IsNetworkGame()) terminate;
SetFont("smallfont");
int y, x;

While(true)

	{
	SetFont("ERFONT");




	HudMessageBold(


	s:BlockAt[0][0], s:"  ", s:BlockAt[0][1], s:"  ", s:BlockAt[0][2], s:"  ", s:BlockAt[0][3], s:"  ", s:BlockAt[0][4], s:"\n\n",
	s:BlockAt[1][0], s:"  ", s:BlockAt[1][1], s:"  ", s:BlockAt[1][2], s:"  ", s:BlockAt[1][3], s:"  ", s:BlockAt[1][4], s:"\n\n",
	s:BlockAt[2][0], s:"  ", s:BlockAt[2][1], s:"  ", s:BlockAt[2][2], s:"  ", s:BlockAt[2][3], s:"  ", s:BlockAt[2][4], s:"\n\n",
	s:BlockAt[3][0], s:"  ", s:BlockAt[3][1], s:"  ", s:BlockAt[3][2], s:"  ", s:BlockAt[3][3], s:"  ", s:BlockAt[3][4], s:"\n\n",
	s:BlockAt[4][0], s:"  ", s:BlockAt[4][1], s:"  ", s:BlockAt[4][2], s:"  ", s:BlockAt[4][3], s:"  ", s:BlockAt[4][4], s:"\n\n\n\n",
	i:AdventureInfo[0][adv_TYPE], s:"  ", i:AdventureInfo[1][adv_TYPE], s:"  ", i:AdventureInfo[2][adv_TYPE], s:"  ", i:AdventureInfo[3][adv_TYPE], s:"  ", i:AdventureInfo[4][adv_TYPE], s:"  ", i:AdventureInfo[5][adv_TYPE], s:"\n\n",
	s:"\cjMOOD  ", 	i:GAMEINFO[Mood],		i:GAMEINFO[Location], s:"\n\n",
	s:"\cjPLAYER's CP  ", 	i:PlayerCheckpoint[PlayerNumber()],		s:"\cj,    ROUND  ", 	i:RoundInfo[CurrentRound], s:"\n\n",
	s:"\ckHEIGHT  ", 			f:GetActorZ(0), s:"\n\n",
	s:"\ciCEILI HEIGHT    ",	f:GetActorCeilingZ	(PLAYER_TID), s:"\n",
	s:"\ciFLOOR HEIGHT    ",	f:GetActorFloorZ	(PLAYER_TID), s:"\n",

	s:"\cgDIFFICULTY  ",	i: AdventureInfo[RoundInfo[CUrrentRound]][adv_DIFFICULTY], s:"\n",
	s:"\cgROUNDS WEAPON IS ", s:ActorString(AdventureInfo[RoundInfo[CurrentRound]] [adv_WEAPON], as_TEXT), s:"\n",
	s:"\cvVelocityX ", i:GetActorVelX(PLAYER_TID)>>16, s:"    VelocityY ", i:GetActorVelY(PLAYER_TID)>>16, s:"\n"

	;HUDMSG_PLAIN, 0, CR_UNTRANSLATED, 0.2, 0.7, 0.1);

	delay(1);
	}
}




































/*

 __        _____ _   _ _   _ _____ ____        _   _    _    __  __ _____       _                   _
 \ \      / /_ _| \ | | \ | | ____|  _ \      | \ | |  / \  |  \/  | ____|     (_)_ __  _ __  _   _| |_
  \ \ /\ / / | ||  \| |  \| |  _| | |_) |     |  \| | / _ \ | |\/| |  _|       | | '_ \| '_ \| | | | __|
   \ V  V /  | || |\  | |\  | |___|  _ <      | |\  |/ ___ \| |  | | |___      | | | | | |_) | |_| | |_
    \_/\_/  |___|_| \_|_| \_|_____|_| \_\     |_| \_/_/   \_\_|  |_|_____|     |_|_| |_| .__/ \__,_|\__|
                                                                                       |_|

*/

function bool LoggedIn (int PlayerNum)
{
bool Result;
str AccName = StrParam(s:GetPlayerAccountName(PlayerNum));
if (StrLen(AccName) > 0) Result = true;	else Result = false;
//if (StrCmp(AccName, "") >= 0) Result = true;	else Result = false;
return Result;
}



function void InputName_Auto (void)
{
int counter, LegendsNum, AddSpaces;
bool DecidedZAN, LongName;
str WinnerString = "";

str InitialName = StrParam(n:GAMEINFO[WinnerPlayerNum] + 1);
InitialName = StripColors(InitialName);	 //Remove the colours
InitialName = StrToUpper(InitialName); // only upper letters
InitialName = StringNoEdgeSpaces(InitialName); // Remove the gaps at the start and the back

// If someone won the last stage also import his name into legends


//Cleaning the Names and place -------


//InputHeader = ((TempSTAGE - 1) * GAMEINFO[MaxNameChars]);
InputHeader = (0 * GAMEINFO[MaxNameChars]); //DEBUG

		for (int a = InputHeader; 			a < InputHeader   +   GAMEINFO[MaxNameChars];  a++)
				{
				WinnerNames[a] = 32;
				//WinnerNames[InputHeader   +   GAMEINFO[MaxNameChars] + 1] = 33;
				}



// importing the name
While(counter < GAMEINFO[MaxNameChars])
	{


	Switch(GetPort())
	{
	CASE ZDaemon:
	Light_ChangeToValue(TIDRAM_WinnerNames + InputHeader + counter,  GetChar(InitialName, counter));
	WinnerNames[InputHeader + counter] = GetSectorLightLevel(TIDRAM_WinnerNames + InputHeader + counter);

	break;





	CASE Zandronum:

		if (DecidedZAN == false)		//Zandronum has more freedom in terms of Nickname usage, so we're choosing a method.
			{
					if ((LoggedIn(GAMEINFO[WinnerPlayerNum])) == true)	WinnerString = GetPlayerAccountName(GAMEINFO[WinnerPlayerNum]);//If player was logged paste his account name
					else
							{
							if 	(StrCmp(InitialName, "PLAYER") == 0)  //No generic Player is allowed, assigning some gibberish
									{
									counter = RNG(MinAllowedInput, GAMEINFO[MaxNameChars] - 2);
									While(counter > 0)
											{
											WinnerString = StrParam(s:WinnerString, c:RNG(48, 90));
											counter--;
											}
									}


							else	WinnerString = StrParam(n:GAMEINFO[WinnerPlayerNum] + 1);		//If player had the usual name
							}


			WinnerString = StripColors(WinnerString);	 //Remove the colours
			WinnerString = StrToUpper(WinnerString); // only upper letters
			WinnerString = StringNoEdgeSpaces(WinnerString); // Remove the gaps at the start and the back
			DecidedZAN = true;
			}



	WinnerNames[InputHeader + counter] = GetChar(WinnerString, counter);




	break;

	}






	//Replace bad chars
	if (WinnerNames[InputHeader + counter] == 92) WinnerNames[InputHeader + counter] = 39;  /* \ */
	if (WinnerNames[InputHeader + counter] == 34) WinnerNames[InputHeader + counter] = 47;	/* " */
	//if (WinnerNames[InputHeader + counter] == 32) WinnerNames[InputHeader + counter] = 95;  //SPACE


	InputNameTurn++;
	counter++;
	}



	Switch(GetPort())
	{
	CASE ZDaemon: 	if (GetChar(InitialName, GAMEINFO[MaxNameChars]) 	> 0)	LongName = true;
					AddSpaces = GAMEINFO[MaxNameChars] - StrLen(InitialName); 		if (AddSpaces < 0) AddSpaces = 0;

	break;

	CASE Zandronum: if (GetChar(StrParam(s:WinnerString), GAMEINFO[MaxNameChars]) 					> 0) 	LongName = true;
					AddSpaces = GAMEINFO[MaxNameChars] - StrLen(StrParam(s:WinnerString)); 		if (AddSpaces < 0) AddSpaces = 0;
	break;
	}

// if USERNAME length > allowed, then make it a USERNA..
if (LongName == true) //(GetChar(StrParam(n:GAMEINFO[WinnerPlayerNum] + 1), GAMEINFO[MaxNameChars]) != 32)
	{
	WinnerNames[InputHeader + GAMEINFO[MaxNameChars] - 2] = 46;
	WinnerNames[InputHeader + GAMEINFO[MaxNameChars] - 1] = 46;
	}



// or if its too short add spaces
if (AddSpaces > 0) //(GetChar(StrParam(n:GAMEINFO[WinnerPlayerNum] + 1), GAMEINFO[MaxNameChars]) != 32)
	{
	for (a = AddSpaces; a > 0;  a--)
	WinnerNames[GAMEINFO[MaxNameChars] - a] = 32;
	}



//Preparing a string for Database
if (GetPort() == Zandronum)
	{
	counter = 0;	WinnerString = "";
	while(counter < GAMEINFO[MaxNameChars])
		{
		WinnerString = StrParam(s:WinnerString, c:WinnerNames[InputHeader + counter]);
		counter++;
		}


	BeginDBTransaction();

	SetDBEntryString(StrParam(s:"db_Season", i:TempSEASON, s:"Winners"), StrParam(s:"db_WinnerOfStage", i:TempSTAGE), WinnerString);

	EndDBTransaction();
	}



}









Script SCRIPT_InputEnter (void)	// ENTER
{

if (InputNameTurn < MinAllowedInput)
		{
		//Print(s:"At least ", i:MinAllowedInput, s:" letters required!");
		DrawNotification(For_ActivatorOnly, StrParam(s:"At least ", i:MinAllowedInput, s:" letters required!"), 		notepose_TOP, notepara_ALIGN, ICON_EXCLAMATION, StrParam(c:ICON_EXCLAMATION), "g", "ERFONT",  OFF, OFF, noteFadeIn_None, noteHold_Short, noteFadeOut_Short);
		Terminate;
		}
GAMEINFO[InputNameTime] = BottomLine;
}



Script SCRIPT_InputBackspace (void)	// BACKSPACE
{
if (InputNameTurn <= 0) Terminate;
WinnerNames[InputHeader + InputNameTurn - 1] = 32;
InputNameTurn--;
}



Script SCRIPT_InputChar (int Char)	// BASIC CHAR
{
if ((Char == 32) && (InputNameTurn == 0))
		{
		//Print(s:"A name should start with a proper symbol");
		DrawNotification(For_ActivatorOnly, StrParam(s:"A name should start with a proper symbol"), 		notepose_MID, notepara_ALIGN, ICON_EXCLAMATION, StrParam(c:ICON_EXCLAMATION), "g", "ERFONT",  OFF, OFF, noteFadeIn_None, noteHold_Short, noteFadeOut_Short);
		Terminate;
		}


if (InputNameTurn >= GAMEINFO[MaxNameChars])
		{
		//Print(i:GAMEINFO[MaxNameChars], s:" letters allowed to input!");
		DrawNotification(For_ActivatorOnly, StrParam(i:GAMEINFO[MaxNameChars], s:" letters allowed to input!"), 		notepose_MID, notepara_ALIGN, ICON_EXCLAMATION, StrParam(c:ICON_EXCLAMATION), "g", "ERFONT",  OFF, OFF, noteFadeIn_None, noteHold_Short, noteFadeOut_Short);
		Terminate;
		}

if (InputNameTurn > GAMEINFO[MaxNameChars] - 1) Terminate;
WinnerNames[InputHeader + InputNameTurn] = Char;
InputNameTurn++;
}







Script SCRIPT_Buy	(int Product)
{
int Cost = 	GetProductProperties(Product, 1);
int Count = GetProductProperties(Product, 2);

str Money = "BlasterAmmo";
int PlayerMoney = GetSectorLightLevel(TIDRAM_Money + PlayerNumber());//		MoneyInfo_VALUE[tmp]		CheckInventory(Money);

if (PlayerMoney >= Cost)
			{
			//Light_ChangeToValue(TIDRAM_Money + PlayerNumber(), PlayerMoney - Cost);
			//TakeInventory(Money, Cost);
			GiveInventory(ActorString(Product, as_CODE), Count);
			RegisterMoney(PlayerNumber(), Cost);
			DrawNotification(For_ActivatorOnly, StrParam(s:"You've bought a ", s:ActorString(Product, as_TEXT), s:"!"), 		notepose_BOT, notepara_ALIGN, ICON_Money, StrParam(c:ICON_Money), "j", "ERFONT",  OFF, OFF, noteFadeIn_Short, noteHold_Short, noteFadeOut_Short);
			}

else		DrawNotification(For_ActivatorOnly, StrParam(s:"Not enough money! Collect ", i:Cost - PlayerMoney, s:"$!"), 		notepose_BOT, notepara_ALIGN, ICON_Sad, StrParam(c:ICON_Sad), "j", "ERFONT",  OFF, OFF, noteFadeIn_Short, noteHold_Short, noteFadeOut_Short);


}







int TestWinner[26];


Script "test12" (void)
{
int Iteration, counter;
Switch(GetPort())
	{
	CASE Zandronum:
	LegendNames[0] = 90;
	LegendNames[1] = 69;
	LegendNames[2] = 66;
	LegendNames[3] = 69;
	LegendNames[4] = 82;
	LegendNames[5] = 80;
	LegendNames[6] = 65;
	LegendNames[7] = 76;
	LegendNames[8] = 32;
	LegendNames[9] = 32;
	LegendNames[10] = 32;
	LegendNames[11] = 32;

	LegendNames[12] = 76;
	LegendNames[13] = 79;
	LegendNames[14] = 79;
	LegendNames[15] = 80;
	LegendNames[16] = 69;
	LegendNames[17] = 82;
	LegendNames[18] = 32;
	LegendNames[19] = 32;
	LegendNames[20] = 32;
	LegendNames[21] = 32;
	LegendNames[22] = 32;
	LegendNames[23] = 32;

	LegendNames[24] = 76;
	LegendNames[25] = 79;
	LegendNames[26] = 79;
	LegendNames[27] = 80;
	LegendNames[28] = 69;
	LegendNames[29] = 82;
	LegendNames[30] = 32;
	LegendNames[31] = 32;
	LegendNames[32] = 32;
	LegendNames[33] = 32;
	LegendNames[34] = 32;
	LegendNames[35] = 32;
	break;

	CASE ZDaemon:
	LegendNames[0] = 90;
	LegendNames[1] = 69;
	LegendNames[2] = 66;
	LegendNames[3] = 69;
	LegendNames[4] = 32;
	LegendNames[5] = 32;

	LegendNames[6] = 83;
	LegendNames[7] = 79;
	LegendNames[8] = 78;
	LegendNames[9] = 89;
	LegendNames[10] = 65;
	LegendNames[11] = 32;

	LegendNames[12] = 76;
	LegendNames[13] = 79;
	LegendNames[14] = 79;
	LegendNames[15] = 80;
	LegendNames[16] = 69;
	LegendNames[17] = 82;
	break;
	}

/*
Switch(GetPort())
{
CASE ZDaemon:
TestWinner[0] = "NULL        ";
TestWinner[1] = "DEA         ";
TestWinner[2] = "DASTAN      ";
TestWinner[3] = "KIKUCHI     ";
TestWinner[4] = "KAMINSKY    ";
TestWinner[5] = "RALPHIS     ";
TestWinner[6] = "DAKOTA      ";
TestWinner[7] = "RALPHIS     ";
TestWinner[8] = "DAKOTA      ";
TestWinner[9] = "DASTAN      ";
TestWinner[10] = "DAKOTA      ";
TestWinner[11] = "ZEBERPAL    ";
TestWinner[12] = "DAKOTA      ";
TestWinner[13] = "DAKOTA      ";
TestWinner[14] = "KAMINSKY    ";
TestWinner[15] = "DAKOTA      ";
TestWinner[16] = "RALPHIS     ";
TestWinner[17] = "DASTAN      ";
TestWinner[18] = "RALPHIS     ";
TestWinner[19] = "RALPHIS     ";
TestWinner[20] = "KIKUCHI     ";
TestWinner[21] = "DAKOTA      ";
TestWinner[22] = "ZEBERPAL    ";
TestWinner[23] = "ZEBERPAL    ";
TestWinner[24] = "RALPHIS     ";
TestWinner[25] = "KAMINSKY    ";
break;

Case Zandronum:
TestWinner[0] = "NULL  ";
TestWinner[1] = "DEA   ";
TestWinner[2] = "DASTAN";
TestWinner[3] = "KIKUCH";
TestWinner[4] = "KAMINS";
TestWinner[5] = "RALPHI";
TestWinner[6] = "DAKOTA";
TestWinner[7] = "RALPHI";
TestWinner[8] = "DAKOTA";
TestWinner[9] = "DASTAN";
TestWinner[10] = "DAKOTA";
TestWinner[11] = "ZEBERP";
TestWinner[12] = "DAKOTA";
TestWinner[13] = "DAKOTA";
TestWinner[14] = "KAMINS";
TestWinner[15] = "DAKOTA";
TestWinner[16] = "RALPHI";
TestWinner[17] = "DASTAN";
TestWinner[18] = "RALPHI";
TestWinner[19] = "RALPHI";
TestWinner[20] = "KIKUCH";
TestWinner[21] = "DAKOTA";
TestWinner[22] = "ZEBERP";
TestWinner[23] = "ZEBERP";
TestWinner[24] = "RALPHI";
TestWinner[25] = "KAMINS";
break;

}

*/

/*
TestWinner[0] = "NULL        ";
TestWinner[1] = "DEA         ";
TestWinner[2] = "DASTAN      ";
TestWinner[3] = "KIKUCHI     ";
TestWinner[4] = "KAMINSKY    ";
TestWinner[5] = "RALPHIS     ";
TestWinner[6] = "DAKOTA      ";
TestWinner[7] = "SEAN        ";
TestWinner[8] = "BOYAKA      ";
TestWinner[9] = "DASRW       ";
TestWinner[10] = "LESTER      ";
TestWinner[11] = "WTFDUDE     ";
TestWinner[12] = "PHANTOM     ";
TestWinner[13] = "DAKOFA      ";
TestWinner[14] = "KAMINKY     ";
TestWinner[15] = "NIGEL       ";
TestWinner[16] = "RAFIK       ";
TestWinner[17] = "DASNOE      ";
TestWinner[18] = "LLAMA       ";
TestWinner[19] = "RIGHT       ";
TestWinner[20] = "SEEKYA      ";
TestWinner[21] = "SEKIRO      ";
TestWinner[22] = "ZEBERDEE    ";
TestWinner[23] = "ZESHIT      ";
TestWinner[24] = "RAR         ";
TestWinner[25] = "HIMLER      ";
*/
/*

			Iteration = 0;
			While (Iteration <= MaxStages)
			{
			Iteration++;
			counter = 0;
				While(counter < GAMEINFO[MaxNameChars])
					{
					WinnerNames[(Iteration - 1)*GAMEINFO[MaxNameChars] + counter] = GetChar(TestWinner[Iteration], counter);
					counter++;
					}
			}

NewLegend();
delay(1);*/
RenderLegends();
}







/*
  __  __ ______  _____ _____         _____ ______  _____
 |  \/  |  ____|/ ____/ ____|  /\   / ____|  ____|/ ____|
 | \  / | |__  | (___| (___   /  \ | |  __| |__  | (___
 | |\/| |  __|  \___ \\___ \ / /\ \| | |_ |  __|  \___ \
 | |  | | |____ ____) |___) / ____ \ |__| | |____ ____) |
 |_|  |_|______|_____/_____/_/    \_\_____|______|_____/


*/







Script "MSG_MinLettersReq" (int Mins) CLIENTSIDE
{
DrawNotification(For_ActivatorOnly, StrParam(s:"At least ", i:Mins, s:" letters required!"), 		notepose_MID, notepara_ALIGN, ICON_EXCLAMATION, StrParam(c:ICON_EXCLAMATION), "g", "ERFONT",  OFF, OFF, 0, 2.0, 0);
}


Script "MSG_ManyBlanks" (void) CLIENTSIDE
{
DrawNotification(For_ActivatorOnly, StrParam(s:"Too many blank letters!"), 		notepose_MID, notepara_ALIGN, ICON_EXCLAMATION, StrParam(c:ICON_EXCLAMATION), "g", "ERFONT",  OFF, OFF, 0, 2.0, 0);
}

Script "MSG_InputSameName" (void) CLIENTSIDE
{
DrawNotification(For_ActivatorOnly, StrParam(s:"USE THE SAME NAME TO INCREMENT YOUR SEASON SCORES!"), 		notepose_TOP, notepara_ALIGN, ICON_EXCLAMATION, StrParam(c:ICON_EXCLAMATION), "j", "ERFONT",  OFF, ON, 0, 2.0, 0);
}




Script "MCR_KillWhileDeploying" (void)
{
while(true)
	{
										for (int b = 0; b < MaxPlayers;  b++)
												if((PlayerStatus(b) == ps_PLAYGROUND) && (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_FLOW))
														{
														if 	(
															(CheckActorPosition(PLAYER_TID + b, pos_ByActorPos, 320, RoundInfo[MiniStartpoint],		0, 0, 0) == false) &&
															(CheckActorPosition(PLAYER_TID + b, pos_ByActorPos, 320, RoundInfo[MiniFinishpoint],	0, 0, 0) == false) &&
															(CheckActorPosition(PLAYER_TID + b, pos_ByActorPos, 320, RoundInfo[FinishpointTAG],		0, 0, 0) == false) &&
															(CheckActorPosition(PLAYER_TID + b, pos_ByActorPos, 320, RoundInfo[StartpointTAG],		0, 0, 0) == false)
															)
															Thing_Damage(PLAYER_TID + b, InstantDeath, MOD_WATER);

														}
	delay(1);
	}

}





#libdefine WormsCount 	5
#libdefine wormTAG 		0
#libdefine wormBC 		1
#libdefine wormMBy 		2
#libdefine wormMBx 		3
int WormAt[WormsCount][4];


/*
  _____            _   _ _____   ____  __  __       ________      ________ _   _ _______ _____
 |  __ \     /\   | \ | |  __ \ / __ \|  \/  |     |  ____\ \    / /  ____| \ | |__   __/ ____|
 | |__) |   /  \  |  \| | |  | | |  | | \  / |     | |__   \ \  / /| |__  |  \| |  | | | (___
 |  _  /   / /\ \ | . ` | |  | | |  | | |\/| |     |  __|   \ \/ / |  __| | . ` |  | |  \___ \
 | | \ \  / ____ \| |\  | |__| | |__| | |  | |     | |____   \  /  | |____| |\  |  | |  ____) |
 |_|  \_\/_/    \_\_| \_|_____/ \____/|_|  |_|     |______|   \/   |______|_| \_|  |_| |_____/


*/

Script "MSG_WormsNotify" (void) CLIENTSIDE
{
DrawNotification(For_ActivatorOnly, StrParam(s:"BE CAREFUL! WORMS ARE FLOATING ON THE SURFACE!"), notepose_MID, notepara_ALIGN, ICON_EXCLAMATION, StrParam(c:ICON_Exclamation), "g", "ERFONT",  ON, ON, noteFadeIn_None, noteHold_Standart, noteFadeOut_Standart);
}

Script "MSG_BombNotify" (void) CLIENTSIDE
{
DrawNotification(For_ActivatorOnly, StrParam(s:"SURFACE SEEMS TO BE FRAGILE... MIND THE SAFE FLOORS!"), notepose_MID, notepara_ALIGN, ICON_EXCLAMATION, StrParam(c:ICON_Exclamation), "g", "ERFONT",  ON, ON, noteFadeIn_None, noteHold_Standart, noteFadeOut_Standart);
}

Script "RandomEvent"	(int Which)
{
int counter, Time, Direction, Deelay, w;

Switch(Which)
		{
		CASE None:	//abort events here
		for(w = 0; w < WormsCount;  w++)				{
																WormAt[w][wormTAG] 	= ImpossibleNum;
																WormAt[w][wormBC] 	= 0;
																WormAt[w][wormMBy] 	= 0;
																WormAt[w][wormMBx] 	= 0;
														}
		ReplaceTextures(TextureIs(FlatWATEtx), TextureIs(FlatBASEtx));
		break;


		CASE event_BOMB:

				While(TRUE)
					{
					Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])	{ Case adventure_BOSS:	delay(SEC*15);	break;	Case adventure_MAZE:	Case adventure_LINEAR:	delay(SEC*40);	break;	}

					//AmbientSound("SFXBOMB", 127);
					for(w = 0; w < PlaygroundBlocks; w++)
											{
											RefreshSpotHeight(refreshspot_DEFAULT, TagAt (w + 1, ToRIGHT, 28));
											//SpawnSpotForced("MapSpot", TagAt (a + 1, ToRIGHT, 28), ACTORTID_AmbientWater, 0);
											ThingSound(TagAt (w + 1, ToRIGHT, 28), "SFXBOMB", 127);
											}

					Time = 13;
					counter = Time;
					while (counter > 0)
							{
							counter--;
							DrawNotification(For_Everyone, StrParam(s:"THE GROUND WILL COLLAPSE IN...", i:counter, s:"!"), notepose_MID, notepara_ALIGN, ICON_None, StrParam(c:ICON_HEADER_Clock + ((FixedDiv(Int2Fix(counter), Int2Fix(Time))* 100) >> 16)/10), "g", "ERFONT",  OFF, ON, 0.0, 1.0, 1.0);
							delay(SEC);
							}

					ReplaceTextures(TextureIs(FlatBASEtx), TextureIs(FlatBOMBtx));
					Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])	{ Case adventure_BOSS:	delay(SEC*RNG(2,3));	break;	Case adventure_MAZE:	Case adventure_LINEAR:	delay(SEC*5);	break;	}
					ReplaceTextures(TextureIs(FlatBOMBtx), TextureIs(FlatBASEtx));
					}

		break;


		CASE event_WORM:
		Deelay = SEC - AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]/3 + 4;
		ReplaceTextures(TextureIs(FlatBASEtx), TextureIs(FlatWATEtx));
		//delay(SEC*5);
		Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])
				{
				Case adventure_BOSS:		counter = 4;	break;

				Case adventure_MAZE:
				Case adventure_LINEAR:
				Case adventure_INVASION:	counter = 0;	break;
				}

		ReplaceTextures(TextureIs(FlatBASEtx), TextureIs(FlatWATEtx));

		while(counter < WormsCount)
		{
			while( ((WormAt[counter][wormBC] == RoundInfo[FinishpointTAG]/100) || WormAt[counter][wormBC] == RoundInfo[StartpointTAG]/100) | (!CheckActorFloorTexture(WormAt[counter][wormTAG], TextureIs(FlatWATEtx)))	| (!WormAt[counter][wormTAG]))
					{/*
					if (counter > 0)
							for(w = 0; w < counter;  w++)
									while(WormAt[counter][wormBC] == WormAt[w][wormBC])			WormAt[counter][wormBC]	 = RNG(1, PlaygroundBlocks);
					else 			WormAt[counter][wormBC]	 = RNG(1, PlaygroundBlocks);*/

									if (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE]	==	adventure_BOSS)
									WormAt[counter][wormBC]	 = RNG(12, 14);
									else
									WormAt[counter][wormBC]	 = RNG((sqrt(PlaygroundBlocks)*counter) + 1, sqrt(PlaygroundBlocks)*(counter + 1));

									//while((WormAt[counter][wormBC] == RoundInfo[FinishpointTAG]/100) || WormAt[counter][wormBC] == RoundInfo[StartpointTAG]/100)			WormAt[counter][wormBC]	 = RNG((sqrt(PlaygroundBlocks)*counter) + 1, sqrt(PlaygroundBlocks)*(counter + 1));
									WormAt[counter][wormMBy] = RNG(1, 8);
									WormAt[counter][wormMBx] = RNG(1, 8);

									WormAt[counter][wormTAG] = TagAt (WormAt[counter][wormBC], ToRIGHT, MiniBlockAt[WormAt[counter][wormMBy]]	[WormAt[counter][wormMBx]]);
					delay(1);
					}
		counter++;
		}

		//WORM SPAWNED

				While(TRUE)
					{
					counter = 0;
					while(counter < WormsCount)
							{

							Direction = RNG(1,4);

							Switch(Direction)
									{
									CASE ToRIGHT:
									if (WormAt[counter][wormMBx] + 1 >= MBslots)
											{
											if (BlockCounterAtTheEdge(Direction,  WormAt[counter][wormBC]) == FALSE)
													if (CheckActorFloorTexture	(TagAt (WormAt[counter][wormBC] + 1, ToRIGHT, MiniBlockAt[WormAt[counter][wormMBy]][1]), 		TextureIs(FlatWATEtx)))
															if (GetSectorFloorZ	(TagAt (WormAt[counter][wormBC] + 1, ToRIGHT, MiniBlockAt[WormAt[counter][wormMBy]][1]), 0, 0) 	== 	GetSectorFloorZ(WormAt[counter][wormTAG], 0, 0))
															{
															ChangeFloor(WormAt[counter][wormTAG], TextureIs(FlatWATEtx));
															WormAt[counter][wormBC] = WormAt[counter][wormBC] + 1; 	WormAt[counter][wormMBx] = 1;
															}

											}
									else
											{
											if (CheckActorFloorTexture	(TagAt (WormAt[counter][wormBC], ToRIGHT, MiniBlockAt[WormAt[counter][wormMBy]][WormAt[counter][wormMBx] + 1]), 		TextureIs(FlatWATEtx)))
													if (GetSectorFloorZ	(TagAt (WormAt[counter][wormBC], ToRIGHT, MiniBlockAt[WormAt[counter][wormMBy]][WormAt[counter][wormMBx] + 1]), 0, 0) 	== 	GetSectorFloorZ(WormAt[counter][wormTAG], 0, 0))
															{
															ChangeFloor(WormAt[counter][wormTAG], TextureIs(FlatWATEtx));
															WormAt[counter][wormMBx] = WormAt[counter][wormMBx] + 1;
															}
											}

									break;


			//-------------------------------------------

									CASE ToDOWN:
									if (WormAt[counter][wormMBy] + 1 >= MBslots)
											{
											if (BlockCounterAtTheEdge(Direction,  WormAt[counter][wormBC]) == FALSE)
													if (CheckActorFloorTexture	(TagAt (WormAt[counter][wormBC] + sqrt(PlaygroundBlocks), ToRIGHT, MiniBlockAt[1][WormAt[counter][wormMBx]]), 		TextureIs(FlatWATEtx)))
															if (GetSectorFloorZ	(TagAt (WormAt[counter][wormBC] + sqrt(PlaygroundBlocks), ToRIGHT, MiniBlockAt[1][WormAt[counter][wormMBx]]), 0, 0) 	== 	GetSectorFloorZ(WormAt[counter][wormTAG], 0, 0))
															{
															ChangeFloor(WormAt[counter][wormTAG], TextureIs(FlatWATEtx));
															WormAt[counter][wormBC] = WormAt[counter][wormBC] + sqrt(PlaygroundBlocks); 	WormAt[counter][wormMBy] = 1;
															}

											}
									else
											{
											if (CheckActorFloorTexture	(TagAt (WormAt[counter][wormBC], ToRIGHT, MiniBlockAt[WormAt[counter][wormMBy] + 1][WormAt[counter][wormMBx]]), 		TextureIs(FlatWATEtx)))
													if (GetSectorFloorZ	(TagAt (WormAt[counter][wormBC], ToRIGHT, MiniBlockAt[WormAt[counter][wormMBy] + 1][WormAt[counter][wormMBx]]), 0, 0) 	== 	GetSectorFloorZ(WormAt[counter][wormTAG], 0, 0))
															{
															ChangeFloor(WormAt[counter][wormTAG], TextureIs(FlatWATEtx));
															WormAt[counter][wormMBy] = WormAt[counter][wormMBy] + 1;
															}
											}

									break;


			//-------------------------------------------

									CASE ToLEFT:
									if (WormAt[counter][wormMBx] - 1 <= -1)
											{
											if (BlockCounterAtTheEdge(Direction,  WormAt[counter][wormBC]) == FALSE)
													if (CheckActorFloorTexture	(TagAt (WormAt[counter][wormBC] - 1, ToRIGHT, MiniBlockAt[WormAt[counter][wormMBy]][8]), 		TextureIs(FlatWATEtx)))
														if (GetSectorFloorZ		(TagAt (WormAt[counter][wormBC] - 1, ToRIGHT, MiniBlockAt[WormAt[counter][wormMBy]][8]), 0, 0) 	== 	GetSectorFloorZ(WormAt[counter][wormTAG], 0, 0))
															{
															ChangeFloor(WormAt[counter][wormTAG], TextureIs(FlatWATEtx));
															WormAt[counter][wormBC] = WormAt[counter][wormBC] - 1; 	WormAt[counter][wormMBx] = 8;
															}

											}
									else
											{
											if (CheckActorFloorTexture	(TagAt (WormAt[counter][wormBC], ToRIGHT, MiniBlockAt[WormAt[counter][wormMBy]][WormAt[counter][wormMBx] - 1]), 		TextureIs(FlatWATEtx)))
													if (GetSectorFloorZ	(TagAt (WormAt[counter][wormBC], ToRIGHT, MiniBlockAt[WormAt[counter][wormMBy]][WormAt[counter][wormMBx] - 1]), 0, 0) 	== 	GetSectorFloorZ(WormAt[counter][wormTAG], 0, 0))
															{
															ChangeFloor(WormAt[counter][wormTAG], TextureIs(FlatWATEtx));
															WormAt[counter][wormMBx] = WormAt[counter][wormMBx] - 1;
															}
											}

									break;

			//-------------------------------------------

									CASE ToUP:
									if (WormAt[counter][wormMBy] - 1 <= -1)
											{
											if (BlockCounterAtTheEdge(Direction,  WormAt[counter][wormBC]) == FALSE)
													if (CheckActorFloorTexture	(TagAt (WormAt[counter][wormBC] - sqrt(PlaygroundBlocks), ToRIGHT, MiniBlockAt[8][WormAt[counter][wormMBx]]), 		TextureIs(FlatWATEtx)))
															if (GetSectorFloorZ	(TagAt (WormAt[counter][wormBC] - sqrt(PlaygroundBlocks), ToRIGHT, MiniBlockAt[8][WormAt[counter][wormMBx]]), 0, 0) 	== 	GetSectorFloorZ(WormAt[counter][wormTAG], 0, 0))
															{
															ChangeFloor(WormAt[counter][wormTAG], TextureIs(FlatWATEtx));
															WormAt[counter][wormBC] = WormAt[counter][wormBC] - sqrt(PlaygroundBlocks); 	WormAt[counter][wormMBy] = 8;
															}

											}
									else
											{
											if (CheckActorFloorTexture	(TagAt (WormAt[counter][wormBC], ToRIGHT, MiniBlockAt[WormAt[counter][wormMBy] - 1][WormAt[counter][wormMBx]]), 		TextureIs(FlatWATEtx)))
													if (GetSectorFloorZ	(TagAt (WormAt[counter][wormBC], ToRIGHT, MiniBlockAt[WormAt[counter][wormMBy] - 1][WormAt[counter][wormMBx]]), 0, 0) 	== 	GetSectorFloorZ(WormAt[counter][wormTAG], 0, 0))
															{
															ChangeFloor(WormAt[counter][wormTAG], TextureIs(FlatWATEtx));
															WormAt[counter][wormMBy] = WormAt[counter][wormMBy] - 1;
															}
											}

									break;

									}





							WormAt[counter][wormTAG] = TagAt (WormAt[counter][wormBC], ToRIGHT, MiniBlockAt[WormAt[counter][wormMBy]][WormAt[counter][wormMBx]]);

							//log(s:"WORM#", i:counter, s:" IS AT ", i:WormAt[counter][wormTAG]);
							ChangeFloor(WormAt[counter][wormTAG], TextureIs(FlatWORMtx));
							RefreshSpotHeight(refreshspot_DEFAULT, WormAt[counter][wormTAG]);
							ThingSound(WormAt[counter][wormTAG], "SFXPANIC", 127);

							counter++;
							}
					delay(Deelay);
					}

		break;


		}





}


function void ClientScript	(int Client, str ScriptName, int arg1, int arg2, int arg3)
{
/*if(GetPort() < GZDoom)	if(!PlayerIsSpectator(Client))		*/
SetActivator(PLAYER_TID + Client);
Switch(GetPort())
	{
	Case ZDaemon:			Client_NamedExecute(Client, ScriptName, 0, 			arg1, arg2, arg3 );			break;
	Case Zandronum:			NamedExecuteClientScript(ScriptName, Client, 		arg1, arg2, arg3 );			break;
	Case GZDoom:			ACS_NamedExecute(ScriptName, 0, 					arg1, arg2, arg3 );			break;
	}
}




Script "PlayerScreenFade" (int color, int TimeHold, int TimeOut) CLIENTSIDE
{
ScreenFade(For_ActivatorOnly, color, 0.0, TimeHold, TimeOut);
}


function void ScreenFade (int Who, int Color, int TimeIn, int TimeHold, int TimeOut)
{
str cl = "";

Switch(Color)
		{
		CASE BLACK:		Color = ICON_BlackScreen;	cl = "\cm";		break;
		CASE WHITE:		Color = ICON_WhiteScreen;	cl = "\cj";		break;
		}

SetHUDSize(HUDX_FULLSCREEN, HUDY_FULLSCREEN, FALSE);		SetFont("ERICON");

Switch(Who)
		{
		CASE For_ActivatorOnly:
		HudMessage(		s:cl, c:Color;		HUDMSG_FADEINOUT, 0, CR_UNTRANSLATED, int2fix(X_FULLSCREEN - 16), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut);
		HudMessage(		s:cl, c:Color;		HUDMSG_FADEINOUT, 0, CR_UNTRANSLATED, int2fix(X_FULLSCREEN - 8), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut);
		HudMessage(		s:cl, c:Color;		HUDMSG_FADEINOUT, 0, CR_UNTRANSLATED, int2fix(X_FULLSCREEN), 		int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut);
		HudMessage(		s:cl, c:Color;		HUDMSG_FADEINOUT, 0, CR_UNTRANSLATED, int2fix(X_FULLSCREEN + 8), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut);
		HudMessage(		s:cl, c:Color;		HUDMSG_FADEINOUT, 0, CR_UNTRANSLATED, int2fix(X_FULLSCREEN + 16), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut);
		break;
		CASE For_Everyone:
		HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT, 0, CR_UNTRANSLATED, int2fix(X_FULLSCREEN - 16), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut);
		HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT, 0, CR_UNTRANSLATED, int2fix(X_FULLSCREEN - 8), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut);
		HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT, 0, CR_UNTRANSLATED, int2fix(X_FULLSCREEN), 		int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut);
		HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT, 0, CR_UNTRANSLATED, int2fix(X_FULLSCREEN + 8), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut);
		HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT, 0, CR_UNTRANSLATED, int2fix(X_FULLSCREEN + 16), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut);
		break;
		}

}









function int GetProductProperties (int Id, int Param)
{
int Cost, Count, Result;
Switch(Id)
	{
	CASE id_Shotgun:			Cost = 10;		Count = 1;					break;
	CASE id_Chaingun:			Cost = 15;		Count = 1;					break;
	CASE id_SuperShotgun:		Cost = 20;		Count = 1;					break;
	CASE id_RocketLauncher:		Cost = 50;		Count = 1;					break;
	CASE id_PlasmaRifle:		Cost = 75;		Count = 1;					break;
	CASE id_BFG9000:			Cost = 250;		Count = 1;					break;

	CASE id_Clip:				Cost = 10;		Count = 10;					break;
	CASE id_ClipBox:			Cost = 10;		Count = 50;					break;
	CASE id_Shell:				Cost = 15;		Count = 4;					break;
	CASE id_ShellBox:			Cost = 10;		Count = 20;					break;
	CASE id_RocketAmmo:			Cost = 20;		Count = 1;					break;
	CASE id_RocketBox:			Cost = 10;		Count = 5;					break;
	CASE id_Cell:				Cost = 50;		Count = 20;					break;
	CASE id_CellPack:			Cost = 75;		Count = 100;				break;
	CASE id_Backpack:			Cost = 250;		Count = 1;					break;

	CASE id_Stimpack:			Cost = 50;		Count = 1;					break;
	CASE id_Medkit:				Cost = 75;		Count = 1;					break;
	CASE id_Soulsphere:			Cost = 250;		Count = 1;					break;

	CASE id_Stimpack:			Cost = 50;		Count = 1;					break;
	CASE id_Medkit:				Cost = 75;		Count = 1;					break;
	CASE id_Soulsphere:			Cost = 250;		Count = 1;					break;
	}

Switch(Param)
	{
	CASE 1:	Result = Cost;		break;
	CASE 2: Result = Count;		break;
	}

return Result;
}








Script "MSG_NewMoneyAcc" (void) CLIENTSIDE
{
DrawNotification(For_ActivatorOnly, StrParam(s:"You got the first money in ", s:GetCVarString("ER_ServerClusterIs"), s:" server!"), 		notepose_MID, notepara_ALIGN, ICON_Money, StrParam(c:ICON_Money), "j", "ERFONT",  OFF, OFF, noteFadeIn_Short, noteHold_Standart, noteFadeOut_Standart);
}




/*



  ______  __       __   _______ .__   __. .___________.    _______. __   _______   _______
 /      ||  |     |  | |   ____||  \ |  | |           |   /       ||  | |       \ |   ____|
|  ,----'|  |     |  | |  |__   |   \|  | `---|  |----`  |   (----`|  | |  .--.  ||  |__
|  |     |  |     |  | |   __|  |  . `  |     |  |        \   \    |  | |  |  |  ||   __|
|  `----.|  `----.|  | |  |____ |  |\   |     |  |    .----)   |   |  | |  '--'  ||  |____
 \______||_______||__| |_______||__| \__|     |__|    |_______/    |__| |_______/ |_______|


*/


/*
for (int a = 0; a < 32787;  a++) {
  if (a == 11 || a == 22 || a ==33) {//this is your exception
    continue; //do nothing and progress with the loop
  }
  DoStuff(); //do the stuff you need here
}
*/







SCRIPT "CLIENTZDA" OPEN
{
int counter;
delay(1);
while(!GetSectorLightLevel(TIDRAM_MapReset))
		{
		if (GetPort() == ZDaemon)		Client_NamedExecute(-1, "CLIENTLOGIC", 0);


				/*
		  __  __  ___  _   _ _______   __
		 |  \/  |/ _ \| \ | | ____\ \ / /
		 | |\/| | | | |  \| |  _|  \ V /
		 | |  | | |_| | |\  | |___  | |
		 |_|  |_|\___/|_| \_|_____| |_|

		*/

		counter = 0;
		while(counter < MaxPlayers)
			{
			RegisterMoney(counter, FALSE);
			counter++;
			}

		delay(SEC);
		if(GetPort() == ZDaemon)	if (PlayerStatus(-1) > ps_DEAD)		if(GAMEINFO[AbsoluteTime] > 60)		if(!GetSectorLightLevel(TIDRAM_CantJoinZDA))		Light_ChangeToValue(TIDRAM_CantJoinZDA, TRUE);
		GAMEINFO[AbsoluteTime]++;

		//if(GetSectorLightLevel(MGRAM_Sequence) > 0)			Light_ChangeToValue(MGRAM_Sequence, GetSectorLightLevel(MGRAM_Sequence) - 1);
		}
}






SCRIPT "CLIENTZAN" OPEN CLIENTSIDE
{
delay(1);

//Multiplayer
	if (!GAMEINFO[PortIs])
			{
			SetActivatorToPlayer(ConsolePlayerNumber());
			ACS_NamedExecute("CLIENTLOGIC", 0);
			}

//singleplayer
	if (GetPort() == GZDoom)		Terminate;
	if (GetPort() == Zandronum)	if (!IsNetworkGame()) 			{

																SetActivatorToPlayer(ConsolePlayerNumber());
																ACS_NamedExecute("CLIENTLOGIC", 0);

																}
}





function void ClientScreen (int TURN)
{
int img;

Switch(TURN)
		{
		CASE ON:		img = ICON_BlackScreen;		break;
		CASE OFF:		img = ICON_None;			break;
		}

SetHUDSize(HUDX_FULLSCREEN, HUDY_FULLSCREEN, FALSE);		SetFont("ERICON");


		HudMessage(		c:img;		HUDMSG_PLAIN, HUDid_MGback1, CR_BLACK, int2fix(X_FULLSCREEN - 16), 	int2fix(Y_FULLSCREEN),  	0.05);
		HudMessage(		c:img;		HUDMSG_PLAIN, HUDid_MGback2, CR_BLACK, int2fix(X_FULLSCREEN - 8), 	int2fix(Y_FULLSCREEN),  	0.05);
		HudMessage(		c:img;		HUDMSG_PLAIN, HUDid_MGback3, CR_BLACK, int2fix(X_FULLSCREEN), 		int2fix(Y_FULLSCREEN),  	0.05);
		HudMessage(		c:img;		HUDMSG_PLAIN, HUDid_MGback4, CR_BLACK, int2fix(X_FULLSCREEN + 8), 	int2fix(Y_FULLSCREEN),  	0.05);
		HudMessage(		c:img;		HUDMSG_PLAIN, HUDid_MGback5, CR_BLACK, int2fix(X_FULLSCREEN + 16), 	int2fix(Y_FULLSCREEN),  	0.05);
}



#libdefine		mg_OFF							0
#libdefine		mg_SELECT						1
#libdefine		mg_USE							2
#libdefine		mg_BUY							3
#libdefine		mg_PLACE						4


#libdefine		MGRAM_Sequence					12000
#libdefine		MGRAM_Player					12100			#libdefine	gcp_PLAYER	1
#libdefine		MGRAM_Unit						12200			#libdefine	gcp_UNIT	2
#libdefine		MGRAM_Power						12300			#libdefine	gcp_POWER	3
#libdefine		MGRAM_Sale						12400			#libdefine	gcp_SALE	4


#libdefine		MG_MaxCELLS						39
#libdefine 		MG_SlotEmpty					99
#libdefine 		MG_msgHold						0.05

#libdefine 		MG_YROOT						64

#libdefine 		HUDID__MG_Layout			13050
#libdefine 		HUDID__MG_Selection				13049
#libdefine 		HUDID__MG_playa					13048

#libdefine button_ACTION 	0
#libdefine button_QUIT 		1



function int GetCellProperty (int Which, int Cell)
{
int Result;
Switch(Which)
	{
	CASE gcp_PLAYER:	Result = GetSectorLightLevel(MGRAM_Player 	+ Cell);
	CASE gcp_UNIT:		Result = GetSectorLightLevel(MGRAM_Unit 	+ Cell);
	CASE gcp_POWER:		Result = GetSectorLightLevel(MGRAM_Power 	+ Cell);
	CASE gcp_SALE:		Result = GetSectorLightLevel(MGRAM_Sale		+ Cell);
	}

return Result;
}


function int GetSliderSpeed (int Power)
{
int Result;

if 				(Power <  40)								Result = 1;
else if 	(	(Power >= 40)	&&	(Power < 80)	)		Result = 2;
else if 	(	(Power >= 80)	&&	(Power <120)	)		Result = 3;
else if 	(	(Power >=120)	&&	(Power <160)	)		Result = 4;
else if 	(	(Power >=160)	&&	(Power <200)	)		Result = 5;
else if 	(	(Power >=200)	&&	(Power <240)	)		Result = 6;
else														Result = 7;

return Result;
}


/*
function int GetUnitProperty (int Which, int Cell)
{
int Result;
Switch(Which)
	{
	CASE gcp_PLAYER:	Result = GetSectorLightLevel(MGRAM_Player 	+ Cell);
	CASE gcp_UNIT:		Result = GetSectorLightLevel(MGRAM_Unit 	+ Cell);
	CASE gcp_POWER:		Result = GetSectorLightLevel(MGRAM_Power 	+ Cell);
	CASE gcp_SALE:		Result = GetSectorLightLevel(MGRAM_Sale		+ Cell);
	}

return Result;
}

*/





Script "CLIENTLOGIC" (void) CLIENTSIDE
{

int Vector, wX, wY, wZ, rX, rY;
int SelectionAt, Deelay, counter, Power, Slider, Range, Carrying;
bool Died;
int MiniGame;

while(!GetSectorLightLevel(TIDRAM_MapReset))
	{


	if (GetPort() != GZDoom)
		Switch(PlayerIsSpectator(ConsolePlayerNumber()))


			{
			CASE NotSpectator:

				if(MiniGame)
						{
						MiniGame = FALSE;
						Vector = 0;
						}


					//EXIT MARKER	based on script by Kaminsky
					if (GetSectorLightLevel(TIDRAM_ExitMarkerA) > 0)
						if (PlayerStatus(ConsolePlayerNumber()) == ps_PLAYGROUND)
								{

								wX = GetActorX(GetSectorLightLevel(TIDRAM_ExitMarkerA)*100 + GetSectorLightLevel(TIDRAM_ExitMarkerB)) - GetActorX(PLAYER_TID + ConsolePlayerNumber());
								wY = GetActorY(GetSectorLightLevel(TIDRAM_ExitMarkerA)*100 + GetSectorLightLevel(TIDRAM_ExitMarkerB)) - GetActorY(PLAYER_TID + ConsolePlayerNumber());
								wZ = GetActorZ(GetSectorLightLevel(TIDRAM_ExitMarkerA)*100 + GetSectorLightLevel(TIDRAM_ExitMarkerB)) + (GetActorProperty(GetSectorLightLevel(TIDRAM_ExitMarkerA)*100 + GetSectorLightLevel(TIDRAM_ExitMarkerB), APROP_HEIGHT) >> 1) - (GetActorZ(PLAYER_TID + ConsolePlayerNumber()) + GetActorViewHeight(PLAYER_TID + ConsolePlayerNumber()));

								rX = FixedMul(wX, cos(GetActorAngle(PLAYER_TID + ConsolePlayerNumber()))) + FixedMul(wY, sin(GetActorAngle(PLAYER_TID + ConsolePlayerNumber())));
								rY = -FixedMul(wX, sin(GetActorAngle(PLAYER_TID + ConsolePlayerNumber()))) + FixedMul(wY, cos(GetActorAngle(PLAYER_TID + ConsolePlayerNumber())));

								wX = FixedMul(rX, cos(GetActorPitch(PLAYER_TID + ConsolePlayerNumber()))) + FixedMul(wZ, sin(GetActorPitch(PLAYER_TID + ConsolePlayerNumber())));

									if(wX > 0)
									{
										wZ = -FixedMul(rX, sin(GetActorPitch(PLAYER_TID + ConsolePlayerNumber()))) + FixedMul(wZ, cos(GetActorPitch(PLAYER_TID + ConsolePlayerNumber())));

										SetFont("ERICON");
										SetHudSize((HUDX_BIG >> 1) << 1, (HUDY_BIG >> 1) << 1, true);

/*
										Switch(color)
											{
											CASE CR_YELLOW:	color = CR_ORANGE;	Vector = 0;											break;
											CASE CR_ORANGE:	if (!Vector)		color = CR_RED;		else 	color = CR_YELLOW;		break;
											CASE CR_RED:	color = CR_ORANGE;	Vector = 1;											break;
											}

*/
										HudMessage(c:ICON_Waypoint; HUDMSG_PLAIN, 25, CR_PURPLE, (((HUDX_BIG >> 1) << 16) - ((HUDX_BIG >> 1) * FixedDiv(rY, wX))) & 0xFFFF0000, int2fix(16), 0.05);		//((halfHeight << 16) - FixedMul(halfHeight * 1.6, FixedDiv(wZ, wX))) & 0xFFFF0000				int2fix(Y_TOP_ICON)
									}

								}



			break;

			CASE DeadSpectator:
				if (!Died)
						{
						Died = TRUE;
						LocalSetMusic(StrParam(s:"D_MUS", i:GetSectorLightLevel(TIDRAM_HubMusic)));
						}
			break;




			CASE TrueSpectator:

			break;
			}

												/*
												 ___      ___   __    _____  ___    __     _______       __       ___      ___   _______
												|"  \    /"  | |" \  (\"   \|"  \  |" \   /" _   "|     /""\     |"  \    /"  | /"     "|
												 \   \  //   | ||  | |.\\   \    | ||  | (: ( \___)    /    \     \   \  //   |(: ______)
												 /\\  \/.    | |:  | |: \.   \\  | |:  |  \/ \        /' /\  \    /\\  \/.    | \/    |
												|: \.        | |.  | |.  \    \. | |.  |  //  \ ___  //  __'  \  |: \.        | // ___)_
												|.  \    /:  | /\  |\|    \    \ | /\  |\(:   _(  _|/   /  \\  \ |.  \    /:  |(:      "|
												|___|\__/|___|(__\_|_)\___|\____\)(__\_|_)\_______)(___/    \___)|___|\__/|___| \_______)

												*/
//---------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------


	if (GetPort() != GZDoom)
		if (PlayerIsSpectator(ConsolePlayerNumber()) != NotSpectator)
			if (GetSectorLightLevel(TIDRAM_WinCamera) == 100)
				{

		/*
			 __                    __                    __
		 ___/ /______ __    __    / /__ ___ _____  __ __/ /_
		/ _  / __/ _ `/ |/|/ /   / / _ `/ // / _ \/ // / __/
		\_,_/_/  \_,_/|__,__/   /_/\_,_/\_, /\___/\_,_/\__/
									   /___/
		*/
		SetHUDSize(HUDX_BIG, HUDY_BIG, FALSE);			SetFont("ERICON");
		HudMessage(s:MG_Layout();						HUDMSG_PLAIN|HUDMSG_ALPHA, HUDID__MG_Layout, CR_BLACK, int2fix(HUDX_BIG/2), 	FixedMul((int2fix(HUDY_BIG/2 + MG_YROOT)), 1.0),  		MG_msgHold, 0.5);



		if (MiniGame > mg_OFF)
		{
				/*
											  __                               _ __
				  _______ _______  __ _____  / /_    __ _  __ __    __ _____  (_) /____
				 / __/ -_) __/ _ \/ // / _ \/ __/   /  ' \/ // /   / // / _ \/ / __(_-<
				/_/  \__/\__/\___/\_,_/_//_/\__/   /_/_/_/\_, /    \_,_/_//_/_/\__/___/
														 /___/
				*/
				Power = 0;
				counter = 0;
				while(counter < MG_MaxCELLS)
					{
					if (GetCellProperty(gcp_PLAYER, counter) == ConsolePlayerNumber())
									{
									Power += GetCellProperty(gcp_POWER, counter);
									}
					counter++;
					}


				/*
									 __      __  __              __    __
				 _______  __ _____  / /_    / /_/ /  ___     ___/ /__ / /__ ___ __
				/ __/ _ \/ // / _ \/ __/   / __/ _ \/ -_)   / _  / -_) / _ `/ // /
				\__/\___/\_,_/_//_/\__/    \__/_//_/\__/    \_,_/\__/_/\_,_/\_, /
																		   /___/
				*/
				if(!Deelay)
					{


						Switch(Slider)
							{
							CASE 1:	Deelay = 3;		Range = 1;		break;
							CASE 2:	Deelay = 2;		Range = 1;		break;
							CASE 3:	Deelay = 1;		Range = 1;		break;
							CASE 4:	Deelay = 0;		Range = 1;		break;
							CASE 5:	Deelay = 0;		Range = 2;		break;
							CASE 6:	Deelay = 0;		Range = 3;		break;
							CASE 7:	Deelay = 0;		Range = 4;		break;
							}



						Switch(Vector)
							{
							CASE ToRIGHT:	// -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> ->

											if(SelectionAt + Range 	>=	MG_MaxCELLS - 1)	{	Vector = ToLEFT;		}
									else	if(SelectionAt + Range 	<	MG_MaxCELLS)		{	SelectionAt += Range;	}


							break;	//   -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> -> ->


							CASE ToLEFT:	// <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <-

											if(SelectionAt - Range	<=	0)					{	Vector = ToRIGHT;		}
									else	if(SelectionAt - Range	> 	0)					{	SelectionAt -= Range;	}

							break;	//   <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <- <-
							}
					}

				else Deelay--;
		}






			/*
			   _____ _______    _______ ______       _____ _   _ _____  _    _ _______ _____
			  / ____|__   __|/\|__   __|  ____|     |_   _| \ | |  __ \| |  | |__   __/ ____|
			 | (___    | |  /  \  | |  | |__          | | |  \| | |__) | |  | |  | | | (___
			  \___ \   | | / /\ \ | |  |  __|         | | | . ` |  ___/| |  | |  | |  \___ \
			  ____) |  | |/ ____ \| |  | |____       _| |_| |\  | |    | |__| |  | |  ____) |
			 |_____/   |_/_/    \_\_|  |______|     |_____|_| \_|_|     \____/   |_| |_____/

			 */




					/*
					  _           _   _                     ___  _   _ ___ _____
					 | |__  _   _| |_| |_ ___  _ __  _     / _ \| | | |_ _|_   _|
					 | '_ \| | | | __| __/ _ \| '_ \(_)   | | | | | | || |  | |
					 | |_) | |_| | |_| || (_) | | | |_    | |_| | |_| || |  | |
					 |_.__/ \__,_|\__|\__\___/|_| |_(_)    \__\_\\___/|___| |_|

					*/

					if ((GetPlayerInput(ConsolePlayerNumber(), INPUT_BUTTONS) & ButtonIs(button_QUIT)) 		&& (!(GetPlayerInput(ConsolePlayerNumber(), INPUT_OLDBUTTONS) & ButtonIs(button_QUIT))))
						{

/*
								if(!Level)
											{
											Minigame = mg_PLACE;
											Vector = RNG(ToRIGHT, ToDOWN);	if (Vector == ToDOWN) Vector = ToLEFT;
											SelectionAt = RNG(0, MG_MaxCells - 1);
											}

*/
						}



					/*
					  _           _   _                       _    ____ _____ ___ ___  _   _
					 | |__  _   _| |_| |_ ___  _ __  _       / \  / ___|_   _|_ _/ _ \| \ | |
					 | '_ \| | | | __| __/ _ \| '_ \(_)     / _ \| |     | |  | | | | |  \| |
					 | |_) | |_| | |_| || (_) | | | |_     / ___ \ |___  | |  | | |_| | |\  |
					 |_.__/ \__,_|\__|\__\___/|_| |_(_)   /_/   \_\____| |_| |___\___/|_| \_|

					*/
					if ((GetPlayerInput(ConsolePlayerNumber(), INPUT_BUTTONS) & ButtonIs(button_ACTION)) 		&& (!(GetPlayerInput(ConsolePlayerNumber(), INPUT_OLDBUTTONS) & ButtonIs(button_ACTION))))
						{



						Switch(Minigame)
								{


									/*
									   ___  _____ _____
									  / _ \|  ___|  ___|
									 | | | | |_  | |_
									 | |_| |  _| |  _|
									  \___/|_|   |_|

									*/

									CASE mg_OFF:
									Power = 0;
									Slider = GetSliderSpeed(Power);
									Vector = RNG(ToRIGHT, ToDOWN);	if (Vector == ToDOWN) Vector = ToLEFT;
									SelectionAt = RNG(0, MG_MaxCells - 1);
									Carrying = unit_HOME;

									MiniGame = mg_PLACE;

									BREAK;







									/*
									  ____  _____ _     _____ ____ _____
									 / ___|| ____| |   | ____/ ___|_   _|
									 \___ \|  _| | |   |  _|| |     | |
									  ___) | |___| |___| |__| |___  | |
									 |____/|_____|_____|_____\____| |_|

									*/

									CASE mg_SELECT:




									BREAK;







									/*
									  _   _ ____  _____
									 | | | / ___|| ____|
									 | | | \___ \|  _|
									 | |_| |___) | |___
									  \___/|____/|_____|

									*/
									CASE mg_USE:



									BREAK;







									/*
									  ____  _   ___   __
									 | __ )| | | \ \ / /
									 |  _ \| | | |\ V /
									 | |_) | |_| | | |
									 |____/ \___/  |_|

									*/

									CASE mg_BUY:



									BREAK;








									/*
									  ____  _        _    ____ _____
									 |  _ \| |      / \  / ___| ____|
									 | |_) | |     / _ \| |   |  _|
									 |  __/| |___ / ___ \ |___| |___
									 |_|   |_____/_/   \_\____|_____|

									*/


									CASE mg_PLACE:

									ClientCall

									BREAK;
								}



						}








			/*
			   _____ _______    _______ ______        _____ _____            _____  _    _ _____ _____  _____
			  / ____|__   __|/\|__   __|  ____|      / ____|  __ \     /\   |  __ \| |  | |_   _/ ____|/ ____|
			 | (___    | |  /  \  | |  | |__        | |  __| |__) |   /  \  | |__) | |__| | | || |    | (___
			  \___ \   | | / /\ \ | |  |  __|       | | |_ |  _  /   / /\ \ |  ___/|  __  | | || |     \___ \
			  ____) |  | |/ ____ \| |  | |____      | |__| | | \ \  / ____ \| |    | |  | |_| || |____ ____) |
			 |_____/   |_/_/    \_\_|  |______|      \_____|_|  \_\/_/    \_\_|    |_|  |_|_____\_____|_____/

			*/







						Switch(MiniGame)
								{




								/*
								   ___  _____ _____
								  / _ \|  ___|  ___|
								 | | | | |_  | |_
								 | |_| |  _| |  _|
								  \___/|_|   |_|

								*/

								CASE mg_OFF:



								BREAK;







								/*
								  ____  _____ _     _____ ____ _____
								 / ___|| ____| |   | ____/ ___|_   _|
								 \___ \|  _| | |   |  _|| |     | |
								  ___) | |___| |___| |__| |___  | |
								 |____/|_____|_____|_____\____| |_|

								*/

								CASE mg_SELECT:



								BREAK;







								/*
								  _   _ ____  _____
								 | | | / ___|| ____|
								 | | | \___ \|  _|
								 | |_| |___) | |___
								  \___/|____/|_____|

								*/
								CASE mg_USE:



								BREAK;







								/*
								  ____  _   ___   __
								 | __ )| | | \ \ / /
								 |  _ \| | | |\ V /
								 | |_) | |_| | | |
								 |____/ \___/  |_|

								*/

								CASE mg_BUY:



								BREAK;








								/*
								  ____  _        _    ____ _____
								 |  _ \| |      / \  / ___| ____|
								 | |_) | |     / _ \| |   |  _|
								 |  __/| |___ / ___ \ |___| |___
								 |_|   |_____/_/   \_\____|_____|

								*/


								CASE mg_PLACE:




								BREAK;



							}

						/*
							   ___    __
						  ___ / (_)__/ /__ ____
						 (_-</ / / _  / -_) __/
						/___/_/_/\_,_/\__/_/

						*/

						Switch(Minigame)
								{
								CASE mg_BUY:
								CASE mg_PLACE:
								SetHUDSize(HUDX_BIG, HUDY_BIG, FALSE);		SetFont("ERFONT");														//80
								HudMessage(s:"C";							HUDMSG_PLAIN, 0,	MG_Color(GetSectorLightLevel(MGRAM_Player + ConsolePlayerNumber())), 	int2fix(HUDX_BIG/2) + SelectionX(SelectionAt, 1.0), 				FixedMul((int2fix(HUDY_BIG/2 + MG_YROOT)), 1.0),  		MG_msgHold);
								break;
								}

						/*
							 __                       ____            _ __
						 ___/ /______ __    __  ___ _/ / / __ _____  (_) /____
						/ _  / __/ _ `/ |/|/ / / _ `/ / / / // / _ \/ / __(_-<
						\_,_/_/  \_,_/|__,__/  \_,_/_/_/  \_,_/_//_/_/\__/___/

						*/
						Switch(Minigame)
								{
								CASE mg_OFF:
								CASE mg_SELECT:
								CASE mg_USE:
								CASE mg_PLACE:




								SetHUDSize(HUDX_BIG, HUDY_BIG, FALSE);		SetFont("MINIGAME");
								counter = 0;
								while(counter < MG_MaxCELLS)
									{
									HudMessage(c:GetCellProperty(gcp_UNIT, counter);							HUDMSG_PLAIN, 0,	MG_Color(GetCellProperty(gcp_PLAYER, counter)), 	int2fix(HUDX_BIG/2) + SelectionX(counter, 1.0), 	FixedMul((int2fix(HUDY_BIG/2 + MG_YROOT)), 1.0),  		MG_msgHold);
									counter++;
									}

								break;
								}



			}




//				if(GetSectorLightLevel(MGRAM_Sequence) > 0)
//					{


/*




						if(Selected == FALSE)
							if(!Deelay)
							{
							Deelay = 0;

							Switch(Vector)
								{
								CASE ToRIGHT:	// ->

												if(SelectionAt 	>=	MG_MaxCELLS - 1)	{	Vector = ToLEFT;	}
										else	if(SelectionAt 	<	MG_MaxCELLS)		{	SelectionAt++;		}

								break;


								CASE ToLEFT:	// <-

												if(SelectionAt	<=	0)					{	Vector = ToRIGHT;	}
										else	if(SelectionAt	> 	0)					{	SelectionAt--;		}

								break;
								}

							}
							else Deelay--;


					SetHUDSize(HUDX_SMALL, HUDY_SMALL, FALSE);	SetFont("ERFONT");
					HudMessage(n:ConsolePlayerNumber() + 1;		HUDMSG_PLAIN, 0	,	MG_Color(GetSectorLightLevel(MGRAM_Player + ConsolePlayerNumber())), 	int2fix(HUDX_SMALL/2) + SelectionX(SelectionAt, 3.44), 				FixedMul((int2fix(HUDY_SMALL/2 + MG_YROOT)), 1.2),  	0.075);

					SetHUDSize(HUDX_BIG, HUDY_BIG, FALSE);		SetFont("ERFONT");														//80
					HudMessage(s:"C";							HUDMSG_PLAIN, 0,	MG_Color(GetSectorLightLevel(MGRAM_Player + ConsolePlayerNumber())), 	int2fix(HUDX_BIG/2) + SelectionX(SelectionAt, 1.0), 					FixedMul((int2fix(HUDY_BIG/2 + MG_YROOT)), 1.0),  		0.05);


//					}

*/


	if (GetSectorLightLevel(TIDRAM_WinCamera) < 100)
			if (PlayerStatus(ConsolePlayerNumber()) != ps_INPUT)
					if (GetSectorLightLevel(TIDRAM_WinCamera) < 99)		ChangeCamera(PLAYER_TID + TIDRAM_WinCamera, 0, 0);
							else 										ChangeCamera(PLAYER_TID + ACTORTID_SkyboxCamera, 0, 0);

		//SHOW MONEY
		//if (GetSectorLightLevel(TIDRAM_Money + ConsolePlayerNumber()) > 0)
				{
				SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, FALSE);
				SetFont("ERFONT");
				HudMessage(s:"$";									HUDMSG_FADEOUT|HUDMSG_ALPHA, 			HUDid_MoneyIcon, 	CR_GOLD, 		int2fix(X_TOP_ICON), 	int2fix(Y_MONEY), 1.0, 1.0, 1.0);
				SetFont("ERFONT");
				HudMessage(i:GetSectorLightLevel(TIDRAM_Money + ConsolePlayerNumber());			HUDMSG_FADEOUT|HUDMSG_ALPHA, 			HUDid_MoneyValue, 	CR_GOLD, 		int2fix(X_TOP_LETTER), 	int2fix(Y_MONEY), 1.0, 1.0, 1.0);
				SetFont("ERICON");
				HudMessage(s:"aggggggggb\neiiiiiiiif\nchhhhhhhhd";	HUDMSG_FADEOUT|HUDMSG_ALPHA, 			HUDid_MoneyBack, 	CR_BLACK, 		int2fix(X_TOP_BACK), 	int2fix(Y_MONEY), 1.0, 1.0, 0.25);
				}







	delay(1);
	}

}


function str MG_Layout (void)
{
str Result = "qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq";
return Result;
}


function int SelectionX (int Selection, int Multiply)
{
int Result;
int Middle = (MG_MaxCells - 1)/2;	//10;

		if (Selection < Middle) 	Result = (Middle - Selection) * -1;
else	if (Selection > Middle) 	Result = (Selection - Middle);
else	Result = 0;

Result = FixedMul(int2fix(Result*8), Multiply);
return Result;
}


function int MG_Color	(int PlayerNum)
{
int Result;
Switch(PlayerNum)
	{
	CASE 0:	Result = CR_BRICK;	break;		CASE 1:	Result = CR_TAN;	break;		CASE 2:	Result = CR_GREEN;	break;		CASE 3:	Result = CR_BROWN;	break;		CASE 4:	Result = CR_GOLD;	break;		CASE 5:	Result = CR_RED;	break;
	CASE 6:	Result = CR_BLUE;	break;		CASE 7:	Result = CR_ORANGE;	break;		CASE 8:	Result = CR_YELLOW;	break;		CASE 9:	Result = CR_CREAM;	break;		CASE 10:Result = CR_OLIVE;	break;		CASE 11:Result = CR_PURPLE;	break;
	CASE 12:Result = CR_BRICK;	break;		CASE 13:Result = CR_TAN;	break;		CASE 14:Result = CR_GREEN;	break;		CASE 15:Result = CR_BROWN;	break;		CASE 16:Result = CR_GOLD;	break;		CASE 17:Result = CR_RED;	break;
	CASE 18:Result = CR_BLUE;	break;		CASE 19:Result = CR_ORANGE;	break;		CASE 20:Result = CR_YELLOW;	break;		CASE 21:Result = CR_CREAM;	break;		CASE 22:Result = CR_OLIVE;	break;		CASE 23:Result = CR_PURPLE;	break;
	CASE 24:Result = CR_BRICK;	break;		CASE 25:Result = CR_TAN;	break;		CASE 26:Result = CR_GREEN;	break;		CASE 27:Result = CR_BROWN;	break;		CASE 28:Result = CR_GOLD;	break;		CASE 29:Result = CR_RED;	break;
	CASE 30:Result = CR_BLUE;	break;		CASE 31:Result = CR_ORANGE;	break;								/*	AI	*/		CASE 32:Result = CR_WHITE;	break;		/*	NONE	*/							CASE 99:Result = CR_GRAY;	break;
	}
return Result;
}



function int ButtonIs (int Which)
{
int Result, BT_ACTION, BT_QUIT;

Switch(GetPort())
	{
	CASE Zandronum:		BT_ACTION = BT_ATTACK;		BT_QUIT = BT_USE;	break;
	CASE ZDaemon:		BT_ACTION = BT_JUMP;		BT_QUIT = BT_USE;	break;
	}

Switch(which)
	{
	CASE button_ACTION:	Result = BT_ACTION;		break;
	CASE button_QUIT:	Result = BT_QUIT;		break;
	}
return Result;
}




